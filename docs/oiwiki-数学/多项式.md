###### 1，多项式简介

+ 1，度

对于一个多项式 ，称其最高次项的次数为该多项式的 **度（Degree）**，记作 $deg~f$。

+ 2，多项式乘法

$f_x = a_0+a_1\times x+..+a_n\times x^n$

$g_x = b_0+b_1\times x+..+b_n\times x^n$

$Q_x=f_x\times g_x=\sum\limits_{i=0}^n\sum\limits_{j=0}^m a_i\times b_j\times x^{i+j}=c_0+c_1\times x+..+c_{n+m}\times x^{n+m}$

+ 3，多项式逆元

$f_x\times g_x\equiv 1(mod~x^n)$

$g_x为f_x在模x^n的意义下的逆元，记f^{-1}_x$

$若deg~g<n，则g唯一$

+ 4，多项式的余数和商 （多项式除法）

对于多项式 $f_x,~g_x$，则存在唯一的 $Q_x,~R_x$ 满足：

$f_x=Q_x\times g_x+R_x~~\&\&~~deg~R<deg~g$

$deg~f\ge deg~g时，deg~Q=deg~f-deg~g，否则Q_x=0$ （整除？？）

$Q_x为g_x除f_x的商(quotient)，R_x为g_x除f_x的余数(remainder)$

$亦可记作f_x\equiv R_x(mod~g_x)$

+ 5，多项式的对数函数与指数函数

$ln(1-f_x) = -\sum\limits_{i=1}^{+\infty} \frac{f_x^i}{i}$

$ln(1+f_x) = \sum\limits_{i=1}^{+\infty} (-1)^{i-1}\times\frac{f_x^i}{i}$

$exp~f_x=e^{f_x}=\sum\limits_{i=0}^{+\infty}\frac{f_x^i}{i!}$

+ 6，多项式的多点求值和插值

1）多项式的多点求值($Multi-point~evaluation$)：

给出一个多项式$f_x$和n个点$x_1，x_2，..，x_n$，求$f_{x_1}, f_{x_2}, .., f_{x_n}$

即 $x_i ~\to~ f_{x_i}（i=0..n）$

2）多项式的插值($Interpolation$)：

给出$n+1$个点$(x_0,y_0), (x_1, y_1), .., (x_n, y_n)$，求一个n次多项式$f_x$使得这n+1个点都在$f_x$上

即 $(x_i,~f_{x_i}) ~\to~ f_x (i=0..n)$

$这两种操作实质上是多项式的~系数表示~和~点值表示~的转化$

+ 补充：多项式的表示法（假设对 $n$ 次多项式而言）

+ + 系数表示法

$f_x = \{ a_0,~a_1,a_2,~...,~a_n \}$

多项式乘法的复杂度： $O(n^2)$

+ + 点值表示法

$f_x ~=~ \{(x_0,~f_{x_0},~(x_1,~f_{x_1}),~...,~(x_n,~f_{x_n}))\}$

多项式乘法：

设另一个多项式为 $g_x ~~=~~ \{(x_0,~~g_{x_0},~~(x_1,~~g_{x_1}),~~...,~~(x_n,~~g_{x_n}))\}$

则有：$f_x\times g_x ~=~ f_x ~~=~~ \{(x_0,~~f_{x_0}\times g_{x_0}),~~(x_1,~~f_{x_1}\times g_{x_1}),~~...,~~(x_n,~~f_{x_n}\times g_{x_n}))\}$

复杂度为 $O(n)$

###### 2，代数基本定理（待补）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-17-23-23-16-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-17-23-23-52-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-17-23-30-46-image.png)

（复系数多项式？复变函数？近世代数？）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-17-23-32-21-image.png)

+ 虚根成对定理

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-17-23-33-47-image.png)

+ + ![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-17-23-40-43-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-17-23-40-28-image.png)

+ + ![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-17-23-41-07-image.png)

+ + ![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-18-10-59-15-image.png)

（？？？）

+ + ![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-18-11-07-26-image.png)

+ 林士谔算法（玄学，nnd，待补！！）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-18-12-16-23-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-18-12-17-21-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-18-12-17-34-image.png)

原理：

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-18-16-52-19-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-18-16-52-32-image.png)

```cpp
const double eps = 1e-6;

double b[1000], c[1000];
void shie(double a[], int n, double *p, double *q){
    memset(b, 0, sizeof b);
    memset(c, 0, sizeof c);
    *p = *q = 0;
    double dp = 1, dq = 1;
    while(dp > eps || dp < -eps || dq > eps || dq < -eps){
        double p0 = *p, q0 = *q;
        b[n - 2] = a[n];
        c[n - 2] = b[n - 2];
        b[n - 3] = a[n - 1] - p0 * b[n - 2];
        c[n - 3] = b[n - 3] - p0 * b[n - 2];
        int j;
        for(j = n - 4; ~j; --j){
            b[j] = a[j + 2] - p0 * b[j + 1] - q0 * b[j + 2];
            c[j] = b[j] - p0 * c[j + 1] - q0 * c[j + 2];
        }
        double r = a[1] - p0 * b[0] - q0 * b[1];
        double s = a[0] - q0 * b[0];
        double rp = c[1];
        double sp = b[0] - q0 * c[2];
        double rq = c[0];
        double sq = -q0 * c[1];
        dp = (rp * s - r * sp) / (rp * sq - rq * sp);
        dq = (r * sq - rq * s) / (rp * sq - rq * sp);
        *p += dp;
        *q += dq;
    }
}
```

###### 3，拉格朗日插值法

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-18-18-27-05-image.png)

引理： $f_x ~=~ f_a \pmod{(x-a)}$  （万恶之源（bushi）

证：$f_x-f_a=(a_0-a_0)+a_1(x^1-a^1)+a_1(x^2-a^2)+\cdots +a_n(x^n-a^n)$ 然有 $(x-a)$ 这个因式，所以得证

这样我们就可以列一个关于 $f_x$ 的多项式线性同余方程组

$\begin{cases}
f_x\equiv f_{x_1}\pmod{(x-x_1)}\\
f_x\equiv f_{x_2}\pmod{(x-x_2)}\\
\cdots\\
f_x\equiv f_{x_n}\pmod{(x-x_n)}
\end{cases}$

（$f_x$ 为带求函数值）

根据 $crt$ 定理，设$\displaystyle M=\prod_{i=1}^n{(x-x_i)},m_i=\dfrac M{x-x_i}=\prod_{j\ne i}{(x-x_j)}$

则 $m_i$ 模 $(x-x_i)$ 意义下的逆元就是： $\displaystyle m_i^{-1}=\prod_{j\ne i}{\dfrac 1{x_i-x_j}}$

（至于 $x$ 怎么变成 $x_i$ 的，可能是因为玄学吧）

所以，$\displaystyle f_x\equiv\sum_{i=1}^n{f_{x_i}\times  m_i\times m_i^{-1}}\equiv\sum_{i=1}^n{f_{x_i} \times \prod_{i=1}^n{\dfrac {x-x_j}{x_i-x_j}}}[j \ne i]\pmod M$

（其中 $f_x$ 是 $n-1$次多项式；而 $n$ 次多项式需要预处理 $n+1$ 个点）

[P4781 【模板】拉格朗日插值 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4781)

复杂度：$O(n^2)$

```cpp
const int N = 2e3+3;
int n, k;
int x[N], y[N];
int fp(int a, int n, int P){
    int ans = 1;
    while(n){
        if(n & 1) ans = ans * a % P;
        a = a * a % P;
        n >>= 1;
    }
    return ans;
}
int inv(int n){ return fp(n, P-2, P);}

int crt(int y[], int x[]){
    int ans = 0;
    for(int i=1; i<=n; ++i){
        int s1 = 1, s2 = 1;
        for(int j=1; j<=n; ++j)
            if(j != i)
                s1 = s1 * (k - x[j] + P) % P, s2 = s2 * (x[i] - x[j]) % P;
        ans = (ans + y[i] * s1 % P * inv(s2) % P) % P;
    }
    return (ans % P + P) % P;
}
```

+ 横坐标是连续整数的拉格朗日插值 $O(n)$

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-19-11-34-14-image.png)

（即 已知 $f_{x_i},~i=1..n+1$，（n 为多项式的次数） 或 $f_{x_i}$ 易求）    

$\begin{aligned}
f(x)&=\sum\limits_{i=1}^{n+1}y_i\times \prod\limits_{j=1}^{n+1}\frac{x-x_j}{x_i-x_j} [j\ne i] \\
&= \sum_{i=1}^{n+1}y_i\times \frac{\prod\limits_{j=1}^{n+1}(x-j) [j\ne i]}{\prod\limits_{j=1}^{n+1}(i - j) [j\ne i]} \\ &= \sum_{i=1}^{n+1}y_i\times \frac{\prod\limits_{j=1}^{n+1}(x-j) [j\ne i]}{(-1)^{n+1-i}\times (i-1)!\times (n+1-i)!}
\end{aligned}$

（$y_i$ 可以线性筛 或 题目给出；分子可以用前缀积和后缀积求得；分母：求连续整数的逆元 $\to$ 求逆元的前缀积，即可求得阶乘的逆元）

（注意：）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-19-12-04-08-image.png)

[Problem - F - Codeforces](https://codeforces.com/contest/622/problem/F)

易知 $f_{n,~k} = \sum\limits_{i=1}^n i^k$ 是函数值为 $n$ 的 $k+1$ 次多项式（ $???$ ），所以可以用拉格朗日插值法

复杂度：$O(n)$  而不是 $O(x)$ （$n$ 称为多项式的度）

```cpp
#include<iostream>
using namespace std;

#define int long long
const int N = 1e6+3, P = 1e9+7;
int x, k;

int fp(int a, int n){ int ans = 1; while(n){ if(n & 1) ans = ans * a % P; a = a * a % P; n >>= 1; } return ans; }

int p[N], idx, st[N], f[N];
// 预处理插值 （n至少为多项式次数 + 1） 
void gp(int n){
    f[1] = 1;
    for(int i=2; i<=n; ++i){
        if(!st[i]) p[ ++ idx] = i, f[i] = fp(i, k);
        for(int j=1; p[j]<=n/i; ++j){
            st[i * p[j]] = true;
//            幂函数的是完全积性函数
            f[i * p[j]] = f[i] * f[p[j]] % P;
            if(!(i % p[j])) break;
        }
    }
    for(int i=1; i<=n; ++i) f[i] = (f[i-1] + f[i]) % P;
}

// 预处理 \segma(i - x) 和 阶乘逆元 
int pre[N], suf[N], ifac[N];
void init(){
    int n = k + 2;
    pre[0] = suf[n + 1] = 1;
    for(int i=1; i<=n; ++i) pre[i] = pre[i-1] * (i - x + P) % P;
    for(int i=n; i>=1; --i) suf[i] = suf[i+1] * (i - x + P) % P;

    // 注意 ifac[0] 也可以取到！！ 
    ifac[0] = ifac[1] = 1;
    for(int i=2; i<=n; ++i) ifac[i] = (P - P / i) * ifac[P % i] % P;
    for(int i=2; i<=n; ++i) ifac[i] = ifac[i-1] * ifac[i] % P;
}

int lag(){
    int n = k + 2;
    gp(n);
    if(x <= n) return f[x];
    init();

    int ans = 0;
    for(int i=1; i<=n; ++i){
        int pp = pre[i-1] * suf[i+1] % P;
        int qq = (i-1&1 ? -1 : 1) * ifac[i-1] * ifac[n-i] % P + P;
        ans = (ans + f[i] * pp % P *qq % P + P) % P;
    }
    return ans;
}

signed main(){
    cin >> x >> k;
    cout << lag() << '\n';
}
```

+ [P5667 拉格朗日插值2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5667)

###### 4，快速傅里叶变换 FFT

全过程：$系数表示\to 点值表示 \to 多项式乘法O(n) \to res多项式的点值表示 \to res 的系数表示$

（$fft$ 使得两种表示法的转换复杂度为 $O(n\log{n})$）

本文将介绍一种算法，它支持在 $O(n\log n)$ 的时间内计算两个 $n$ 度的多项式的乘法，比朴素的 $O(n^2)$ 算法更高效。由于两个整数的乘法也可以被当作多项式乘法，因此这个算法也可以用来**加速大整数的乘法**计算。

$\displaystyle X_k=\sum_{n=0}^{N-1}x_ne^{\frac{-2\pi ikn}{N}}$

$\displaystyle x_n=\sum_{k=0}^{N-1}X_ke^{\frac{-2\pi ikn}{N}}$

+ 前置：**复数**

+ 引入：

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-15-26-35-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-15-26-51-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-15-27-03-image.png)

$c_{i} ~=~ \sum\limits_{j=0}^{i}a_j[j\le|A|]\times b_{i-j}[i-j\le|B|]$

（$[~]$ 内为 $false$ ，则左边的值为 $1$ 而非 $0$）

$fft$ 可以快速将多项式的 **系数表示法** 转换为 **点值表示法**，复杂度：$O(n\log{n})$

+ 1，傅里叶变换 FF（待补）

$Fourier~Transform$ 

+ 2，离散傅里叶变换 DFT（待补）

$Discrete~Fourier~Transform$

朴素的变换复杂度还是$O(n^2)$

+ 3，快速傅里叶变换 FFT

本质：分治的 $DFT$，系数表示法 $\to$ 点值表示法

复杂度：$O(n\log{n})$

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-15-41-46-image.png)

（插值？）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-15-42-36-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-15-43-06-image.png)

$\begin{aligned}
f(\omega_n^k) &= G((\omega_n^k)^2) + \omega_n^k \times H((\omega_n^k)^2) \\
 &= G(\omega_n^{2k}) + \omega_n^k \times H(\omega_n^{2k}) \\
 &= G(\omega_{n/2}^k) + \omega_n^k \times H(\omega_{n/2}^k)
\end{aligned}$

$\begin{aligned}
f(\omega_n^{k+n/2}) &= G(\omega_n^{2k+n}) + \omega_n^{k+n/2} \times H(\omega_n^{2k+n}) \\
 &= G(\omega_n^{2k}) - \omega_n^k \times H(\omega_n^{2k}) \\
 &= G(\omega_{n/2}^k) - \omega_n^k \times H(\omega_{n/2}^k)
\end{aligned}$

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-15-43-48-image.png)

递归版 $fft$：

```cpp
com t[N];
// rev = 1, DFT; rev = -1, IDFT
void DFT(com *f, int n, int rev){
    if(n == 1) return ;
    for(int i=0; i<n; ++i) t[i] = f[i];
    // 奇数项放右边，偶数项放左边 
    for(int i=0; i<n; ++i) f[n / 2 + (n & 1) * i / 2] = t[i];
    com *g = f, *h = f + n / 2;
    DFT(g, n / 2, rev), DFT(h, n / 2, rev);

    com cur(0, 1), delta(cos(2 * M_PI / n), sin(2 * M_PI / n * rev));
    for(int k=0; k<n/2; ++k){
        t[k] = g[k] + cur * h[k];
        t[k + n / 2] = g[k] - cur * h[k];
        cur *= delta;
    }
    for(int i=0; i<n; ++i) f[i] = t[i];
}
```

+ + 位逆序置换（蝴蝶变换）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-15-49-31-image.png)

（**可以解决递归版的内存问题**）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-15-50-21-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-15-50-37-image.png)

+ + + 方法1，复杂度$O(n\log{n})$

```cpp
void butter(com y[], int len){
    for(int i=1, j=len>>1, k; i<len-1; ++i){
        if(i < j) swap(y[i], y[j]);
        k = len >> 1;
        while(j >= k) j -= k, k >>= 1;
        if(j < k) j += k;
    }
}
```

+ + + 方法2，复杂度$O(n)$

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-15-53-43-image.png)

```cpp
int rev[N];
void butter(com y[], int len){
    for(int i=0; i<len; ++i){
        rev[i] = rev[i>>1]>>1 | (i & 1) * (len >> 1);
        if(i < rev[i]) swap(y[i], y[rev[i]]);
    }
}
```

+ + 傅里叶逆变换 $IDFT$

核心：点值表示法 $\to$ 系数表示法

（实现时只需稍加改动即可）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-15-56-48-image.png)

由于中间的大矩阵的元素非常特殊，它的逆矩阵也有特殊的性质，就是每一项 **取倒数**，再 **除以变换的长度** ，就能得到它的逆矩阵。

最终版 $fft$：（非递归）

```cpp
// 蝴蝶变换
void butter(com y[], int len){
    for(int i=1, j=len>>1, k; i<len-1; ++i){
        if(i < j) swap(y[i], y[j]);
        k = len >> 1;
        while(j >= k) j -= k, k >>= 1;
        if(j < k) j += k;
    }
}

void fft(com y[], int len, int op){
    butter(y, len);
    for(int n=2; n<=len; n<<=1){
        com wn(cos(2 * PI / n), sin(2 * PI / n * op));

        for(int j=0; j<len; j+=n){
            com w(1, 0);

            for(int k=j; k<j+n/2; ++k){
                com u = y[k], v = y[k + n/2] * w;
                y[k] = u + v;
                y[k + n / 2] = u - v;

                w *= wn;
            }
        }
    }
    if(~op) return ;
    for(int i=0; i<len; ++i) y[i] /= len;
}
```

（len 取大点也是没关系的）

+ [Problem - 1402 (hdu.edu.cn)](http://acm.hdu.edu.cn/showproblem.php?pid=1402)     

```cpp
#include<iostream>
#include<complex>
#include<cmath>
#include<cstring>
using namespace std;

typedef complex<double> com;
const double PI = acos(-1.0);

void butter(com y[], int len){
    for(int i=1, j=len>>1, k; i<len-1; ++i){
        if(i < j) swap(y[i], y[j]);
        k = len >> 1;
        while(j >= k) j -= k, k >>= 1;
        if(j < k) j += k;
    }
}

void fft(com y[], int len, int op){
    butter(y, len);
    for(int n=2; n<=len; n<<=1){
        com wn(cos(2 * PI / n), sin(2 * PI / n * op));

        for(int j=0; j<len; j+=n){
            com w(1, 0);

            for(int k=j; k<j+n/2; ++k){
                com u = y[k], v = y[k + n/2] * w;
                y[k] = u + v;
                y[k + n / 2] = u - v;

                w *= wn;
            }
        }
    }
    if(~op) return ;
    for(int i=0; i<len; ++i) y[i] /= len;
}

const int N = 1e5+3;
char a[N], b[N];
com A[N<<1], B[N<<1];
int c[N<<1];

int main(){
    while(cin >> a >> b){
        int l1 = strlen(a), l2 = strlen(b), l = 1;

        while(l < l1 * 2 || l < l2 * 2) l <<= 1;

        for(int i=0; i<l; ++i) A[i] = com((i < l1) * (a[l1 - i - 1] - '0'), 0);
        for(int i=0; i<l; ++i) B[i] = com((i < l2) * (b[l2 - i - 1] - '0'), 0);

        fft(A, l, 1), fft(B, l, 1);
        for(int i=0; i<l; ++i) A[i] *= B[i];
        fft(A, l, -1);

        for(int i=0; i<l; ++i) c[i] = A[i].real() + 0.5;
        for(int i=0; i<l; ++i) c[i + 1] += c[i] / 10, c[i] %= 10;

        l = l1 + l2 - 1;
        while(!c[l] && l > 0) -- l;
        for(int i=l; i>=0; --i) cout << c[i];
        cout << '\n';
    }
}
```

+ [P3803 【模板】多项式乘法（FFT） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3803)

```cpp
int n, m;
com a[N<<2], b[N<<2];

int main(){
    cin >> n >> m;
    for(int i=0, x; i<=n; ++i) cin >> x, a[i] = com(x, 0);
    for(int i=0, x; i<=m; ++i) cin >> x, b[i] = com(x, 0);

    int l = 1;
    while(l <= n + m) l <<= 1;
//    cout << l << '\n';

    fft(a, l, 1), fft(b, l, 1);
    for(int i=0; i<l; ++i) a[i] *= b[i];
    fft(a, l, -1);

    for(int i=0; i<=n+m; ++i) cout << int(a[i].real()+0.5) << ' ';
    cout << '\n';
}
```

###### 5，快速数论变换 NTT

（取模意义上的加强版 $fft$）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-21-22-10-image.png)

+ 离散傅里叶变换DFT

对于 $N$ 点序列 $\left\{x[n]\right\}_{0\le n <N}$

1，它的**离散傅里叶变换**（DFT）为

$\displaystyle \hat{x}[k]=\sum_{j=0}^{N-1} e^{-i\frac{2\pi}{N}jk}x[j] \qquad k = 0,1,\ldots,N-1.$

记 $\hat{x}=\mathcal{F}x$

2，**逆离散傅里叶变换**（IDFT）为：

$\displaystyle x\left[j\right]={1 \over N}\sum_{k=0}^{N-1} e^{ i\frac{2\pi}{N}jk}\hat{x}[k] \qquad j = 0,1,\ldots,N-1.$

记 $x=\mathcal{F}^{-1}\hat{x}$

3，注意到 $\omega_N^{-nk} = e^{-i\frac{2\pi}{N}nk} $，$k=0..N-1,~n=0..N-1$，容易想到这两个变换可以用矩阵表示

（记 $f_{x_k},~\alpha,~x_j$ 分别表示上述定义中的 $\hat{x}[k],~\omega_N^{-nk},~x\left[j\right]$）

得到 DFT 的矩阵形式：

${\displaystyle {\begin{bmatrix}f_{x_0}\\f_{x_1}\\\vdots \\f_{x_n-1}\end{bmatrix}}={\begin{bmatrix}1&1&1&\cdots &1\\1&\alpha &\alpha ^{2}&\cdots &\alpha ^{n-1}\\1&\alpha ^{2}&\alpha ^{4}&\cdots &\alpha ^{2(n-1)}\\\vdots &\vdots &\vdots &&\vdots \\1&\alpha ^{n-1}&\alpha ^{2(n-1)}&\cdots &\alpha ^{(n-1)(n-1)}\\\end{bmatrix}}{\begin{bmatrix}x_{0}\\x_{1}\\\vdots \\x_{n-1}\end{bmatrix}}.}$

IDFT 的矩阵形式：

${\displaystyle {\begin{bmatrix}x_{0}\\x_{1}\\\vdots \\x_{n-1}\end{bmatrix}} ~=~ \frac{1}{n}\times{\begin{bmatrix}1^{-1}&1^{-1}&1^{-1}&\cdots &1^{-1}\\1^{-1}&\alpha^{-1} &(\alpha ^{2})^{-1}&\cdots &(\alpha^{n-1})^{-1}\\1^{-1}&(\alpha ^{2})&(\alpha ^{4})^{-1}&\cdots &(\alpha ^{2(n-1)})^{-1}\\\vdots &\vdots &\vdots &&\vdots \\1^{-1}&(\alpha ^{n-1})^{-1}&(\alpha ^{2(n-1)})^{-1}&\cdots &(\alpha ^{(n-1)(n-1)})^{-1}\\\end{bmatrix}}{\begin{bmatrix}f_{x_0}\\f_{x_1}\\\vdots \\f_{x_{n-1}}\end{bmatrix}}.}$

（顺便复习 fft）

+ 生成子群（玄学）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-22-00-51-image.png)

+ 原根（玄学）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-22-01-09-image.png)

+ NTT（玄，但是代码好敲！！）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-22-06-10-image.png)

**常见的 P 和 g：**

$p = 1004535809 = 479 \times 2^{21}+1, g=3$

$p=998244353= 119 \times 2^{23}+1, g=3$   （ $7\times 17=119$）

$w_{n} ~\equiv~ g_n ~=~ g^{\frac{P-1}{n}}$，$g_n^{-1} = (g^{\frac{P-1}{n}})^{-1}$（即模 $P$ 的逆元）

（$g$ 为原根， $g_n$ 类似于 $fft$ 提到的单位根）

```cpp
#define int long long
const int P = (479<<21) + 1;
const int N = (1e6+3)*4;
int fp(int a, int n){
    int ans = 1;
    while(n){
        if(n & 1) ans = ans * a % P;
        a = a * a % P;
        n >>= 1;
    }
    return ans;
}

int rev[N];
void ntt(int y[], int len, int op){
    for(int i=0; i<len; ++i){
        rev[i] = rev[i>>1]>>1 | (i & 1) * (len >> 1);
        if(i < rev[i]) swap(y[i], y[rev[i]]);
    }
    for(int n=2; n<=len; n<<=1){
        int gn = fp(3, (P - 1) / n);
        // 逆变换处理方法1：
        if(op == -1) gn = fp(gn, P-2);

        for(int j=0; j<len; j+=n){
            int g = 1;
            for(int k=j; k<j+n/2; ++k){
                int u = y[k], v = y[k + n/2] * g % P;
                y[k] = (u + v) % P;
                y[k + n/2] = (u - v + P) % P;
                g = g * gn % P;
            }
        }
    }
    if(~op) return ;
//  逆变换处理方法2：
//    reverse(y + 1, y + len);
    int il = fp(len, P-2);
    for(int i=0; i<len; ++i) y[i] = y[i] * il % P;
}
```

###### 6，快速复数论变换 CNTT（待补）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-22-46-54-image.png)

[Number theoretic transforms to implement fast digital convolution | IEEE Journals & Magazine | IEEE Xplore](https://ieeexplore.ieee.org/document/1451721)

+ DFT 可逆的条件

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-22-47-30-image.png)

+ 模 $P$ 高斯整数环 $Z_p[i]$

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-22-48-31-image.png)

+ 常用模数的单位根
  
  $n=2^{21}$ 时 $p_-=999292927=2^{20}\times953-1$ 的 $p_-^2-1$ 次单位根 $\omega=1+8\text i$；

$n=2^{23}$ 时 $p_+=998244353=2^{23}\times119+1$ 的 $p_+-1$ 次单位根 $\omega=1+\text i$

$n=2^{16}$ 时 $p_+=65537=2^{16}+1$ 的 $p_+-1$ 次单位根 $\omega=4+17573\text i$

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_多项式_\assets\2022-07-20-22-54-10-image.png)

###### 7，快速沃尔什变换（待补）

沃尔什转换（Walsh Transform）是在频谱分析上作为离散傅立叶变换的替代方案的一种方法

[浅谈快速沃尔什变换 - Hyscere - 博客园 (cnblogs.com)](https://www.cnblogs.com/hbyer/p/10308815.html)

$fwt$ 可以解决类似以下的卷积

$\displaystyle C_{i} = \sum_{i=j \bigoplus k}A_{j} B_{k}$ ，$i=0..len$ （$\bigoplus$ 表示 $or$ 或 $and$ 或 $xor$ 或 $xnor$）

（而 $fft$ 解决的是这样的卷积 $\displaystyle C_{i} = \sum_{i=j ~~+~~ k}A_{j} B_{k}$）

+ 或运算

$\displaystyle C_{i} = \sum_{i=j ~or~~ k}A_{j} B_{k}$

$fwt[A] = merge(fwt[A_0],~~fwt[A_0] + fwt[A_1])$

$ifwt[A'] = merge(ifwt[A_0'],~~ifwt[A_1'] - ifwt[A_0'])$

（$ifwt[A'] ~=~ A$）

```cpp
void fwt_or(int y[], int len, int op){
    for(int n=2; n<=len; n<<=1){
        for(int j=0; j<len; j+=n){
            for(int k=j; k<j+n/2; ++k){
                int u = y[k], v = y[k + n / 2];
                if(~op) y[k + n / 2] = (u + v) % P;
                else y[k + n / 2] = (-u + v + P) % P;
            }
        }
    }
}
```

+ 与运算

$\displaystyle C_{i} = \sum_{i=j ~~and~~ k}A_{j} B_{k}$

$fwt[A] = merge(fwt[A_0] + fwt[A_1], fwt[A_1])$

$ifwt[A'] = merge(ifwt[A_0'] - ifwt[A_1'], ifwt[A_1'])$

```cpp
void fwt_and(int y[], int len, int op){
    for(int n=2; n<=len; n<<=1){
        for(int j=0; j<len; j+=n){
            for(int k=j; k<j+n/2; ++k){
                int u = y[k], v = y[k + n / 2];
                if(~op) y[k] = (u + v) % P;
                else y[k] = (u - v + P) % P;
            }
        }
    }
}
```

+ 异或运算

$\displaystyle C_{i} = \sum_{i=j ~~xor~~ k}A_{j} B_{k}$

$fwt[A] = merge(fwt[A_0] + fwt[A_1], fwt[A_0] - fwt[A_1])$

$ifwt[A'] = merge(\frac{ifwt[A_0'] + ifwt[A_1']}{2}, \frac{ifwt[A_0'] - ifwt[A_1']}{2})$

```cpp
void fwt_xor(int y[], int len, int op){
    for(int n=2; n<=len; n<<=1){
        for(int j=0; j<len; j+=n){
            for(int k=j; k<j+n/2; ++k){
                int u = y[k], v = y[k + n / 2];
                if(~op) y[k] = (u + v) % P, y[k + n / 2] = (u - v + P) % P;
                else y[k] = (u + v) * i2 % P, y[k + n / 2] = (u - v + P) * i2 % P;
            }
        }
    }
}
```

+ 同或运算

$fwt[A] = merge(fwt[A_1] - fwt[A_0], fwt[A_1] + fwt[A_0])$

$ifwt[A'] = merge(\frac{ifwt[A_1'] - ifwt[A_0']}{2}, \frac{ifwt[A_1'] + ifwt[A_0']}{2})$

+ 例题[Problem - F - Codeforces](https://codeforces.com/gym/103329/problem/F)（玄学题）

`"one should not give up the dream easily! Struggle, struggle until you are crushed by a rock!"`

$\displaystyle \sum_{(x,y) \in E} (x \oplus y)^{33}x^{-2}y^{-1} \mod 10^9+7$

题解：[Detailed Editorial for problem "The Struggle" from XXII Opencup, Grand Prix of XiAn - Codeforces](https://codeforces.com/blog/entry/96518)

+ [P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/fwt) - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4717)

###### 8，chirp Z变换 CZT（待补）

[P6800 【模板】Chirp Z-Transform - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P6800)
