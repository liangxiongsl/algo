可能会用到的知识：

+ 优先级：**算术** > **移位** > 关系 > 逻辑 > **位算术** > 双目 > 赋值

+ **记忆化的dfs属于dp**

+ 记：$lb_n = n~\&~-n,~ub_n = n~\&~n-1$

+ + 性质：$lb_n~|~ub_n == n,~lb_n~\&~ub_n==0$
  
  + 推论：$lb_n = n~ XOR ~ub_n, ub_n = n~ XOR ~lb_n$

+ `__builtin_popcount(n): n的1的个数`

+ `__builtin_ctz(n): n的最后一个1后的0, 返回值不小于0`

+ `n & -n: n的最后一个1的权值`

+ 常用函数：

```cpp
#define in(a, S) (S >> a & 1)
#define sub(S, T) (S == (S & T))
```

###### 1，二进制集合基本操作

集合间的操作

| 操作     | 集合表示            | 位运算语句                  |
| ------ | --------------- | ---------------------- |
| 交集     | $a \cap b$      | `a & b`                |
| 并集     | $a \cup b$      | `a \| b`               |
| 补集     | $\bar a$        | `~a` （全集为二进制都是 1）      |
| 差集     | $a\setminus b$  | `a & (~b)`             |
| 对称差    | $a \triangle b$ | `a ^ b`                |
| a是b的子集 | $a \subseteq b$ | `a==(a&b) 或 (a\|b)==b` |

 元素和集合的操作

| 操作                        | 位运算语句            |
| ------------------------- | ---------------- |
| $i\in s$ 的 $bool$ 值       | `s >> i & 1`     |
| 将 $i$ 加入 $s$              | `s \|= 1 << i`   |
| 将 $i$ 从 $s$ 中删除（$i$ 必须存在） | `s ^= 1 << i`    |
| 将 $i$ 从 $s$ 中删除           | `s &= ~(1 << i)` |

###### 2，模2的幂

$n$ 模非负整数 $k$ 的幂 $\iff$ $n$ 的二进制取最后 $k$ 位 $\iff$ $n~\%~(2^k-1)$

**拓展**：对于$n,~n\in N^+$，$n-1$ 会将 $n$ 的最后一个1置零，后继位 全置1，$n \% (n-1)$等价于 将 $n$ 删掉二进制的最后一位

**应用**：

+ 判断2的幂

```cpp
bool isPowOfTwo(int n){ return n>0 && !(n & n-1); }
```

###### 3，子集遍历（对"2" 的应用）

（子集也可以称为掩码？（掩码用于对源码进行 按位与 操作，以屏蔽或显示某些位））

（[证明](https://oi-wiki.org/math/binary-set/#%E5%AD%90%E9%9B%86%E9%81%8D%E5%8E%86)）

+ 降序遍历 $s$ 的非空子集

```cpp
for(int i=s; i>0; i=i-1&s){
    cout << i << ' ';
}
```

+ 降序遍历 s 的子集

```cpp
for(int i=s; ; i=i-1&s){
    cout << i << ' ';
    if(i<=0) break;
}
```

使用 $popcount(s)$ 表示 $s$ 二进制中 1 的个数，用这种方法可以在 $O(2^{popcount(s)})$ 的时间复杂度内遍历集合 $s$ 的子集

+ 遍历所有掩码的子掩码，$O(3^n)$

输入位数 $n$

1）可重复划分版（用于**可重复计算**）

```cpp
for(int S=0; S<1<<n; ++S){
    for(int T=S; T; T=T-1&S){
        // T 为 S的子集
        // S^T 或 S-T 为 T对S的补集
        // S 和 S^T 为 S的划分
    }
    cout << '\n';
}
```

2）**不重复划分版**：（用于**计数**）

```cpp
for(int S=1; S<1<<n; ++S){
    int p = __builtin_ctz(S);
    for(int T=S; T; T=T-1&S){
        if(!(T >> p & 1)) continue;
    }
}
```

复杂度证明：

将 $j$ 的二进制中 1的个数 $k$ 进行划分 $(0\le k\le n)$，此时 $j$ 有 $2^k$ 个子集，因此 $T_n = \sum\limits_{k=0}^{n}C_{n}^{k}\times 2^k = \sum\limits_{k=0}^{n}C_{n}^{k}\times 2^k\times 1^{n-k}=(2+1)^n=3^n$

（$a~\&~b \le min\{a,~b\}$）

+ 计算以某点为根，具有n个结点的树的方案数

1）结论：$n^{n-2}$

2）状压dp计算：

设以 $u$ 为根，点集为 $S$ 的方案数为 $f_{S,~u}$

$\displaystyle f_{S,~u} = \sum_{T\subseteq S\setminus u,~v\in T} f_{T,~v}\times f_{S-T,~u}$

可以证上述转移式无法做到不重不漏（不会）

为了计算不重复，引入常量点 $p \in S\setminus u,~p\in T$

$\displaystyle f_{S,~u} = \sum_{T\subseteq S\setminus u,~v\in T,~p\in T} f_{T,~v}\times f_{S-T,~u}$

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
int n;

int f[1<<20][20];
int dfs(int S, int u){
    int &ans = f[S][u]; if(~ans) return ans;
    if(__builtin_popcount(S) == 1) return ans = 1;

    ans = 0;
    int Su = S ^ 1 << u;
    int p = __builtin_ctz(Su);
    for(int T=Su; T; T=T-1&Su){
        if(!(T >> p & 1)) continue;

        for(int v=0; v<n; ++v){
            if(!(T >> v & 1)) continue;
            ans += dfs(T, v) * dfs(S-T, u);
        }
    }
    return ans;
}

signed main(){
    while(cin >> n){
        memset(f, -1, sizeof f);
        cout << dfs((1<<n)-1, 0) << '\n';
    }
}
```

![](D:\Document%20And%20Settings2\lx\Desktop\oiwiki\数学\二进制集合操作\assets\2022-10-30-21-34-45-image.png)

+ 
- [Atcoder - Close Group](https://atcoder.jp/contests/abc187/tasks/abc187_f)
- [Codeforces - Nuclear Fusion](http://codeforces.com/problemset/problem/71/E)
- [Codeforces - Sandy and Nuts](http://codeforces.com/problemset/problem/599/E)
- [Uva 1439 - Exclusive Access 2](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4185)
- [UVa 11825 - Hackers' Crackdown](https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2925)

[Solution -「CF 599E」Sandy and Nuts - Rainybunny - 博客园 (cnblogs.com)](https://www.cnblogs.com/rainybunny/p/13395586.html)

$T \subseteq S$ \ $u$

$p \in T$

[(70条消息) Codeforces 1741G. Kirill and Company（BFS/位运算/分组背包）_Happig丶的博客-CSDN博客](https://blog.csdn.net/qq_44691917/article/details/127508272)

###### 4，
