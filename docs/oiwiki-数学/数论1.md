$非零整数a \times 整数b = a的倍数$

###### 1、整除

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-20-52-03-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-20-56-35-image.png)

###### 2、显然约数/因子

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-20-50-29-image.png)

###### 3、"伪因子"

如果$a\mid b$，必有 $\frac{b}{a}\mid b$，我自称 $\frac{b}{a}$ 为**伪因子**；伪因子为整数（可以取0）

###### 4、余数、带余数除法&&、绝对最小余数、最小正余数

        ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-02-41-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-06-43-image.png)

###### 5、最大公约数gcd，最小公倍数lcm、扩展欧几里得

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-20-15-40-18-image.png)

```cpp
// 欧几里得算法
int gcd(int a, int b){
  return !b ? a : gcd(b, a % b);
}
```

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-20-15-31-52-image.png)
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-20-15-41-07-image.png)    

```cpp
int lcm(int a, int b){
  return a / gcd(a, b) * b;
}
```

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-20-16-12-30-image.png)

$a\times x + b\times y = (a, b)\\ b\times x_1 + (a\%b)\times y_1=(b,a\%b)\\ (a,b) = (b, a\%b)\\ \implies a\times x + b\times y = b\times x_1 + (a\%b)\times y_1\\又a\%b=a-\lfloor\frac{a}{b}\rfloor\times b\\ \implies a\times x + b\times y = b\times x_1 + (a-\lfloor\frac{a}{b}\rfloor\times b)\times y_1 = a\times y_1 + b\times (x_1- \lfloor\frac{a}{b}\rfloor\times y_1 )$

$所以，x = y_1, y = x_1 - \lfloor\frac{a}{b}\rfloor \times y_1 $

$最后，再考虑边界情况b=0，则a \times x + 0 \times y = (a, 0) = a \\ \implies x = 1, y = 0, (a, 0) = a$

```cpp
// 递归版
int exgcd(int a, int b, int &x, int &y){
    if(!b){
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, x, y);
    int x1 = x, y1 = y;
    x = y1;
    y = x1 - a / b * y1;
    return d;
}
// 迭代版
int exgcd(int a, int b, int& x, int& y) {
  x = 1, y = 0;
  int x1 = 0, y1 = 1, a1 = a, b1 = b;
  while (b1) {
    int q = a1 / b1;
    tie(x, x1) = make_tuple(x1, x - q * x1);
    tie(y, y1) = make_tuple(y1, y - q * y1);
    tie(a1, b1) = make_tuple(b1, a1 - q * b1);
  }
  return a1;
}
// 矩阵版
int exgcd(int a, int b, int &x, int &y) {
  int x1 = 1, x2 = 0, x3 = 0, x4 = 1;
  while (b != 0) {
    int c = a / b;
    std::tie(x1, x2, x3, x4, a, b) =
        std::make_tuple(x3, x4, x1 - x3 * c, x2 - x4 * c, b, a - b * c);
  }
  x = x1, y = x2;
  return a;
}
```

补充：![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-20-16-35-28-image.png)

+ 例题
  
  [Online Judge](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1045)
  
  [Attachments - 2007-2008 Summer Petrozavodsk Camp, Japanese Contest, 2007-08-29 - Codeforces](https://codeforces.com/gym/100963/attachments)
  
  [Online Judge](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=4628)

###### 6、互素

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-09-46-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-11-15-image.png)

###### 7、裴蜀定理

[证明](https://oi-wiki.org/math/number-theory/bezouts/)

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-20-20-39-07-image.png)

**例题：**[Codeforces Round #290 (Div. 2) D. Fox And Jumping](http://codeforces.com/contest/510/problem/D)

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-20-22-40-57-image.png)

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-20-23-38-57-image.png)

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-20-23-39-08-image.png)

###### 8、辗转相除法Euclid算法（见 5、最大公约数）

###### 9、素数、合数、质因子（素因数/素约数）

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-17-36-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-18-38-image.png)

**性质：**

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-25-16-image.png)

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-18-22-29-image.png)

###### 10、算术基本引理、算数基本定理、标准素因数分解式

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-28-34-image.png)

补充：![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-29-44-image.png)

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-32-50-image.png)

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-33-20-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-33-31-image.png)

###### 11、同余、模数

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-40-05-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-42-57-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-43-05-image.png)

无脑性质：

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-21-51-37-image.png)

###### 12、乘法逆元 extends (11)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-20-23-43-13-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-20-23-44-57-image.png)

+ 欧几里得求逆元

```cpp
// (a, p) = 1时成立  （代码证b指的是p）
void exgcd(int a, int b, int &x, int &y){
  if(!b){
      x = 1, y = 0;
      return ;
  }
  exgcd(b, a % b, x, y);
  y -= a / b * x;
}
// 注意：经过计算后x不一定是逆元，需要 x = (x % p + p) % p 处理
```

+ 快速幂求逆元
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-00-07-17-image.png)

```cpp
// p 为质数时成立
const int p = 1e9+7;
int fp(long long a, int n){
  int ans = 1;
  a = (a % p + p) % p;
  while(n){
      if(n & 1) ans = ans * a % p;
      a = a * a % p;
      n >>= 1;
  }
  return ans;
}
```

+ 线性求逆元
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-00-13-24-image.png)
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-00-13-39-image.png)
  
  $其次，\lfloor\frac{p}{x}\rfloor \times x + p\%x = p \\ \implies \lfloor\frac{p}{x}\rfloor \times x + p\%x \equiv 0(mod~p) \\ \implies \lfloor\frac{p}{x}\rfloor \times (p\%x)^{-1} + x^{-1} \equiv 0(mod~p) \\ \implies x^{-1} \equiv -\lfloor\frac{p}{x}\rfloor \times (p\%x)^{-1}(mod~p) $
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-11-57-39-image.png)

```cpp
const int N = 1e5+3, p = 1e9+7;
int inv[N];
int n;
void f(){
  inv[1] = 1;
  // (p - p / i) 是为了防止出现负数
  for(int i=2; i<=n; i++) inv[i] = (p - p / i) * inv[p % i] % p;
}

// 扩展：递归求逆元
// O(n^(1/3))
const int p = 1e9+7;
int inv(int x){
  return x == 1 ? 1 : (p - p / x) * inv(p % x) % p;
}
// 哈希表优化
const int p = 1e9+7;
unordered_map<int, int> h;
int inv(int x){
  if(h.count(x)) return h[x];
  return x == 1 ? 1 : (p - p / x) * (h[x] = inv(p % x)) % p;
}
```

+ 线性求任意n个数的逆元

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-12-01-53-image.png)

$S_i = S_{i-1} \times a_i \\ SV_{i} = SV_{i+1} \times a_{i+1} \\ av_{i} = SV_{i} \times S_{i-1}$

```cpp
const int N = 1e5+3;
int n;
// s为前缀积，sv为前缀积的逆元
int s[N], sv[N];
// a为数列，av为数列的逆元
int a[N], av[N];
void f(){
  s[0] = 1;
  for(int i=1; i<=n; i++) s[i] = s[i-1] * a[i] % p;
  sv[n] = inv(s[n]);
  for(int i=n-1; i>=1; i--) sv[i] = sv[i+1] * a[i+1] % p;
  for(int i=1; i<=n; i++) av[i] = sv[i] * s[i-1] % p;
}
```

[#110. 乘法逆元 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/110)

[#161. 乘法逆元 2 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/161)

[#2605. 「NOIP2012」同余方程 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/2605)

[P2054 [AHOI2005] 洗牌 - 洛谷 ](https://www.luogu.com.cn/problem/P2054)（递推关系很难想；$(2^n)^{-1} = (2^{-1})^n$）

[#2034. 「SDOI2016」排列计数 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/2034)

###### 13、数论函数

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-23-04-14-image.png)

###### 14、积性函数

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-23-04-45-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-23-07-12-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-19-23-19-13-image.png)

###### 15、丢番图方程（补）

###### 16、错排公式

```cpp
const int N = 1e5+3, p = 1e9+7;
int f[N];
void func(){
    f[0] = f[2] = 1;
    for(int i=3; i<N; i++) f[i] = (f[i-1] + f[i-2]) * (i - 1) % p;
}
```

###### 17、素性判定、反素数     extends（9）

+ 暴力判定

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-19-12-58-image.png)

```cpp
bool isPrime(int n){
  if(n < 2) return false;
  for(int i=2; i<=n/i; i++)
      if(n % i == 0) return false;
  return true;
}
```

+ 素性测试
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-19-13-43-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-19-13-57-image.png)

- + Fermat素性测试

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-19-16-23-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-19-29-53-image.png)

```cpp
#include<ctime>
int TEST_NUM = 8;
bool millerRabin(int n){
    if(n < 3) return n == 2;
    for(int i=1; i<= TEST_NUM; ++i){
        int a = rand() % (n - 2) + 2;
        if(fp(a, n-1, n) != 1) return false;
    }
    return true;
}
```

+ + + 卡迈克尔数
    
    ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-19-31-04-image.png)
    
    ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-19-31-39-image.png)
    
    https://oeis.org/A006931

+ + Miller-Rabin素性测试
    
    ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-19-42-49-image.png)
    
    ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-19-43-10-image.png)

+ + + 二次探测定理
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-19-43-53-image.png)

+ + + 实现

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-20-04-57-image.png)

```cpp
#include<ctime>
int TEST_NUM = 8;
bool millerRabin(int n){
  if(n < 3 || n % 2 == 0) return n == 2;
  int a = n - 1, b = 0;
  while(a % 2 == 0) a >>= 1, ++ b;
  for(int _=0, i; _<TEST_NUM; _++){
      int r = rand() % (n - 2) + 2, v = fp(r, a, n);
      if(v == 1) continue;
      for(i=0; i<b; i++){
          if(v == n-1) break;
          v = 1ll * v * v % n;
      }
      if(i >= b) return false;
  }
  return true;
}
```

      ____

+ 反素数

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-22-17-39-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-22-17-52-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-22-21-20-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-22-21-28-image.png)

+ + 求因子数为n的反质数（即求因子数为n，最小化乘积prod）

```cpp
#define int unsigned long long
int p[16] = {
    2, 3, 5, 7, 11,
    13, 17, 19, 23, 29,
    31, 37, 41, 43, 47, 53
};

int n, ans_prod = ~0ull;
void dfs(int pre = 63, int u = 0, int prod = 1, int num = 1){
    // 出口
    if(u >= 16) return ;

    // 剪枝
    if(prod > ans_prod || num > n) return ;
    // 更新答案
    if(prod < ans_prod && num == n){
        ans_prod = prod;
        return ;        // 小剪枝
    }

    // 扩展枝叶
    for(int i=1; i<=pre; i++)
        dfs(i, u + 1, prod *= p[u], num * (i + 1));
}
```

____

+ + 求1..n以内最大的反质数（即因子数num最大化，乘积prod最小化）

```cpp
#define int unsigned long long
int p[16] = {
    2, 3, 5, 7, 11,
    13, 17, 19, 23, 29,
    31, 37, 41, 43, 47, 53
};

int n, ans_prod, ans_num;
void dfs(int pre = 63, int u = 0, int prod = 1, int num = 1){
    if(u >= 16) return ;

    if(prod > n) return ;
    // 因子数最大化，乘积最小化 
    if(ans_num < num){
        ans_num = num;
        ans_prod = prod;
    }else if(ans_num == num && ans_prod > prod){
        ans_prod = prod;
    }

    for(int i=1; i<=pre; i++)
        dfs(i, u + 1, prod *= p[u], num * (i + 1));
}
```

____

+ 例题

[Problem - 27E - Codeforces](https://codeforces.com/problemset/problem/27/E)

[ZOJ (pintia.cn)-More Divisors](https://zoj.pintia.cn/problem-sets/91827364500/problems/91827366061)

###### 18、筛法

+ 筛素数

+ + 埃拉托斯特尼筛法Eratosthenes
  
  + + 朴素版$O(n\times loglog~n)$、筛至平方根$O(n \times lnln\sqrt{n}+n)$

```cpp
const int N = 1e5+3;
bool np[N];
int p[N], idx;
// 朴素版
void f(int n){
    np[0] = np[1] = true;
    for(int i=2; i<=n; ++i){
        if(!np[i]){
            p[++ idx] = i;
            // 写法1
            if(1ll * i * i <= n) 
                for(int j=i*i; j<=n; j+=i) np[j] = true;
            // 写法2 （枚举“伪因子”）
            for(int j=i; j<=n/i; ++j) np[j * i] = true; 
        }
    }
}

// 筛至平方根
void f(int n){
    np[0] = np[1] = true;
    for(int i=2; i<=n/i; ++i)
        if(!np[i]){
//             for(int j=i*i; j<=n; j+=i) np[j] = true;
            for(int j=i; j<=n/i; ++j) np[j * i] = true;
        }
}
```

    ____

+ + 分块筛选（[筛法 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/number-theory/sieve/)，不想看）

```cpp
int count_primes(int n) {
const int S = 10000;
vector<int> primes;
int nsqrt = sqrt(n);
vector<char> is_prime(nsqrt + 1, true);
for (int i = 2; i <= nsqrt; i++) {
  if (is_prime[i]) {
    primes.push_back(i);
    for (int j = i * i; j <= nsqrt; j += i) is_prime[j] = false;
  }
}
int result = 0;
vector<char> block(S);
for (int k = 0; k * S <= n; k++) {
  fill(block.begin(), block.end(), true);
  int start = k * S;
  for (int p : primes) {
    int start_idx = (start + p - 1) / p;
    int j = max(start_idx, p) * p - start;
    for (; j < S; j += p) block[j] = false;
  }
  if (k == 0) block[0] = block[1] = false;
  for (int i = 0; i < S && start + i <= n; i++) {
    if (block[i]) result++;
  }
}
return result;
}
```

  ____

+ + 线性筛法

```cpp
const int N = 1e8+3;
bool np[N];
int p[N], idx;
int gp(int n){
  np[0] = np[1] = true;
  for(int i=2; i<=n; ++i){
      if(!np[i]) p[++ idx] = i;
      for(int j=1; p[j]<=n/i; ++j){
          np[i * p[j]] = true;
          if(!(i % p[j])) break;
          // i % p[j] == 0
          // 换言之，i 之前被 p[j] 筛过了
          // 由于 p[] 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定也是
          // p[j] 的倍数 它们都被筛过了，就不需要再筛了，所以这里直接 break
          // 掉就好了
      }
  }
  return idx;
}
```

  ____

+ 筛积性函数
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-16-21-01-image.png)
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-16-27-31-image.png)
  
  主要有4个条件：$f_1、f_p、f_{i\times p_j}（p_j \nmid i 或(i,p_j)=1）、f_{i\times p_j}（p_j \mid i）$
  
  其中已知：$f_1 = 1, 、f_{i\times p_j}（p_j \nmid i 或(i,p_j)=1）~=~f_i\times f_{p_j} $
  
  所以，只需要求：$f_p、f_{i\times p_j}（p_j \mid i）$
  
  + 筛欧拉函数$\phi_n$
  
  1，p：$\phi_p~=~p-1$
  
  2，$i \% p_j ~==~ 0 \implies i \times p_j与 i 拥有共同的质因子集合 \\ \implies \phi_{i\times p_j} ~=~ i \times p_j \times \prod\limits_{t=1}^{s}\frac{p_t-1}{p_t} ~=~ i \times \prod\limits_{t=1}^{s}\frac{p_t-1}{p_t}\times p_j ~=~ \phi_i \times p_j  $
  
  3，$i \% p_j ~!=~ 0 \implies (i, p_j)==1 \implies \phi_{i\times p_j} = \phi_i \times \phi_{p_j} $

```cpp
const int N = 5e6+3;
bool np[N];
int p[N], idx;
int phi[N];
void pre(int n){

  phi[1] = 1;
  for(int i = 2; i <= n; ++ i){
      if(!np[i]) p[++ idx] = i, phi[i] = i - 1;
      for(int j = 1; p[j] <= n/i; ++ j){
          np[i * p[j]] = true;
          phi[i * p[j]] = i % p[j] ? phi[i] * phi[p[j]] : phi[i] * p[j];
          if(!(i % p[j])) break;
      }
  }

}
```

____

- - 筛莫比乌斯函数$\mu_n$

```cpp
const int N = 5e6+3;
bool np[N];
int p[N], idx;
int mu[N];
void pre(int n){
  mu[1] = 1;
  for(int i = 2; i <= n; ++ i){
      if(!np[i]) p[++ idx] = i, mu[i] = -1;
      for(int j = 1; p[j] <= n/i; ++ j){
          np[i * p[j]] = true;
          mu[i * p[j]] = i % p[j] ? mu[i] * mu[p[j]] : 0;
          if(!(i % p[j])) break;
      }
  }
}
```

____

+ + 筛约数个数$d_n$

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-15-53-01-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-15-53-49-image.png)

```cpp
const int N = 5e6+3;
bool np[N];
int p[N], idx;
int num[N], d[N];
void pre(int n){
    num[1] = d[1] = 1;
    for(int i = 2; i <= n; ++ i){
        if(!np[i]) p[++ idx] = i, num[i] = 1, d[i] = 2;
        for(int j = 1; p[j] <= n/i; ++ j){
            np[i * p[j]] = true;

            int n = i * p[j];
            num[n] = i % p[j] ? num[i] * num[p[j]] : num[i] + 1; 
            // num[n] = i % p[j] ? 1 : num[i] + 1;
            d[n] = i % p[j] ? d[i] * d[p[j]] : d[i] / num[n] * (num[n] + 1);
            // d[n] = i % p[j] ? d[i] * 2 : d[i] / num[n] * (num[n] + 1); 
            if(!(i % p[j])) break;
        }
    }
    for(int i=1; i<=10; i++) cout << num[i] << ' ' << d[i] << '\n';

}
```

  ____

+ + 筛约数和$f_n$
    
        ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-16-06-04-image.png)

```cpp
const int N = 5e6+3;
bool np[N];
int p[N], idx;
int g[N], f[N];
void pre(int n){

    g[1] = f[1] = 1;
    for(int i = 2; i <= n; ++ i){
        if(!np[i]) p[++ idx] = i, g[i] = i + 1, f[i] = i + 1;
        for(int j = 1; p[j] <= n/i; ++ j){
            np[i * p[j]] = true; 
            int n = i * p[j];
            g[n] = i % p[j] ? g[i] * g[p[j]] : g[i] * p[j] + 1;
            // g[n] = i % p[j] ? 1 + p[j] : g[i] * p[j] + 1;
            f[n] = i % p[j] ? f[i] * f[p[j]] : f[i] / g[i] * g[n]; 
            if(!(i % p[j])) break;
        }
    }

}
```

###### 19、数论分块

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-17-26-28-image.png)

+ 引理
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-17-27-54-image.png)
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-17-28-18-image.png)
  
  + 一维数论分块

```cpp
const int N = 5e6+3;
int n;
int f[N], s[N]; 
int block(){
    // 先求 f[] 的前缀和 s[] 
    int ans = 0;
    for(int lb = 1, ub; lb <= n; lb = ub + 1){
        ub = n / (n / lb); 
        ans += (s[ub] - s[lb - 1]) * (n / lb);
    }
    return ans;
}
```

+ 多维数论分块
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-18-20-44-image.png)
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-18-20-54-image.png)
  
  + 例题
    
    [P2261 [CQOI2007]余数求和 ](https://www.luogu.com.cn/problem/P2261)

```cpp
#include<iostream>
using namespace std; 
#define int long long
int s1(int n){
 return n * (n + 1) / 2;
} 
signed main(){

    int n, k;
    cin >> n >> k; 
    int ans = n * k;
    for(int lb = 1, ub; lb <= n; lb = ub + 1){
        if(lb <= k) ub = min(k / (k / lb), n);
        else ub = n; 
        ans -= (s1(ub) - s1(lb - 1)) * (k / lb);
    }
    cout << ans << '\n';

}
```

+ [Online Judge](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=27&page=show_problem&problem=2521)

+ [P3455 [POI2007]ZAP-Queries - ](https://www.luogu.com.cn/problem/P3455)

###### 20、欧拉函数

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-16-29-09-image.png)

+ 性质
  
  + 积性：![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-16-45-47-image.png)
  
  + $n~=~\sum\limits_{d \mid n}\phi_d$（证明：莫比乌斯反演）
  
  + $\phi_{p^n} ~=~ p^{n}-p^{n-1}$
  
  + $\phi_n ~=~ n \times \prod\limits_{i=1}^{s}\frac{p_i-1}{p_i}$ 
    
    ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-16-52-40-image.png)

+ 求单值欧拉函数（利用Pollard Rho算法做优化）

```cpp
int phi(int n){
  int ans = n;

  // int m = int(0.5 + sqrt(n));
  // for(int i=2; i<=m; ++i)
  for(int i=2; i<=n/i; ++ i)
  if(!(n % i)){
      ans = ans / i * (i - 1);
      while(!(n % i)) n /= i;
  }
  if(n > 1) ans = ans / n * (n - 1);
  return ans;
}
```

____

+ 欧拉定理
  
  $(a, m) ~=~ 1 \implies a^{\phi_m} ~\equiv~ 1(mod~m)$

+ 扩展欧拉定理
  
    $a^b ~\equiv~ \begin{cases}a^{b ~\%~ \phi_p}, & (a, p)=1 ~\\~ a^b, ~&~ (a, p ) ~\ne~ 1, b<\phi_p ~\\~ a^{b ~\%~ \phi_p ~+~ \phi_p}, ~~&~~ (a, p ) ~~\ne~~ 1, b \ge \phi_p\end{cases}    （mod~p）$

###### 21、分解质因数（补）

  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-21-57-48-image.png)

  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-21-58-04-image.png)

+ 朴素算法$O(\sqrt{\frac{n}{ln~n}} \to \sqrt{n} )$

```cpp
int d[55], idx;
int breakdown(int n){

    idx = 0;
    for(int i=2; i<=n/i; ++i){
        if(n % i) continue;
        while(!(n % i)) n /= i;
        d[ ++ idx] = i;
    }
    if(n > 1) d[ ++ idx] = n, n /= n;
    return idx;

}
```

  ____

+ 例题：[Problem - 1445C - Codeforces](https://codeforces.com/problemset/problem/1445/C)

```cpp
#include<iostream>
using namespace std; 
typedef long long ll;
ll a, b; 
int d[55], idx;
ll breakdown_solve(){
    idx = 0;
    ll n = b;
    for(int i=2; i<=n/i; ++i){
        if(n % i) continue;
        while(!(n % i)) n /= i;
        d[ ++ idx] = i;
    }
    if(n > 1) d[ ++ idx] = n, n /= n; 
    ll ans = n;
    for(int i=1; i<=idx; ++i){
        ll int m = a;
        while(!(m % b)) m /= d[i];
        ans = max(ans, m);
    }
    return ans;
} 
int main(){
    int T;
    cin >> T;
    while(T--){
        cin >> a >> b;
        cout << breakdown_solve() << '\n';
    }
}
```

____

+ Pollard Rho算法

+ + 生日悖论
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-22-07-31-image.png)
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-22-27-12-image.png)
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-22-27-29-image.png)
  
  + ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-22-27-39-image.png)

+ + 构造伪随机数
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-22-31-31-image.png)
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-22-31-57-image.png)

+ + 优化随机算法
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-23-01-37-image.png)
  
  + ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-26-23-02-41-image.png)

+ + Floyd判环
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-10-16-03-image.png)

```cpp
std::mt19937 rd(time(0));

int gcd(int a, int b){
  return !b ? a : gcd(b, a % b);
}
int f(int x, int c, int n){
  return (x * x + c) % n;
}
int pollard_rho(int n){
  int c = rd() % (n - 1) + 1;
  int t = f(0, c, n), r = f(t, c, n);
  while(t != r){
      int d = gcd(abs(t - r), n);
      if(d > 1) return d;
      t = f(t, c, n), r = f(f(r, c, n), c, n);
  }
  return n;
}
```

+ + 倍增优化
  
  + ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-10-34-44-image.png)

```cpp
int pollard_rho(int n){
    int c = rd() % (n - 1) + 1;
    int s = 0, t = 0;
    int step = 0, goal = 1;
    int val = 1;
    for(goal = 1; ; goal <<= 1, s = t, val = 1){
        for(step = 1; step <= goal; ++ step){
            t = f(t, c, n);
            val = mul(val, abs(t - s), n) % n;
            if(step % 127 == 0){
                int d = gcd(val, n);
                if(d > 1) return d;
            }
        }
        int d = gcd(val, n);
        if(d > 1) return d;
    }
}
```
