###### 23、类欧几里得（男）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-14-19-10-image.png)

+ pro

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-14-19-25-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-18-59-image.png)

+ 推导f

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-24-39-image.png)

（**贡献合并计算，将贡献与条件做转化**）（依赖性：$j \to i \to n$）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-28-21-image.png)

（**"限制转移"**）（依赖性：$j \to n, i \to n$）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-28-57-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-32-38-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-32-54-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-33-11-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-33-34-image.png)

+ 推导g

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-34-31-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-34-46-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-34-58-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-35-06-image.png)

+ 推导h

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-35-33-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-35-57-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-36-33-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-36-21-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-36-46-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-36-55-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-27-18-37-36-image.png)

+ 总结
  
  （记：$s_0=n+1,s_1=\frac{n\times(n+1)}{2},s_2=\frac{n\times(n+1)\times(2\times n+1)}{6}  ~\\~ d = \frac{a\times i+b}{c}, d_1=\frac{a\%c\times i+b\%c}{c}, d_2=\frac{j\times c + c - b - 1}{a} ~\\~ D = \frac{a\times n + b}{c} ~\\~ f = f(a, b, c, n),f_1 ~=~ f(a\%c,~b\%c,~c,~n), f_2 = f(c,~c-b-1,~a,~D-1) ~\\~（g,g_1,g_2,h,h_1,h_2同理）$）
  
  $f ~=~ \begin{cases}  \lfloor\frac{b}{c}\rfloor \times s_0 & a == 0 \\ \lfloor\frac{a}{c}\rfloor \times s_1 + \lfloor\frac{b}{c}\rfloor \times s_0 + f_1 & a \ge c || b \ge c ~\\~ D \times n - f_2 & a<c, b<c  \end{cases}$
  
  $g ~~=~~ \begin{cases} \lfloor\frac{b}{c}\rfloor \times s_1 & a == 0 ~\\~ \lfloor\frac{a}{c}\rfloor \times s_2 + \lfloor\frac{b}{c}\rfloor \times s_1 + g_1 & a \ge c || b \ge c ~~\\~~ D \times s_1 - \frac12\times h_2 - \frac12\times f_2 & a<c, b<c \end{cases}$
  
  $h ~~=~~ \begin{cases} \lfloor\frac{b}{c}\rfloor^2 \times s_0 & a == 0 ~\\~ \lfloor\frac{a}{c}\rfloor^2 \times s_2 + 2 \times \lfloor\frac{a}{c}\rfloor \times \lfloor\frac{b}{c}\rfloor \times s_1 + \lfloor\frac{b}{c}\rfloor^2 \times s_0  & a \ge c || b \ge c ~~\\~~ + h_1 + 2 \times \lfloor\frac{a}{c}\rfloor \times g_1 + 2 \times \lfloor\frac{b}{c}\rfloor f_1 ~\\~ D \times (D + 1)\times n - 2\times g_2 - 2\times f_2 - f & a<c, b<c \end{cases}$

+ [P5170 【模板】类欧几里得算法 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5170)

```cpp
#include<iostream>
using namespace std;

#define int long long
const int p = 998244353;
int i2, i6;
inline int inv(int n){ return n==1 ? 1 : (p - p / n) * inv(p % n) % p; }
inline int s0(int n){ return n + 1; }
inline int s1(int n){ return n * (n + 1) % p * i2 % p; }
inline int s2(int n){ return n * (n + 1) % p * (2 * n + 1) % p * i6 % p; }

struct func{
    int f, g, h;
};

func calc(int a, int b, int c, int n){
    int ac = a / c, bc = b / c, D = (a * n + b) / c;

    if(!a) return {bc * s0(n) % p, bc * s1(n) % p, bc * bc % p * s0(n) % p};

    if(a >= c || b >= c){
        func x1 = calc(a % c, b % c, c, n);
        return {
            (ac * s1(n) % p + bc * s0(n) % p + x1.f) % p,
            (ac * s2(n) % p + bc * s1(n) % p + x1.g) % p,
            (ac * ac % p * s2(n) % p + 2 * ac * bc % p * s1(n) % p + bc * bc % p * s0(n) % p + 
            x1.h + 2 * ac * x1.g % p + 2 * bc * x1.f % p) % p
        };
    }
    func x2 = calc(c, c - b - 1, a, D - 1);
    func x = {
        ((D * n - x2.f) % p + p) % p,
        ((D * s1(n) % p - i2 * x2.h % p - i2 * x2.f % p) % p + p) % p,
        ((D * (D + 1) % p * n % p - 2 * x2.g % p - 2 * x2.f % p) % p + p) % p
    };
    x.h = ((x.h - x.f) % p + p) % p;
    return x;
}

signed main(){
    i2 = inv(2), i6 = inv(6);
//    cout << i2 << ' ' << i6 << '\n';

    int T;
    cin >> T;
    while(T--){
        int n, a, b, c;
        cin >> n >> a >> b >> c;
        func x = calc(a, b, c, n);
        cout << x.f << ' ' << x.h << ' ' << x.g << '\n';
    }
    return 0;
}
```

###### 24、费马小定理、欧拉定理

+ 费马小定理

$p~~is~~prime,~(a,~p)=1 ~\implies~ a^{p-1} ~\equiv~ 1(mod~p)$

另一个形式：$p~~id~~prime ~\implies~ a^p ~\equiv~ a(mod~p)$

+ 欧拉定理（比费马定理更一般）

$(a,~b) ~=~ 1 ~\implies~ a^{\phi_b} ~\equiv~ 1(mod~b) $

+ 扩展欧拉定理

$a^b ~\equiv~ \begin{cases}  a^{b~\%~\phi_m},    &  (a,~m)~=~1        \\           a^b,       &  (a,~m) ~\ne~ 1,~b<\phi_m                               \\    a^{b~\%~\phi_m ~+~ \phi_m}     &    (a,~m) ~\ne~ 1,~b \ge \phi_m     \end{cases}   \pmod{m}$

（当$a < 2\times m$时，$(a,m)$仅当$a==m$时，为$m$，此时$a^b\pmod{m}=0$；其他情况下为1，即欧拉定理第一个条件）

+ 例题
  
  1、[SPOJ.com - Problem ETF](https://www.spoj.com/problems/ETF/)（水题）
  
  2、[UVA #10179 "Irreducible Basic Fractions"[Difficulty: Easy]](https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1120)（水题）
  
  3、[UVA #10299 "Relatives"[Difficulty: Easy]]([Online Judge](https://onlinejudge.org/index.php?option=onlinejudge&page=show_problem&problem=1240))(水题，但数据有问题($\phi_1=1$而非0))
  
  4、[UVA #11327 "Enumerating Rational Numbers"[Difficulty: Medium]](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=2302)（二分+欧拉筛+gcd）
  
  5、[TIMUS #1673 "Admission to Exam"[Difficulty: High]](https://acm.timus.ru/problem.aspx?space=1&num=1673)（不会）

###### 25、线性同余方程liEu

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-09-50-28-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-09-51-24-image.png)

```cpp
int exgcd(int a, int b, int &x, int &y){
    if(!b){
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, x, y), x1 = x;
    x = y;
    y = x1 - a / b * x1;
    return d;
}
// 一般 c是正整数；a，b可以不是正整数（很多人往往会忽略这一点，这也困扰了我好久）
bool liEu(int a, int b, int c, int &x, int &y){
    int d = exgcd(a, b, x, y);
    if(c % d) return false;
    int ad = a / d, bd = b / d, cd = c / d;
    x *= cd, y *= cd;
//  如果模数bd是负数，那么对bd取反(重要！！)
    bd = abs(bd);
//  取最小正整数解
    x = (x % bd + bd) % bd;
    return true;
}
```

（模数取倒数的正确性：

设 $P$ 为模数，那么 $n - p\times t \iff n + p\times -t$ ，$n,~t\in Z$ ）

###### 26、中国剩余定理CRT

+ Chinese Remainder Theorem, CRT

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-12-21-02-image.png)

$\begin{cases}  x \equiv a_1 \pmod{b_1}  \\   x \equiv a_2 \pmod{b_2}  \\  &\vdots   \\    x \equiv a_n \pmod{b_n} \end{cases}$

结论：

$ pb ~=~ \prod\limits_{i=1}^{n}b_i   \\  x=(\sum\limits_{i=1}^n a_i\times\frac{pb}{b_i} \times (\frac{pb}{b_i})^{-1}) ~\%~ pb$

+ 朴素版（$b[~]互质的情况$）[P3868 [TJOI2009] 猜数字](https://www.luogu.com.cn/problem/P3868)

```cpp
int exgcd(int a, int b, int &x, int &y){
    if(!b) return x = 1, y = 0, a;
    int d = exgcd(b, a % b, x, y), x1 = x;
    return x = y, y = x1 - a / b * y, d;
}
int crt(int k, int *a, int *b){
    int ans = 0;
    int pb = 1;
    for(int i=1; i<=k; ++i) pb = pb * b[i];
    for(int i=1; i<=k; ++i){
        int b1 = pb / b[i], ib1, y;
        exgcd(b1, b[i], ib1, y);
        ans = (ans + a[i] * b1 %pb * ib1 % pb) % pb;
    }
    return (ans % pb + pb) % pb;
}
```

+ 扩展中国剩余定理excrt（$b[~]无限制的情况，但不一定有解$）

考虑两个方程的情况[P4777 【模板】扩展中国剩余定理（EXCRT）](https://www.luogu.com.cn/problem/P4777)

$x ~\equiv~ a_1 \pmod{b_1} \\ x ~\equiv~ a_2 \pmod{b_2} \\ \implies  x =a_1 + b_1\times p = a_2 + b_2\times q  \\ \implies b_1\times p ~-~ b_2\times q ~=~ a_2 - a_1 \\ \implies 用exgcd~求出~p \\ 当d | (a_2 - a_1)时有解，解为 x ~\equiv~ a_1 + b_1\times p \pmod{[b_1,~b_2]} \\ \implies 于是，对于多个方程的情况，更新 a_1 += b_1\times p,~ b_1 *= b_2/d 迭代求解即可   $

```cpp
#define int __int128
int exgcd(int a, int b, int &x, int &y){
    if(!b) return x = 1, y = 0, a;
    int d = exgcd(b, a % b, x, y), x1 = x;
    return x = y, y = x1 - a / b * y, d;
}
int excrt(int n, int *a, int *b){
    int A1 = a[1], B1 = b[1];
    for(int i=2; i<=n; ++i){
        int A2 = a[i], B2 = b[i];

        // liEu(a, b, c, x, y)
        int x, y;
        int d = exgcd(B1, B2, x, y), c = A2 - A1, cd = c / d, bd = B2 / d;
        if(c % d) return -1;
        x *= cd, y *= cd;
        // 求解最小正整数解
        x = (x % bd + bd) % bd;

        A1 += B1 * x, B1 *= bd;
    }
    // 不知道要不要模 B1 ？
    return A1;
}
```

+ 变相的excrt，如[P4774 [NOI2018] 屠龙勇士](https://www.luogu.com.cn/problem/P4774)
  
  毒瘤题目，还需要特判

求解方程组：$c_i\times x \equiv a_i \pmod{b_i}$

一种(我的)做法是：将$c_i$转化为1，然后调用$excrt()$求解

```cpp
int exgcd(int a, int b, int &x, int &y){
    if(!b) return x = 1, y = 0, a;
    int d = exgcd(b, a % b, x, y), x1 = x;
    return x = y, y = x1 - a / b * y, d;
}
int liEu(int a, int b, int c, int &x, int &y){
    int d = exgcd(a, b, x, y), cd = c / d, bd = b / d;
    if(c % d) return -1;
    return x = ((__int128)x * cd % bd + bd) % bd, d;
}
int mx;
int excrt(int n, int *a, int *b){
    int a1 = a[1], b1 = b[1];
    for(int i=2; i<=n; ++i){
        int a2 = a[i], b2 = b[i];
        int x, y, d = liEu(b1, b2, a2 - a1, x, y);
        if(d == -1) return -1;
        a1 += b1 * x, b1 *= b2 / d;
        a1 = (a1 % b1 + b1 ) % b1;
    }
    // 特判
    if(a1 < mx) a1 += ((mx - a1 - 1) / b1 + 1) * b1;
    return a1;
}
int ex(int n, int *a, int *b, int *c){
    for(int i=1; i<=n; ++i){
        int x, y, d = liEu(c[i], b[i], a[i], x, y);
        if(d == -1) return -1;
        a[i] = x, b[i] = b[i] / d;
    }
    return excrt(n, a, b);
}
```

+ Garner算法（crt的应用）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-11-34-45-image.png)

$\begin{cases} n \equiv a_1 \pmod{b_1} \\ n \equiv a_2 \pmod{b_2} \\ &\vdots \\ n \equiv a_n \pmod{b_n} \end{cases}$

$记：p_i \times r_{i,j} ~\equiv~ 1 \pmod{p_j}$ （即$r_{i,j}$为$p_i$模$p_j$意义下的逆元）

定义$n ~=~ x_1 ~+~ x_2\times p_1 ~+~ x_3\times p_1\times p_2 ~+~\ldots ~+~ x_k\times p_1\times\ldots\times p_{k-1} $

将 $n$ 代入逐个式子中化简，得：

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-23-00-09-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-23-00-18-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-23-00-25-image.png)

+ 模数

###### 27、威尔逊定理Wilson

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-23-11-35-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-23-14-57-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-23-15-17-image.png)

- [Problem - 2973 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=2973) 
  
  ```cpp
  #include
  using namespace std; 
  const int N = 1e6+8, M = 3 * N + 8;
  int s[N];
  bool notp[M]; 
  int main(){
  notp[1] = true;
  for(int i=2; i<M; i++)
  if(!notp[i])
  for(int d=2; d <= M / i; d ++ ) notp[d * i] = true;
  for(int i=1; i<N; i++) s[i] = s[i-1] + !notp[3 * i + 7]; 
  int T;
  cin >> T;
  while(T--){
  int n;
  scanf("%d", &n);
  printf("%d\n", s[n]);
  } 
  }
  ```

###### 28、升幂定理LTE

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-23-16-24-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-23-16-40-image.png)

+ $LTE_p$（模为奇素数）

$ p \nmid a,~p \nmid b,~a \equiv b \pmod{p} \\ \implies v_{p, a^n - b^n} ~=~ v_{p, a - b} ~+~ v_{p, n}       $

+ $LTE_2$

$a,~b为奇数$

$n为奇数 \implies v_{2,~a^n-b^n} ~=~ v_{2,~a-b} $

$n为偶数 \implies v_{2,~a^n-b^n} ~=~ v_{2,~a-b} ~+~ v_{2,~a+b} ~+~ v_{2,~n} ~-~ 1  $

###### 29、卢卡斯定理Lucas

（前置知识：快速幂，乘法逆元，组合数）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-28-23-40-38-image.png)

（简言之：卢卡斯用于计算 $a,~b$ 很大，而 $P$ 较小 的组合数，**复杂度下限**为 $O(P)$  ；

若 $P~is~prime$，用朴素 $lucas$； 若 $P~is~not~prime$，用 $exlucas$）

（证明略）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-29-13-50-26-image.png)

$lucas$ 求法一，复杂度：$O(p) ~\to~ O(\log_P\times \log_n)$（预处理，查询）

```cpp
#define int long long
const int N = 1e5+3;
int fac[N];
void init(int n, int p){
    fac[0] = 1;
    for(int i=1; i<=n; ++i) fac[i] = fac[i-1] * i % p;
}
int fp(int a, int n, int p){ int ans = 1; while(n){ if(n & 1) ans = ans * a % p; a = a * a % p; n >>= 1; } return ans; }
int inv(int n, int p){ return fp(n, p-2, p); }
int c(int a, int b, int p){
    return a < b ? 0 : fac[a] * inv(fac[a - b], p) % p * inv(fac[b], p) % p;
}
int lucas(int a, int b, int p){
    return !b ? 1 : lucas(a / p, b / p, p) * c(a % p, b % p, p) % p;
}
```

$lucas$ 求法二，复杂度：$O(p) ~~\to~~ O(\log_n)$

```cpp
#define int long long
int P;

int fac[N], ifac[N];
void init(int n){
    fac[0] = ifac[0] = ifac[1] = 1;
    for(int i=1; i<=n; ++i) fac[i] = fac[i-1] * i % P;
    for(int i=2; i<=n; ++i) ifac[i] = (P - P / i) * ifac[P % i] % P;
    for(int i=1; i<=n; ++i) ifac[i] = ifac[i-1] * ifac[i] % P;
}
int c(int a, int b){
    return a < P ? fac[a]*ifac[a-b] % P * ifac[b] % P 
        : c(a%P, b%P) * c(a/P, b/P) % P;
}
```

**在非常大的不为质数的模数下的优化：**（7个函数）

```cpp
#define int long long
const int N = 4e4+3, p = 999911659, pb = p - 1;
int k, a[4 + 1], b[4 + 1];
void breakdown(int n){
    // 构造 b[] 
    for(int i=2; i<=n; ++i){
        if(n % i) continue;
        while(!(n % i)) n /= i;
        b[++ k] = i;
    }
    if(n > 1) b[++ k] = n;
}

int fac[N];
void init(int p){ fac[0] = 1; for(int i=1; i<=p; ++i) fac[i] = fac[i-1] * i % p; }
int fp(int a, int n, int p){ int ans = 1;while(n){    if(n & 1) ans = ans * a % p;a = a * a % p;    n >>= 1; } return ans; }
int inv(int n, int p){  return fp(n, p-2, p); }
int c(int a, int b, int p){ return a < b ? 0 : fac[a] * inv(fac[a - b], p) % p * inv(fac[b], p) % p; }
int lucas(int a, int b, int p){ return !b ? 1 : lucas(a / p, b / p, p) * c(a % p, b % p, p) % p; }

int crt(int k, int *a, int *b, int n){
    // 构造 a[]， 即 x 模 各种 bi 意义下的值 
    for(int i=1; i<=k; ++i){
        init(b[i]);

        int ans = 0;
        for(int j=1; j * j <= n; ++j){
            if(n % j) continue;
            ans = (ans + lucas(n, j, b[i])) % b[i];
            if(j * j != n) ans = (ans + lucas(n, n / j, b[i])) % b[i];
        }
        a[i] = ans;
    }
    // 合并 
    int ans = 0;
    for(int i=1; i<=k; ++i){
        int b1 = pb / b[i], ib1 = inv(b1, b[i]);
        ans = (ans + a[i] * b1 % pb * ib1 % pb) % pb;
    }

    return ans;
}
```

$n!$中含有的素数$p$的幂次 $v_{p,~n!} ~=~ \sum\limits_{i=1}^{\infty} \lfloor\frac{n}{p_{i}}\rfloor $

另一种形式：$v_{p,~n!} ~=~ \frac{n - s_{p,~n}}{p - 1} $（$s_{p,~n}$为n在p进制下的各位数字之和）

+ 素数在组合数中的幂次

$v_{p,~C^a_b} ~=~ \frac{s_{p,~a ~+~ s_{p,~b-a} ~-~ s_{p,~b}}}{p-1} $

```cpp
int s(int p, int n){
    int ans = 0;
    while(n){
        ans += n % p;
        n /= p;
    }
    return ans;
}
int v(int p, int n){
    return (n - s(p, n)) / (p - 1);
}
int v(int p, int a, int b){
    return -(s(p, a) + s(p, b - a) - s(p, b)) / (p - 1);
}
```

+ exlucas

###### 30、二次剩余（男）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-30-22-48-59-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-30-22-49-19-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-30-22-49-47-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-30-23-00-40-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-30-23-34-49-image.png)

（[原图 (902×905) (oi-wiki.org)](https://oi-wiki.org/math/number-theory/images/quad_residue.png)）

+ Euler判别准则

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-01-18-30-52-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-01-19-20-37-image.png)

（证明略）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-01-18-28-59-image.png)

+ 二次剩余，二次非剩余的数量

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-01-19-15-25-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-01-19-15-17-image.png)

（证明略，涉及Fermat小定理、Lagrange定理、Euler判别准则）

+ **特殊情况时的算法**（$a=4\times i-1$）

+ + 

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-01-19-45-03-image.png)

+ + Atkin算法

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-01-20-13-46-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-01-20-24-15-image.png)

+ **Cipolla算法**（看不懂）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-01-20-39-31-image.png)

```cpp

```

+ Legendre算法（。。。）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-01-20-44-58-image.png)

+ Tonelli-Shanks算法（。。。）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-01-20-45-34-image.png)

+ 练习

[P5491 【模板】二次剩余 - 洛谷 ](https://www.luogu.com.cn/problem/P5491)

[「Timus 1132」Square Root](https://acm.timus.ru/problem.aspx?space=1&num=1132)

###### 31、拉格朗日定理（补）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-13-52-04-image.png)

+ 应用

+ + ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-14-12-20-image.png)
  
  + ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-14-13-05-image.png)
  
  + ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-14-13-48-image.png)

###### 32、原根（Primitive Roots）

+ 前置：[费马小定理](https://oi-wiki.org/math/number-theory/fermat/)，[欧拉定理](https://oi-wiki.org/math/number-theory/fermat/)，[拉格朗日定理](https://oi-wiki.org/math/number-theory/lagrange/)。

+ 1，阶$\delta_{m,a}$、半阶$\delta_{m,a}^-$

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-14-27-11-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-14-27-20-image.png)

+ + 性质

+ + + 1，$a,~a^1,~a^2,~..~,~a^{\delta_{m,~a}}$模$m$两两不同余

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-14-34-14-image.png)

+ + + 2，若$a^n ~\equiv~ 1\pmod{m}$，则$\delta_{m,~a} \mid n$

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-14-37-38-image.png)

+ + + 3，设$m\in\mathbb{N^*},~a,~b\in\mathbb{Z},~(a,~m)=(b,~m)=1$，则：

$\delta_{m,~a\times b}=\delta_{m,~a}\times \delta_{m,~b} \iff (\delta_{m,~a},~\delta_{m,~b})=1$

（证明略，[原根 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/number-theory/primitive-root/#_3)）

+ + + 4，设$k\in \mathbb{N},~m\in \mathbb{N^*},a\in \mathbb{Z},~(a,~m)=1  \\ \implies \delta_{m,~a^k} ~=~ \frac{\delta_{m,~a}}{(\delta_{m,~a},~k)}$

+ 2，原根

设$m\in \mathbb{N}^*,~a\in \mathbb{Z}$。若$(a,~m)=1$，且$\delta_{m,~a}=\phi_m$，则 $a$ 为模 $m$ 的原根

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-15-02-47-image.png)

+ + 1，原根判定定理

设 $m\ge 3, (a,~m)=1$，则

$a$ 是模 $m$ 的原根 $\iff  \forall 素因子p\in \phi_{m},~a^{\frac{\phi_m}{p}}\not\equiv 1\pmod{m}$

（证明略）

+ + 2，原根个数

若一个数 $m$ 有原根，则它的原根个数为 $\phi_{\phi_m}$

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-15-19-52-image.png)

+ + 3，原根存在定理

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-15-20-50-image.png)

+ + + 引理
  
  + + ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-15-22-31-image.png)
    
    + ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-15-22-56-image.png)
    
    + ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-15-23-47-image.png)

+ + 最小原根的数量级

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-15-25-21-image.png)

+ 例题          

+ [P6091 【模板】原根 - ![loading-ag-2712]()洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P6091)（gcd+fp+筛+breakdown可以得到最优复杂度）

```cpp
#include <iostream>
#include<algorithm>
using namespace std;

const int N = 1e6+4;
int p[N], idx, st[N], phi[N];
// 判断原根存在性 （如果没有线性筛，复杂度将退化为 > O(N)）
//bool rt[N];
int gp(int n){
    phi[1] = 1;
    for(int i=2; i<=n; ++i){
        if(!st[i]) p[ ++ idx] = i, phi[i] = i-1;
        for(int j=1; p[j]<=n/i; ++j){
            st[i * p[j]] = true;
            phi[i * p[j]] = i % p[j] ? phi[i] * phi[p[j]] : phi[i] * p[j];
            if(!(i % p[j])) break;
        }
    }
//    rt[2] = rt[4] = true;
//    // 枚举奇素数 
//    for(int i=2; i<=idx; ++i){
////            cout << p[i] << '\n';
//        for(long long j=p[i]; j<=n; j*=p[i]){
//            rt[j] = true;
//            if(2 * j <= n) rt[2 * j] = true;
//        }
//    }
}


int gcd(int a, int b){ return !b ? a : gcd(b, a % b); }
int fp(int a, int n, int p){
    int ans = 1;
    while(n){
        if(n & 1) ans = 1ll * ans * a % p;
        a = 1ll * a * a % p;
        n >>= 1;
    }
    return ans;
}

bool check(int a, int p) {
    if(gcd(a, p) != 1) return false;

    int n = phi[p];
    for(int i=2; i*i<=n; i++) {
        if(n % i) continue;
        while(!(n % i)) n /= i;
        if(fp(a, phi[p] / i, p) == 1) return false;
    }
    if (n > 1) if(fp(a, phi[p] / n, p) == 1) return false;

    return true;
}
int findrt (int p) {
//    if(!rt[p]) return -1;
    for (int i=1; i<p; i++)
        if (check(i, p)) return i;
    return -1;
}

int cnt, root[N];
void getrt (int p, int g){
    int prod = 1;
    for (int i=1; i<=phi[p]; i++) {
        prod = 1ll * prod * g % p;
        if (gcd(i,phi[p])==1) {
            root[++ cnt] = prod;
        }
    }
}

int main () {
    gp(N - 1);

    int T;
    scanf("%d", &T);
    while(T--){
        int p, d;
        scanf("%d%d", &p, &d);
        int g = findrt(p);
        if(~g){
            cnt = 0;
            getrt(p, g);
            sort(root+1, root+cnt+1);

            cout << cnt << '\n';
            for(int i=1; i<=cnt/d; i++) printf("%d ", root[i*d]);
            puts("");
        }else puts("0\n");
    }
}
```

+ [Problem - 4992 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=4992)（必须线性筛，否则TLE）

+ [1284 -- Primitive Roots (poj.org)](http://poj.org/problem?id=1284)（水题）

+ [Little Chu - URAL 1268 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/URAL-1268)

+ [Problem - 1114F - Codeforces](https://codeforces.com/problemset/problem/1114/F)

+ [2018秦皇岛ccpc-camp Steins;Gate (原根+FFT) - xiuwenL - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiuwenli/p/9735804.html)

###### 33、离散对数bsgs，离散根dr（男）

主要问题：离散对数$discrete~logarithm$（基础篇+拓展篇），离散根$discrete~roots$（提高篇）

BSGS：可以 $x=\log_a{b}\pmod{P}$ 的最小最小正整数解，复杂度：$O(\sqrt{p})$ 

+ 基础篇

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-02-00-29-08-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-22-10-39-image.png)

+ 两种模板（默认：$(a,p)=1$）

$O(\sqrt{P})$

```cpp
// vector
int _bsgs(int a, int b, int p){
    if(!b) return 0;

    int sq = sqrt(p) + 1;
    vector<pair<int, int>> dec;
    for(int i=1; i<=sq; ++i) dec.push_back({fp(a, i * sq, p), i});
    sort(dec.begin(), dec.end());

    int x0 = INT_MAX;
    for(int i=0; i<sq; ++i){
        int my = fp(a, i, p) * b % p;
        auto it = lower_bound(dec.begin(), dec.end(), make_pair(my, 0ll));
        if(it != dec.end() && it->first == my){
            x0 = min(x0, it->second * sq - i);
            break;
        }
    }
    return x0==INT_MAX ? -1 : x0;
}

// map
int log(int a, int b){
    if(b == 1) return 0;
    int sq = sqrt(P) + 1;

    map<int, int> T;
    // pr = a^t, t = 0..sq
    int pr = 1;
    for(int t=0; t<sq; ++t) T[b * pr % P] = t, pr = pr * a % P;

    // pr1 = (a^sq)^s
    int pr1 = 1;
    for(int s=1; s<=sq; ++s){
        pr1 = pr1 * pr % P;
        if(T.count(pr1)) return s * sq - T[pr1];
    }
    return -1;
}
```

+ 进阶篇

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-22-43-15-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-22-44-03-image.png)

（即：$x~\%p,0\le x\le p-1$ 可以表示为 $x ~\equiv~ g^i~~\%p, 0\le i\le p-1$）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-22-52-47-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-22-54-50-image.png)

（取离散对数？）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-04-22-56-52-image.png)

+ 求所有解：

```cpp
int gcd(int a, int b){ return !b ? a : gcd(b, a % b); }
int fp(int a, int n, int p){
    int ans = 1;
    while(n){
        if(n & 1) ans = ans * a % p;
        a = a * a % p;
        n >>= 1;
    }
    return ans;
}

int rt(int p){
    vector<int> fc;
    int phi = p-1, n = phi;
    for(int i=2; i*i<=n; ++i){
        if(n % i) continue;
        while(!(n % i)) n /= i;
        fc.push_back(i);
    }
    if(n > 1) fc.push_back(n);

    for(int ans=2; ans<=p; ++ans){
        bool ok = true;
        for(int fac : fc){
            if(fp(ans, phi / fac, p) == 1){
                ok = false;
                break;
            }
        }
        if(ok) return ans;
    }
    return -1;
}
int ebg(int a, int b, int p){
    if(!b) return puts("1\n0"), 0;
    int g = rt(p);
    // bsgs discrete logarithm algorithm
    int sq = (int)sqrt(p + .0) + 1;
    vector<pair<int, int>> dec(sq);
    for(int i=1; i<=sq; ++i) dec[i-1] = {fp(g, a * i * sq % (p - 1), p), i};
    sort(dec.begin(), dec.end());

    int x0 = -1;
    for(int i=0; i<sq; ++i){
        int my = fp(g, a * i % (p - 1), p) * b % p;
        auto it = lower_bound(dec.begin(), dec.end(), make_pair(my, 0ll));
        if(it != dec.end() && it->first == my){
            x0 = it->second * sq - i;
            break;
        }
    }
    if(x0 == -1) return puts("0"), -1;

    int delta = (p - 1) / gcd(a, p - 1);
    vector<int> ans;
    for(int cur = x0 % delta; cur < p - 1; cur += delta) ans.push_back(fp(g, cur, p));

    sort(ans.begin(), ans.end());
    cout << ans.size() << '\n';
    for(int x : ans) cout << x << ' ';
    cout << '\n';
    return 1;
}
```

+ 扩展篇

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-10-56-11-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-10-56-27-image.png)

$exbsgs$实现（和朴素$bsgs$只有3个区别）

```cpp
int gcd(int a, int b){ return !b ? a : gcd(b, a % b); }
int fp(int a, int n, int p){ int ans = 1; while(n){ if(n & 1) ans = 1ll * ans * a % p; a = 1ll * a * a % p; n >>= 1; } return ans; }

int exbsgs(int a, int b, int p){
    if(b == 1) return 0;

    // 区别 1 
    long long cnt = 0, k = 1, d;
    while((d = gcd(a, p)) > 1){
        if(b % d) return -1;
        b /= d, p /= d;
        ++ cnt, k = a / d * k % p;
        if(k == b) return cnt;
    }

    int sq = sqrt(p) + 1;
    unordered_map<int, int> dec;

    d = b;
    for(int i=0; i<sq; ++i){
        dec[d] = i;
        d = d * a % p;
    }

    int asq = fp(a, sq, p);
    // 区别2，d初始化为 k，而不是 1
    d = k;
    for(int i=1; i<=sq; ++i){
        d = d * asq % p;
        // 区别3，结果加上 cnt 
        if(dec.count(d)) return cnt + i * sq - dec[d];
    }
    return -1;
}
```

+ 例题

+ [SPOJ.com - Problem MOD](https://www.spoj.com/problems/MOD/)

+ [P3306 [SDOI2013] 随机数生成器 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3306)

+ [Problem - 99999261 - Codeforces](https://codeforces.com/problemsets/acmsguru/problem/99999/261)

+ [#10214. 「一本通 6.4 例 6」计算器 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/10214)

+ [P4195 【模板】扩展 BSGS/exBSGS - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4195)

+ [Problem - F - Codeforces](https://codeforces.com/contest/1106/problem/F)

+ [#6542. 离散对数 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/6542) （index calculus 方法）
