###### 1，向量

定义

向量的线性运算（加、减、数乘）

平面向量基本定理 及 坐标表示

平面向量的坐标运算

向量的数量积

+ 1，定义

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-13-49-33-image.png)

+ + 向量：既有大小又有方向的量。数学上研究的向量为 **自由向量**，即只要不改变它的大小和方向，起点和终点可以任意平行移动的向量。记 $\vec a$ 或 $ \boldsymbol{a}$

+ + 有向线段：带有方向的线段称为有向线段。有向线段有三要素：**起点，方向，长度**，知道了三要素，终点就唯一确定。我们用有向线段表示向量。

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-13-47-35-image.png)

+ + 零/单位/平行/相等/相反 向量

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-13-47-17-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-13-47-44-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-13-49-09-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-13-49-21-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-13-49-37-image.png)

-__- 

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-13-54-01-image.png)

（ $\angle~$，$~\langle a,~b\rangle$，$\perp$ ， ）

（注意到平面向量具有方向性，我们并不能比较两个向量的大小（但可以比较两向量的模长）。但是两个向量可以相等。）

+ 2，向量的线性运算（加、减、数乘）

+ + 加减法

加法：

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-14-04-34-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-14-03-44-image.png)

可以验证，向量的加法满足 **交换律与结合律**

减法：

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-14-13-38-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-14-13-52-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-14-14-28-image.png)

+ + 向量的数乘

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-14-21-15-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-14-21-29-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-14-29-27-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-14-29-35-image.png)

+ + 判定两向量共线

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-14-30-45-image.png)

+ 3，平面向量基本定理 及 坐标表示

+ + 1，平面向量基本定理

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-15-11-21-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-15-13-19-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-15-13-26-image.png)

+ + 2，平面向量的坐标表示

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-15-19-10-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-15-19-16-image.png)

+ 4，平面向量的坐标运算

+ + 1，平面向量的线性运算

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-15-23-54-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-15-24-05-image.png)

+ + 2，求向量的坐标表示

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-15-24-53-image.png)

+ + 3，平移一点

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-15-32-40-image.png)

+ + 4，三点共线的判定

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-15-34-08-image.png)

+ 5，向量的数量积

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-15-42-29-image.png)

（我们发现，这种运算得到的结果是一个实数，为标量，并**不属于向量的线性运算**）

应用：

判定两向量垂直：$\vec a \perp \vec b \iff \vec a ~\cdot~ \vec b ~=~ 0 $

判定两向量共线：$\vec{a}=\lambda\times\vec{b} \iff |\vec{a}\cdot\vec{b}| ~=~ |\vec{a}|\cdot|\vec{b}| $

数量积的坐标运算：若 $\boldsymbol a=(m,n),\boldsymbol b=(p,q),$  则 $\boldsymbol a\cdot \boldsymbol b=mp+nq$

向量的模：$|\boldsymbol a|=\sqrt {m^2+n^2}$

两向量的夹角：$\cos \theta=\cfrac{\boldsymbol a\cdot\boldsymbol b}{|\boldsymbol a||\boldsymbol b|}$

+ 6，扩展

+ + 1，向量 与 矩阵

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-15-53-54-image.png)

+ + 2，向量积

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-16-02-14-image.png)

（右手法则：先打开手掌，$x轴正方向$ 为四指的指向，$z轴正方向$ 为手掌平面内与四指垂直的方向，而 $y轴正方向$ 由 $x轴正方向$ 逆时针转 $90\degree$ 得到）

（由于向量积涉及到空间几何与线性代数知识，所以并未在高中课本中出现）

    几何意义：

$|\boldsymbol a\times \boldsymbol b|$ 是以 $\boldsymbol a,\boldsymbol b$ 为邻边的平行四边形的面积

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-16-17-08-image.png)

（空间向量 $(a,~b,~0)\times(c,~d,~0) ~=~ (0,~0,~a\times d-b\times c)$  ？？  ）

+ + 3，向量旋转

设 $\boldsymbol a=(x,y)$，倾角为$\theta$ ，长度为 $l=\sqrt{x^2+y^2}$。则 $x=l\cos \theta,y=l\sin\theta$。令其逆时针旋转 $\alpha$ 度角，得到向量 $\boldsymbol b=(l\cos(\theta+\alpha),l\sin(\theta+\alpha))$

$\vec b ~=~(l\times\cos(\theta+\alpha),~l\times\sin(\theta+\alpha)) \\ \quad =~(l\times\cos{\theta}\times\cos{\alpha}-l\times\sin{\theta}\times\sin{\alpha},~l\times\sin{\theta}\times\cos{\alpha}+l\times\cos{\theta}\times\sin{\alpha})  \\ \quad=(x\times\cos{\alpha}-y\times\sin{\alpha},~y\times\cos{\alpha}+x\times\sin{\alpha}) $

+ 7，极坐标 与 极坐标系

+ + 任意角 与 弧度制

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-16-51-47-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-16-51-52-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-17-06-36-image.png)

（$弧度~=~ \displaystyle \frac{弧长}{半径}$）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-17-08-37-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-17-08-45-image.png)

###### 2，矩阵（待补（树的部分））

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-17-09-43-image.png)

（常系数齐次递推？ohhhhhh）

^__^

+ 性质

矩阵的逆：

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-17-12-05-image.png)

+ 运算

矩阵的加减法是逐个元素进行的

+ + 矩阵乘法

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-17-18-57-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-17-19-05-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-17-19-10-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-17-26-54-image.png)

+ 应用

+ + 1，加速递推

只需要知道 **初始向量** 和 **递推矩阵** $M$ 就可以了

（有时候初始向量较难构造；）

（**warning**： 矩阵维数必须 $N \le 500$ ）

[(17条消息) 矩阵快速幂习题_cheng__yu_的博客-CSDN博客](https://blog.csdn.net/cheng__yu_/article/details/107148615)

[「学习笔记」矩阵快速幂 - cyhyyds - 博客园 (cnblogs.com)](https://www.cnblogs.com/chenyuhe/p/15837622.html)

1，[P1962 斐波那契数列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1962)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-21-20-33-image.png)

根据 $(f_{n+1},~f_{n}) ~=~ (f_{n},~f_{n-1})\times M$ 构造矩阵 $M$

易得：$\left[\begin{array}{ccc} 1 & 1 \\ 1 & 0 \end{array}\right]$

（构造顺序：按顺序对 $M$ 的每一列进行构造）

（这题可以作为板子）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define no(u) memset(u, 0, sizeof u)
#define int long long

const int P = 1e9+7;
// 1：矩阵大小
#define N 2
void mul(int a[N][N], int b[N][N]){
    int ans[N][N] = {};
    for(int i=0; i<N; ++i) for(int j=0; j<N; ++j) for(int k=0; k<N; ++k)
        ans[i][j] = (ans[i][j] + a[i][k] * b[k][j] % P) % P;
//  如果用 sizeof a 等着见阎罗王吧！！（a[]作为参数传送会出错）
    memcpy(a, ans, sizeof ans);
}

// 2：初始向量 (f2, f1)
int st[N] = {1, 1};
int fp(int n){        // (fn, f(n-1)) = (f2, f1) \times M^(n-2)
//  3：递推矩阵 M
    int a[N][N] = {{1, 1}, {1, 0}};
    int ans[N][N]= {};
    for(int i=0; i<N; ++i) ans[i][i] = 1;
    while(n > 0){
        if(n & 1) mul(ans, a);
        mul(a, a);
        n >>= 1;
    }

    int ret = 0;
    for(int i=0; i<N; ++i) ret = (ret + st[i] * ans[i][0] % P) % P;
    return ret;
}


signed main(){
    int n;
    while(cin >> n){
        cout << fp(n-2) << '\n';
    }
}
```

2，[P1349 广义斐波那契数列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1349)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-21-52-05-image.png)

$st = (f_2,~f_1) = (1,~1)$ 

$M = \begin{bmatrix}p & 1\\ q & 0\end{bmatrix}$

3，[P1939 【模板】矩阵加速（数列） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1939)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-27-21-51-52-image.png)

$st = (f_3,~~f_2,~~f_1) = (1,~~1,~~1)$

$M = \begin{bmatrix} 1 & 1 & 0\\ 0 & 0 & 1 \\ 1 & 0 & 0 \end{bmatrix}$

4，$\begin{gathered}
f_{1} = f_{2} = 0\\
f_{n} = 7f_{n-1}+6f_{n-2}+5n+4\times 3^n
\end{gathered}$

这是个结合了 1次多项式 和 幂函数 的递推式

（维数 = 2 + 2 + 1 = 5维（n次多项式对维数的贡献是n+1））

$F_n := (f_n,~~f_{n-1},~~n,~~3^n,~~1)$ ，$F_n\times M ~=~ F_{n+1}$

$st = F_2 = (f_2,~~f_1,~~2,~~9,~~1) = (0,~~0,~~2,~~9,~~1)$

$M = \begin{bmatrix} 7 & 1 & 0 & 0 & 0 \\ 6 & 0 & 0 & 0 & 0 \\ 5 & 0 & 1 & 0 & 0 \\ 12 & 0 & 0 & 3 & 0 \\ 5 & 0 & 1 & 0 & 1 \end{bmatrix}$

5，2019牛客第五场 B. generator 1

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-28-10-10-43-image.png)
**十进制矩阵快速幂**

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define N 2
int P;

void mul(int a[N][N], int b[N][N]){
    int ans[N][N] = {};
    for(int i=0; i<N; ++i) for(int j=0; j<N; ++j) for(int k=0; k<N; ++k)
        ans[i][j] = (ans[i][j] + a[i][k] * b[k][j] % P) % P;
    memcpy(a, ans, sizeof ans);
}

int st[N], m[N][N];
int fp(string n){
    int a[N][N] = {};
    memcpy(a, m, sizeof m);
    int ans[N][N] = {};
    for(int i=0; i<N; ++i) ans[i][i] = 1;
    // 核心
    for(int i=n.size()-1; i>=0; --i){
        int cnt = n[i] - '0';
        for(int j=0; j<cnt; ++j) mul(ans, a);

        int tmp[N][N] = {{1, 0}, {0, 1}};
        for(int j=0; j<10; ++j) mul(tmp, a);
        memcpy(a, tmp, sizeof tmp);
    }

    int ret = 0;
    for(int i=0; i<N; ++i) ret = (ret + st[i] * ans[i][1] % P) % P;
    return ret;
}

signed main(){
    string n;
    cin >> st[1] >> st[0] >> m[0][0] >> m[1][0];
    cin >> n >> P;
    for(int i=1; i<N; ++i) m[i-1][i] = 1;

    // n = n-1
//    int i = n.size()-1;
//    while(n[i] == '0') -- i;
//    if(!i && n[i] == '1') n.erase(0, 1);
//    else -- n[i];
//    int j = i + 1;
//    while(j < n.size()) n[j] = '9', ++ j;

    cout << fp(n) << '\n';
}
```

6，[3233 -- Matrix Power Series (poj.org)](http://poj.org/problem?id=3233)

非常恶心之矩阵分块乘法

7，[Problem - 2276 (hdu.edu.cn)](http://acm.hdu.edu.cn/showproblem.php?pid=2276)

较好的思维题

给定01序列 $F=[f_0,~f_2,~...,~f_{n-1}]$，$F$ 经过一次变换后，若 $f_{(i-1)\%n}=1$ ，则 $f_i$ 置反

如：$\displaystyle 0101111\implies 1111000$

讨论最简单的形式：$\begin{bmatrix} \dots & f_1 & f_2 & \dots \end{bmatrix}\times \begin{bmatrix} \vdots \\ a \\ b \\ \vdots \end{bmatrix} \equiv (f_1\otimes a)\oplus(f_2\otimes b) = f'_2$

（上面的列向量是 $M$ 中的一部分，$f'_2$ 即需要求的 $f_2$ 转换后状态）

（**注意**：$\equiv$ 后面的部分表示通过定义 $\otimes$ 和 $\oplus$ 运算，一些多余的部分的对值没有贡献）

如果对 $f_1,~f_2,~f'_2$ 进行真值表的观察发现 $f_1 \bigoplus f_2 = f'_2$ （$\bigotimes$指异或）

定义：$\oplus = \bigoplus$， $\otimes = \&$ 

自然地，递推矩阵 $M = \begin{bmatrix} 1 & 1 & 0 & \dots & 0 \\ 0 & 1 & 1 & \dots & 0 \\ 0 & 0 & 1 & \dots & 0 \\ & \vdots & & \vdots \\ 0 & 0 & 0 & \dots & 1 \\ 1 & 0 & 0 & \dots & 1 \end{bmatrix}$ 

```cpp
#include<bits/stdc++.h>
using namespace std;

#define N 100
#define mc(u, v) memcpy(u, v, sizeof v)

int n;
void mul(int a[N][N], int b[N][N]){
    int ans[N][N] = {};
    for(int i=0; i<n; ++i) for(int j=0; j<n; ++j) for(int k=0; k<n; ++k)
        ans[i][j] ^= a[i][k] & b[k][j];
    mc(a, ans);
}

int st[N], m[N][N];
void fp(int k){
    int a[N][N] = {}; mc(a, m);
    int ans[N][N] = {}; mc(ans, m);

    -- k;
    while(k){
        if(k & 1) mul(ans, a);
        mul(a, a);
        k >>= 1;
    }

    int ret[N] = {};
    for(int i=0; i<n; ++i) for(int j=0; j<n; ++j) ret[i] ^= st[j] & ans[j][i];
    for(int i=0; i<n; ++i) cout << ret[i];
    cout << '\n';
}

int main(){
    int k;
    string s;
    while(cin >> k >> s){
        memset(st, 0, sizeof st);
        memset(m, 0, sizeof m);


        for(int i=0; i<s.size(); ++i) st[i] = s[i] - '0';
        n = s.size();
        for(int i=0; i<n; ++i) m[i][i] = m[(i-1+n)%n][i] = 1;

        fp(k);
    }
}
```

8，[Problem - E - Codeforces](https://codeforces.com/contest/1182/problem/E)（好题）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-29-10-56-53-image.png)

$f_{n} = f_{n-1}\times f_{n-2}\times f_{n-3}\times c^{2\times n-6}$

$f_n := f_1^{F_{1,~n}}\times f_2^{F_{2,~n}}\times f_3^{F_{3,~n}}\times c^{F_{4,~n}}$

（$F_{i,~n}$ 分别表示 $f_n$ 中 $f_1,~f_2,~f_3,~c$ 的幂次）

因此，计算出 $F_{1,~n},~F_{2,~n},~F_{3,~n},~F_{4,~n}$ 即可得到答案：

1）$F_{i,~n} = F_{i,~n-1} + F_{i,~n-2} + F_{i,~n-3}，i=1..3$ 

此形式可以用矩阵快速幂

（三个贡献分别来自于 $f_{n-1}， f_{n-2}， f_{n-3}$）

$\begin{bmatrix}F_{i,~n} & F_{i,~{n-1}} & F_{i,~{n-2}}\end{bmatrix}\times M_i = \begin{bmatrix}F_{i,~~{n+1}} & F_{i,~~{n}} & F_{i,~{n-1}}\end{bmatrix}$

$M_i = \begin{bmatrix}1 & 1 & 0 \\ 1 & 0 & 1 \\ 1 & 0 & 0\end{bmatrix}，i=1..3$

$\because f_1 = f_1^1\times f_2^0\times f_3^0 \\ f_2 = f_1^0\times f_2^1\times f_3^0 \\ f_3 = f_1^0\times f_2^0\times f_3^1$

$\therefore st_1 = \begin{bmatrix}F_{1,~~3} & F_{1,~~{2}} & F_{1,~{1}}\end{bmatrix} = \begin{bmatrix}0 & 0 & 1\end{bmatrix}$

$st_2 = \begin{bmatrix}F_{2,~~3} & F_{2,~~{2}} & F_{2,~{1}}\end{bmatrix} = \begin{bmatrix}0 & 1 & 0\end{bmatrix}$

$st_3 = \begin{bmatrix}F_{3,~~3} & F_{3,~~{2}} & F_{3,~{1}}\end{bmatrix} = \begin{bmatrix}1 & 0 & 0\end{bmatrix}$

2）$F_{4,~n} = F_{4,~~n-1} + F_{4,~~n-2} + F_{4,~n-3} + 2\times n-6$

$\begin{bmatrix}F_{i,~~n} & F_{i,~~{n-1}} & F_{i,~{n-2}} & n & 1\end{bmatrix}\times M_4 = \begin{bmatrix}F_{i,~~{n+1}} & F_{i,~~{n}} & F_{i,~{n-1}} & n & 1\end{bmatrix}$

$M_4 = \begin{bmatrix}1 & 1 & 0 & 0 & 0\\ 1 & 0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 0 & 0 \\ 2 & 0 & 0 & 1 & 0 \\ -4 & 0 & 0 & 1 & 1\end{bmatrix}$

$st_4 = \begin{bmatrix}0 & 0 & 0 & 3 & 1\end{bmatrix}$

（$F_{i,~n}$ 很大，所以要欧拉降幂）

```cpp
#include<bits/stdc++.h>
using namespace std;

#define N 5
#define mc(u, v) memcpy(u, v, sizeof v)
#define int long long

const int P = 1e9+7, p = 1e9+6;
int n;
void mul(int a[N][N], int b[N][N]){
    int ans[N][N] = {};
    for(int i=0; i<n; ++i) for(int j=0; j<n; ++j) for(int k=0; k<n; ++k)
        ans[i][j] = (ans[i][j] + a[i][k] * b[k][j] % p) % p;
    mc(a, ans);
}

int k, f1, f2, f3, c;
int st[4][N] = {
{0, 0, 1},
{0, 1, 0},
{1, 0, 0},
{0, 0, 0, 3, 1}
};
int m[4][N][N] = {
{{1, 1, 0}, {1, 0, 1}, {1, 0, 0}},
{{1, 1, 0}, {1, 0, 1}, {1, 0, 0}},
{{1, 1, 0}, {1, 0, 1}, {1, 0, 0}},
{{1, 1, 0, 0, 0}, {1, 0, 1, 0, 0}, {1, 0, 0, 0, 0}, {2, 0, 0, 1, 0}, {p-4, 0, 0, 1, 1}}
};
int mfp(int f, int k){
    int a[N][N] = {}; mc(a, m[f]);
    int ans[N][N] = {}; mc(ans, a);
    -- k;
    while(k){
        if(k & 1) mul(ans, a);
        mul(a, a);
        k >>= 1;
    }

    int ret = 0;
    for(int i=0; i<n; ++i) ret = (ret + st[f][i] * ans[i][0] % p) % p;
    return ret;
}
int fp(int a, int n){
    int ans = 1;
    while(n){
        if(n & 1) ans = ans * a % P;
        a = a * a % P;
        n >>= 1;
    }
    return ans;
}

signed main(){
    cin >> k >> f1 >> f2 >> f3 >> c;
    k -= 3;
    n = 3;
    int ans = fp(f1, mfp(0, k)) * fp(f2, mfp(1, k)) % P * fp(f3, mfp(2, k)) % P;
    n = 5;
    ans = ans * fp(c, mfp(3, k)) % P;
    cout << ans << '\n';
}
```

9，[2017年铜牌题 [Cloned] - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/contest/299842#problem/N)

求：$f_n = f_{n-1} + 2\times f_{n-2} + n^4$，$f_1 = a,~f_2 = b$

（需要二项式定理）

$f_{n+1} = f_{n} + 2\times f_{n-1} + (n+1)^4  \\ = f_{n} + 2\times f_{n-1} + C_4^4\times n^4 + C_4^3\times n^3 + C_4^2\times n^2 + C_4^1\times n^1 + C_4^0\times n^0 \\= f_{n} + 2\times f_{n-1} + n^4 + 4\times n^3 + 6\times n^2 + 4\times n^1 + n^0 $

（$(n+1)^3,~(n+1)^2,~(n+1)^1,~(n+1)^0$ 的拆分同理 ）

$\begin{bmatrix}f_n & f_{n-1} & n^4 & n^3 & n^2 & n^1 & 1\end{bmatrix}\times M = \begin{bmatrix}f_{n+1} & f_{n} & (n+1)^4 & (n+1)^3 & (n+1)^2 & (n+1)^1 & 1\end{bmatrix}$

$M = \begin{bmatrix}1 & 1 & 0 & 0 & 0 & 0 & 0 \\ 2 & 0 & 0 & 0 & 0 & 0 & 0 \\ 1 & 0 & 1 & 0 & 0 & 0 & 0 \\ 4 & 0 & 4 & 1 & 0 & 0 & 0 \\ 6 & 0 & 6 & 3 & 1 & 0 & 0 \\ 4 & 0 & 4 & 3 & 2 & 1 & 0 \\ 1 & 0 & 1 & 1 & 1 & 1 & 1 \end{bmatrix}$

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
#define N 7
#define mc(u, v) memcpy(u, v, sizeof v)

const int P = 2147493647;
void mul(int a[N][N], int b[N][N]){
    int ans[N][N] = {};
    for(int i=0; i<N; ++i) for(int j=0; j<N; ++j) for(int k=0; k<N; ++k)
        ans[i][j] = (ans[i][j] + a[i][k] * b[k][j] % P) % P;
    mc(a, ans);
}

int n, a, b;
int st[N] = {b, a, 16, 8, 4, 2, 1};
int m[N][N] = {
{1, 1, 0, 0, 0, 0, 0},
{2, 0, 0, 0, 0, 0, 0},
{1, 0, 1, 0, 0, 0, 0},
{4, 0, 4, 1, 0, 0, 0},
{6, 0, 6, 3, 1, 0, 0},
{4, 0, 4, 3, 2, 1, 0},
{1, 0, 1, 1, 1, 1, 1}};
int fp(int n){
    int a[N][N] = {}; mc(a, m);
    int ans[N][N] = {}; for(int i=0; i<N; ++i) ans[i][i] = 1;

    while(n){
        if(n & 1) mul(ans, a);
        mul(a, a);
        n >>= 1;
    }

    int ret = 0;
    for(int i=0; i<N; ++i) ret = (ret + st[i] * ans[i][0] % P) % P;
    return ret;
}

signed main(){
    int T;
    cin >> T;
    while(T--){
        cin >> n >> a >> b;
//        m[0][0] = a, m[1][0] = b;
        st[0] = b, st[1] = a;
        if(n == 1) cout << a << '\n';
        else if(n == 2) cout << b << '\n';
        else cout << fp(n-2) << '\n';
    }
}
```

10，[Problem - C - Codeforces](https://codeforces.com/gym/102966/problem/C)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-28-14-17-35-image.png)

构造矩阵$\begin{bmatrix}f_1 & f_2 & ... & f_n \end{bmatrix}$，$f_i$ 表示当前在 点$i$  的概率，

令 $\begin{bmatrix}f_1 & f_2 & ... & f_n \end{bmatrix}\times M = \begin{bmatrix}f'_1 & f'_2 & ... & f'_n \end{bmatrix}$

则 $f'_i ~=~ \sum\limits_{j=1}^n f_j\times M_{j,~i}$  为全概率公式的形式？ 

那么 $f'_i$ 的含义就是经过一次变换后出现在 点$i$  的概率

另外，初始矩阵为：$[1,~0,~...,~0]$ （可以偷懒最后只输出 $M^k_{1,~i},~i=1..n$）

```cpp
#include<bits/stdc++.h>
using namespace std;

#define db double
#define mc(u, v) memcpy(u, v, sizeof v)
#define N 200

int n;
void mul(db a[N][N], db b[N][N]){
    db ans[N][N] = {};
    for(int i=0; i<n; ++i) for(int j=0; j<n; ++j) for(int k=0; k<n; ++k)
        ans[i][j] += a[i][k] * b[k][j];
    mc(a, ans);
}

db st[N], m[N][N];
void fp(int k){
    db a[N][N] = {}; mc(a, m);
    db ans[N][N] = {}; for(int i=0; i<N; ++i) ans[i][i] = 1;

    while(k){
        if(k & 1) mul(ans, a);
        mul(a, a);
        k >>= 1;
    }

    for(int i=0; i<n; ++i) cout << ans[0][i] << '\n';
}

signed main(){
    int k;
    cin >> n >> k;
    for(int i=0; i<n; ++i) for(int j=0; j<n; ++j) cin >> m[i][j];
    fp(k);
}
```

11，[P3758 [TJOI2017]可乐 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3758)

[P5789 [TJOI2017]可乐（数据加强版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5789)

和第（10）题很像，初始时设置矩阵 $F := [f_1,~f_2,~f_3,~...,~f_n]$ 表示当前停留在每个点的“机器人数量”，递推矩阵 $M$ 就是原图（$01$ 矩阵），每经过一次变换可解释为各个机器人复制一次到达另一个点（可以是自己），经过 $k$ 次变换后的 向量 $F$ 的机器人数量的总和即为方案总和

（初始时 $F=[1,~0,~0,~...,~0]$ ）

“爆炸”：进入出度为0 的点

“停在原地”：通过自环走向自己

（灵感：改变初始矩阵 $F$  或 把 $01递推矩阵M$ 改为 $带权矩阵 M$ 就能得到新题）

12，[P2886 [USACO07NOV]Cow Relays G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2886)

（“定时”最短路，tnnd，不造哪里错）

13，[P2233 [HNOI2002]公交车路线 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2233)

（easy题）

+ + 2，矩阵表达修改（待补）

[P7453 [THUSCH2017] 大魔法师 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P7453)

[#6208. 树上询问 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/6208)

+ + 3，定长路径统计

给定 $n$ 阶有向图，边权为1，求边数为 $k$ 的 $u\to v$ 的路径数

若 $u\to v$ 有直接路径，则 $G_{u,~v}$ 为直接路径的数量，否则为 0 

$G_{p+1} = G_p\times G = \sum\limits_{k=1}^n G_{i,~k}\times G_{k,~j}$

+ + 4，定长最短路

给定 $n$ 阶有向图，边权为1，求边数为 k 的 $u\to v$ 的路径数

若 $u\to v$ 有直接路径，则 $G_{u,~v}$ 为重边权的最小值，否则为 $\infin$ 

$G_{p+1} = G_p\otimes G = \min\limits_{k=1}^n \{G_{i,~~k}+ G_{k,~~j}\}$

+ + 5，限长路径计数/最短路

（3）/（4）中的图加上权为 1 / 0 的自环即可

###### 3，高斯消元（待补）

$det_{A}~=~\sum\limits_{\sigma\in S_n}sgn_{\sigma}\times \prod\limits_{i=1}^n a_{i,~\sigma_{i}}$

###### 4，特征多项式（待补）

###### 5，线性基（待补）

（待补知识：线性基合并，实数线性基）

线性基是向量空间的一组基，通常可以解决有关异或的一些题目。

通俗一点的讲法就是由一个集合构造出来的另一个集合，它有以下几个性质：

- 线性基的元素能相互异或得到原集合的元素的所有相互异或得到的值。

- 线性基是满足性质 1 的最小的集合。

- 线性基没有异或和为 0 的子集。

- 线性基中每个元素的异或方案唯一，也就是说，线性基中不同的异或组合异或出的数都是不一样的。

- 线性基中每个元素的二进制最高位互不相同。

```cpp
#define int long long
const int N = 63;

int a[N], zero;
void add(int w){
    for(int i=N-1; ~i; --i){
        if(!(w >> i & 1)) continue;
        if(!a[i]) return void(a[i] = w);
        w ^= a[i];
    }
}
// 查询 w 是否能被异或出来 
bool ask(int w){
    for(int i=N-1; ~i; --i){
        if(!(w >> i & 1)) continue;
        w ^= a[i];
    }
    return !w;
}
// 查询异或最小值
int gmin(){
    if(zero) return 0;
    for(int i=0; i<N; ++i) if(a[i]) return a[i];
}
// 查询异或最大值
int gmax(){
    int ans = 0;
    for(int i=N-1; ~i; --i) ans = (ans, ans ^ a[i]);
    return ans;
}

int cnt, d[N];
// 重构线性基 
void rebuild(){
    cnt = 0;
    for(int i=N-1; ~i; --i)
        for(int j=i-1; ~j; --j)
            if(a[i] >> j & 1) a[i] ^= a[j];
    for(int i=0; i<N; ++i) if(a[i]) d[cnt ++] = a[i];
}
// 查询异或第k小值 （正确性未知）
int kth(int k){
    if(k == zero) return 0;
    k -= zero;
    if(k >> cnt & 1) return -1;
    int ans = 0;
    for(int i=cnt-1; ~i; --i) if(k >> i & 1) ans ^= d[i];
    return ans;
}
// 查询 w的异或排名（正确性未知） 
int rank(int w){
    int ans = 0;
    for(int i=N-1; ~i; --i)
        if(w >= a[i]) ans |= 1 << i, w ^= a[i];
    return ans + zero;
}
```

较好的理论介绍：

[P3812 【模板】线性基 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/solution/P3812)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数学\_线性代数\assets\2022-07-30-12-05-40-image.png)

[xor（线性基的合并） - 执||念 - 博客园 (cnblogs.com)](https://www.cnblogs.com/caijiaming/p/11263221.html)

+ [P3857 [TJOI2008]彩灯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3857)

求线性基大小（裸题）

+ [P4301 [CQOI2013] 新Nim游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4301)

1）第一次取走任意堆后使得之后的局面所有数的异或和不为0时（即后手必败局面），先手必胜

因为一个数 $w$ 插入线性基后返回0 意味着 $w=0$ 或 $w$ 可以用之前插入线性基的数 线性表示（即为几个数异或和； $a$ ^ $b$ ^ $...$ ^ $u$ ^ $w = 0$  $\implies$ $a$ ^ $b$ ^ $...$ ^ $u = w$ （$w\ne 0$ 的情况） ） 

根据线性基的性质：线性基内任意几个数的异或不为0

因此游戏的第一个回合 取出插入失败的所有数，而插入成功的数不可能线性表示0，进而必然导致后手必败局面

2）要使第一回合所取数之和最小，可以证明贪心策略可以满足要求（从大到小插入每个数）

定理：$a$ ^ $b$ ^ $...$ $\le a+b+...$    （异或是不仅为加法）

+ [P4570 [BJWC2011]元素 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4570)（待看）

关于贪心策略的理论：[(19条消息) 拟阵：贪心原理（bzoj 3105: [cqoi2013]新Nim游戏）_Jaihk662的博客-CSDN博客](https://blog.csdn.net/Jaihk662/article/details/75050313)

[线性基学习笔记 | Sengxian's Blog](https://blog.sengxian.com/algorithms/linear-basis)

+ 查找异或和为第 $k$ 小的值（没有返回-1） 

```cpp
int cnt, d[N];
// 重构线性基
void rebuild(){
    cnt = 0;
    for(int i=N-1; ~i; --i)
        for(int j=i-1; ~j; --j)
            if(a[i] >> j & 1) a[i] ^= a[j];
    for(int i=0; i<N; ++i) if(a[i]) d[cnt ++] = a[i];
}
int kth(int k){
    if(cnt != n) -- k;
    if(k >= (1ll << cnt)) return -1;
    int ans = 0;
    for(int i=cnt-1; ~i; --i) if(k >> i & 1) ans ^= d[i];
    return ans;
}
```

+ [P4151 [WC2011]最大XOR和路径 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4151)

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
const int N = 63, M = 5e4+3;
int a[N];
void add(int w){
    for(int i=N-1; ~i; --i){
        if(!(w >> i & 1)) continue;
        if(!a[i]) return void(a[i] = w);
        w ^= a[i];
    }
}


struct nd{ signed v, ne; int w; }e[M<<2];
signed idx, n, h[M]; int xr[M]; bool st[M];
void add(signed u, signed v, int w){
    e[ ++ idx] = {v, h[u], w}, h[u] = idx;
}

void dfs(int u, int p, int res){
    st[u] = true, xr[u] = res;
    for(int i=h[u]; i; i=e[i].ne){
        int v = e[i].v, w = e[i].w;
        if(v == p) continue;
        // s -> ... -> u -> v 没出现过环，继续搜 
        if(!st[v]) dfs(v, u, res ^ w);
        // s -> ... -> v -> ... -> u -> v，即 v为环口 
        // res ^ w 表示 从 s -> u 的异或和，再异或上 xr[v] 相当于消除 s->v的贡献
        // res ^ w ^ xr[v] 则表示环的异或和 
        else add((res ^ w) ^ xr[v]);
    }
}


signed main(){
    ios::sync_with_stdio(false);

    int m;
    cin >> n >> m;
    for(int i=0; i<m; ++i){
        int u, v, w;
        cin >> u >> v >> w;
        add(u, v, w), add(v, u, w);
    }

    dfs(1, 0, 0ll);
    int ans = xr[n];
    for(int i=N-1; ~i; --i) ans = max(ans, ans ^ a[i]);
    cout << ans << '\n';
}
```

+ [P3292 [SCOI2016]幸运数字 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3292)（待补）

前置：LCA，tarjan等

+ [Problem - 6579 (hdu.edu.cn)](http://acm.hdu.edu.cn/showproblem.php?pid=6579) 

前缀线性基 + 湿马的强制在线（每次操作的参数需要异或上一个输出的数）

```cpp
#define int long long
#define mc(u, v) memcpy(u, v, sizeof v)
#define ms(u) memset(u, 0, sizeof u)
const int N = 31, M = 5e5+3;
int a[M][N], pos[M][N], num;
void add(int w){
    ++ num;
    mc(a[num], a[num-1]), mc(pos[num], pos[num-1]);

    int p = num;
    for(int i=N-1; ~i; --i){
        if(!(w >> i & 1)) continue;
        if(!a[num][i]) return void((a[num][i] = w, pos[num][i] = p));
        else{
            if(pos[num][i] < p) swap(a[num][i], w), swap(pos[num][i], p);
            w ^= a[num][i];
        }
    }
}

int gmax(int lb, int ub){
    int ans = 0;
    for(int i=N-1; ~i; --i){
        if(pos[ub][i] < lb) continue;
        ans = max(ans, ans ^ a[ub][i]);
    }
    return ans;
}

int gmin(int lb, int ub){
    for(int i=N-1; ~i; --i){
        if(pos[ub][i] < lb) continue;
        if(a[ub][i]) return a[ub][i];
    }
    return 0;
}
```

相同的题目：[Problem - F - Codeforces](https://codeforces.com/contest/1100/problem/F)（离线）
