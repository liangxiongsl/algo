###### 1、莫比乌斯反演

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-15-57-56-image.png)

+ 前置知识：数论分块、狄利克雷卷积

+ 1，莫比乌斯函数

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-16-20-29-image.png)

+ + **性质1**

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-16-21-02-image.png)

（$\epsilon_n=[n=1]$）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-16-21-29-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-16-22-18-image.png)

+ + **结论1**（将 性质1的$\epsilon_{(i,~j)}$ 展开即可）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-16-23-21-image.png)

+ **2，线性筛**：略

+ **3，欧拉函数的性质：**

<img src="file:///D:/Document%20And%20Settings2/lx/Desktop/project-梁雄/img/2022-07-05-16-40-21-image.png" title="" alt="" data-align="center">

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄/img\2022-07-05-16-44-18-image.png)

（为什么只要证明 $n^{'}=p^c$ 的情况？）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-16-45-26-image.png)

（证：$\phi ~*~1 = id \implies \phi ~*~ 1 ~*~ \mu = \operatorname{id} ~*~ \mu \\  \implies \phi ~*~ \epsilon = \operatorname{id} ~*~ \mu \implies \phi = \operatorname{id} ~*~ \mu  $）

（证$\operatorname{f} ~*~\epsilon = \operatorname{f}$：$\operatorname{f} ~*~ \epsilon = \sum\limits_{d|n}f_d \times [\frac{n}{d}=1] ~=~f_n ~=~ \operatorname{f}$）

+ **4，莫比乌斯变换**

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-17-07-01-image.png)

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-17-06-51-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-17-12-25-image.png)

（黎曼函数？狄利克雷生成函数？）

+ ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-17-18-39-image.png)

证明：

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-18-07-50-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-18-08-15-image.png)

（~~就是 莫比乌斯 比较好欺负呗~~）

+ 5，问题举例

+ + 1，[P2522 [HAOI2011]Problem b - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2522)

$求\displaystyle\sum\limits_{i=x}^{n}\sum\limits_{j=y}^{m}[\gcd(i,j)=k]\qquad (1\leqslant T,x,y,n,m,k\leqslant 5\times 10^4)$

$ ~=~ \displaystyle\sum\limits_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{m}{k}\rfloor}[(i,j)=1]  ~=~ \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\varepsilon((i,j)) =~ \sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\sum_{d\mid \gcd(i,j)}\mu_d $

$~=~ \displaystyle \sum_{d=1}^{min\{ \lfloor\frac{n}{k}\rfloor,~\lfloor\frac{m}{k}\rfloor \}} \mu_d\times \sum_{d | i}[i\le min] \times \sum_{d | j}[j\le min] $

（或 ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-05-20-30-28-image.png)）

$~=~ \displaystyle\sum_{d=1}^{\min(\lfloor \frac{n}{k}\rfloor,\lfloor \frac{m}{k}\rfloor)}\mu_d \times \lfloor\frac{n}{kd}\rfloor \times \lfloor\frac{m}{kd}\rfloor$

( 注意:$\displaystyle\lfloor\frac{a}{b\times c}\rfloor ~=~ \lfloor\frac{\lfloor \frac{a}{b} \rfloor}{c}\rfloor$，因此 $n,m$ 可以提前 $n/=k,m/=k$ )

$复杂度：O(n ~+~ \sqrt{n/k}\times T) = O(n ~+~ \sqrt{n}\times T)$

```cpp
// 两种实现都是可以的
int block(int n, int m, int k){
    n /= k, m /= k;
    int ans = 0;
    for(int lb = 1, ub; lb<=min(n, m); lb = ub + 1){
        ub = min(n / (n / lb), m / (m / lb));
        ans += (ms[ub] - ms[lb-1]) * (n / lb) * (m / lb);
    }
    return ans;
}
int block1(int n, int m, int k){
    int ans = 0;
    for(int lb = 1, ub; lb<=min(n/k, m/k); lb = ub + 1){
        ub = min(n / (n / lb), m / (m / lb));
        ans += (ms[ub] - ms[lb-1]) * (n / (lb * k)) * (m / (lb * k));
    }
    return ans;
}
```

+ + 2，[SPOJ.com - Problem LCMSUM](https://www.spoj.com/problems/LCMSUM/)

$\displaystyle \sum_{i=1}^n \operatorname{lcm}(i,n)\quad \text{s.t.}\ 1\leqslant T\leqslant 3\times 10^5,1\leqslant n\leqslant 10^6$

+ + + 1，$\phi_n$ 的一个性质（对 $i=1..n$ 内 $(i,~n)$相同的数进行分组）：

$\displaystyle\sum_{i=1}^n 1 ~=~ \sum_{d|n}\phi_{\frac{n}{d}}\times 1$

比如：

$\displaystyle\sum_{i=1}^n (i,~n)^k ~~=~~ \sum_{d|n}\phi_{\frac{n}{d}}\times d^k$

$\displaystyle\sum_{i=1}^n \frac{n^2}{(i,~n)} ~~=~~ \sum_{d|n}\frac{n^2\times\phi_{\frac{n}{d}}}{d}$

```cpp
// i=1..n, 按 d = (i, n) 进行分组，d 枚举的是最小的  
map<int, vector<int>> mp;
for(int i=1; i<=100; ++i){
    int my = gcd(i, 100);
    mp[my].push_back(i);
}
for(auto x : mp){
    cout << x.first << ' ' << phi(100 / x.first) << '\n';
    for(auto v : x.second) cout << v << ' ';
    puts("\n");
}
```

+ + + **2，可以证明一个关于线性筛积性函数的结论**：（筛卷积）

对于函数：$f_n ~=~ \sum\limits_{d|n}d^x\times \phi_d \\ \implies f_{i\times p_j} [p_j |i] = f_i ~+~ (f_i ~-~ f_{\frac{i}{p_j}})\times p_j^{x+1},~ f_p ~=~ 1 ~+~ (p-1)\times p^x  $

证明：

引理1：线性筛要求 $f_{i\times p_j} ~[p_j ~|~i]$ 时，设 $i ~=~ a\times p_j^k,~k\in N^+,~(a,~p_j)=1$，那么$i\times p_j = a\times p_j^{k+1}，\frac{i}{p_j} = a\times p_j^{k-1}$  

$\displaystyle \frac{f_{i\times p_j} ~-~ f_{i}}{f_{i} ~~-~~ f_{\frac{i}{p_j}}} ~=~ \frac{f_a\times (f_{p_j^{k+1}} ~-~ f_{p_j^{k}})}{f_a\times (f_{p_j^{k}} ~~-~~ f_{p_j^{k-1}})} = \frac{ f_{p_j^{k+1}} ~~-~~ f_{p_j^{k}}}{ f_{p_j^{k}} ~~-~~ f_{p_j^{k-1}}} \qquad ①$

若等式右边可以消掉，将右边记为函数 $g_{p_j}$，则$f_{i\times p_j}$ 即可通过$f_{i},~f_{\frac{i}{p_j}},~g_{p_j}$求得

引理2：$\displaystyle f_{p^k} ~~=~~ \sum\limits_{d|p^k}d^x\times \phi_{d} ~\overset{①}=~ \sum_{i=0}^k p^{i\times x} \times \phi_{p^i} ~\overset{②}=~ \sum_{i=0}^k p^{i\times (x ~+~ 1)-1}\times (p-1) \\ \implies \begin{cases} f_{p^{k+1}} - f_{p^k} = p^{(k+1)\times(x+1)-1}\times (p-1) \\  f_{p^{k}} - f_{p^{k-1}} = p^{k\times(x+1)-1}\times (p-1) \end{cases} \\ \implies \frac{f_{p^{k+1}} - f_{p^k}}{f_{p^{k}} - f_{p^{k-1}}} = p^{x+1}  $

将上式代入引理1中的 $①$ ，稍作化简即得 $f_{i\times p_j} = f_i ~~+~~ (f_i ~~-~~ f_{\frac{i}{p_j}})\times p_j^{x+1}$

证毕 $\square$

当 $x=0$  时，$f_n ~=~ \sum\limits_{d|n}\phi_d$，筛 $\sum\limits_{d|n}\phi_d$ 之后，可以发现 $f_n ~=~ n$ 成立，代码如下：

```cpp
#define int long long
const int N = 1e6+3;
int p[N], idx, st[N];
long long f[N];
void gp(int n){
    f[1] = 1;
    for(int i=2; i<=n; ++i){
        if(!st[i]) p[ ++ idx] = i, f[i] = 1ll + 1ll *  (i - 1) ;
        for(int j=1; j<=idx && i * p[j]<=n; ++j){
            st[i * p[j]] = true;

            f[i * p[j]] = i % p[j] ? f[i] * f[p[j]] :
                f[i] + (f[i] - f[i / p[j]]) * p[j] ;

            if(!(i % p[j])) break;
        }
    }
    for(int i=1; i<=10; ++i) cout << f[i] << '\n';
}
```

原式 $\displaystyle \sum_{i=1}^n \operatorname{lcm}(i,n) \quad $ 的化简如下：

$\displaystyle \sum_{i=1}^n[i,~n] = \sum_{i=1}^n \frac{i\times n}{(i,~n)} ~\overset{①}=~ \frac12\times(\sum_{i=1}^{n-1}\frac{i\times n}{(i,~n)} ~+~ \sum_{i=n-1}^{1}\frac{i\times n}{(i,~n)}) ~+~ n $

$\displaystyle ~\overset{②}=~ \frac12\times(\sum_{i=1}^{n-1}\frac{i\times n}{(i,~~n)} ~+~~ \sum_{i=n-1}^{1}\frac{i\times n}{(n-i,~~n)}) ~+~~ n$

$\displaystyle ~\overset{③}=~ \frac{1}{2}\cdot \sum_{i=1}^{n-1}\frac{n^2}{(i,n)}+n  ~~=~~ \frac{1}{2}\cdot \sum_{i=1}^{n}\frac{n^2}{(i,n)}+\frac{n}{2} ~\overset{④}=~ \frac{1}{2}\cdot\sum_{d\mid n}\frac{n^2\cdot\phi_{\frac{n}{d}}}{d}+\frac{n}{2}$

$\displaystyle  ~=~ \frac{1}{2}n\cdot\left(\sum_{d'\mid n}d'\cdot\varphi(d')+1\right)$

$①$：将原式复制一份并且颠倒顺序，然后将 n 一项单独提出

$②$：根据 $\gcd(i,n)=\gcd(n-i,n)$

$③$：两个求和式中分母相同的项可以合并。

$④$：将相同的 $\gcd(i,n)$ 合并在一起计算，故只需要统计 $\gcd(i,n)=d$ 的个数。当 $\gcd(i,n)=d$ 时，$\displaystyle\gcd(\frac{i}{d},\frac{n}{d})=1$，所以 $\gcd(i,n)=d$ 的个数有 $\displaystyle\varphi(\frac{n}{d})$ 个。（即“分组求和”或“分组变换”）

$\sum\limits_{d|n}d\times\phi_d$ 可以在线性时间内筛出，原式的查询复杂度为 $O(1)$，则总复杂度：$O(n ~+~ T)$ 

+ + 3，[P1829 [国家集训队]Crash的数字表格 / JZPTAB - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1829)

求： $\displaystyle \sum_{i=1}^n\sum_{j=1}^m\operatorname{lcm}(i,j)  \pmod{20101009}\qquad (n,m\leqslant 10^7)$

$\displaystyle ~=~ \sum_{i=1}^n\sum_{j=1}^m\frac{i\cdot j}{(i,j)} ~=~ \sum_{i=1}^n\sum_{j=1}^m\sum_{d\mid i,d\mid j,(\frac{i}{d},\frac{j}{d})=1}\frac{i\cdot j}{d}  \\ ~=~ \sum_{d=1}^n d\cdot\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(i,j)=1]\ i\cdot j \\ 记\operatorname{sum}(n,m)=\sum_{i=1}^n\sum_{j=1}^m [\gcd(i,j)=1]\ i\cdot j  \\ ~=~ \sum_{d=1}^n\sum_{d\mid i}^n\sum_{d\mid j}^m\mu(d)\cdot i\cdot j  ~=~ \sum_{d=1}^n\mu(d)\cdot d^2\cdot\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}i\cdot j \\   记g(n,m)=\sum_{i=1}^n\sum_{j=1}^m i\cdot j=\frac{n\cdot(n+1)}{2}\times\frac{m\cdot(m+1)}{2} $

一级结论：

$\displaystyle \operatorname{sum}(n,m)=\sum_{d=1}^n\mu(d)\cdot d^2\cdot g(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor) \\  ans ~=~ \sum_{d=1}^n d\cdot\operatorname{sum}(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)$

复杂度：$O(n)还是O(n^{\frac{2}{3}})？$

```cpp
#define int long long
const int N = 1e7+3, P = 20101009;
int i2, i6;
int inv(int n){ return n==1 ? 1 : (P - P / n) * inv(P % n) % P; }
int s1(int n){ return n * (n + 1) % P * i2 % P; }

int p[N], idx, st[N];
int f[N];
void gp(int n){
    f[1] = 1;
    for(int i=2; i<=n; ++i){
        if(!st[i]) p[ ++ idx] = i, f[i] = -1;
        for(int j=1; p[j]<=n/i; ++j){
            st[i * p[j]] = true;
            f[i * p[j]] = i % p[j] ? f[i] * f[p[j]] : 0;
            if(!(i % p[j])) break;
        }
    }
    for(int i=1; i<=n; ++i) f[i] = (f[i-1] + f[i] * i % P * i % P) % P;
}
int b1(int n, int m){
    int ans = 0;
    for(int lb = 1, ub; lb <= min(n, m); lb = ub + 1){
        ub = min(n / (n / lb), m / (m / lb));
        ans = (ans + (f[ub] - f[lb-1]) * s1(n / lb) % P * s1(m / lb) % P + P) % P;
    }
    return ans;
}
int b2(int n, int m){
    int ans = 0;
    for(int lb = 1, ub; lb <= min(n, m); lb = ub + 1){
        ub = min(n / (n / lb), m / (m / lb));
        ans = (ans + (s1(ub) - s1(lb-1)) * b1(n / lb, m / lb) % P + P) % P;
    }
    return ans;
}
```

二级结论：$\sum\limits_{t=1}^{min\{n,~m\}} S_1(\frac{n}{t},~\frac{m}{t}) \times t\times \sum\limits_{d~|~t}d \times \mu_d $

```cpp
#define int long long
const int N = 1e7+3, P = 20101009;
int i2;
int inv(int n){ return n==1 ? 1 : (P - P / n) * inv(P % n) % P; }
int s1(int n){ return n * (n + 1) % P * i2 % P; }

int p[N], idx, st[N], f[N];
void gp(int n){
    f[1] = 1;
    for(int i=2; i<=n; ++i){
        if(!st[i]) p[ ++ idx] = i, f[i] = (1 - i + P) % P;
        for(int j=1; p[j]<=n/i; ++j){
            st[i * p[j]] = true;
            f[i * p[j]] = i % p[j] ? f[i] * f[p[j]] % P : f[i];
            if(!(i % p[j])) break;
        }
    }
    for(int i=1; i<=n; ++i) f[i] = (f[i-1] + f[i] * i % P) % P;
}
int blk(int n, int m){
    int ans = 0;
    for(int lb = 1, ub; lb <=min(n, m); lb = ub + 1){
        ub = min(n / (n / lb), m / (m / lb));
        ans = (ans + (f[ub] - f[lb - 1]) * s1(n / lb) % P * s1(m / lb) % P + P) % P;
    }
    return ans;
}
```

+ + 4，[#2185. 「SDOI2015」约数个数和 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/2185)

求：$\displaystyle \sum_{i=1}^n\sum_{j=1}^md(i\cdot j)\\ \left(d(n)=\sum_{i \mid n}1\right) n,m,T\leq5\times10^4$

```cpp
#define int long long
const int N = 1e5+3;
int p[N], idx, st[N], num[N], d[N], mu[N];
void gp(int n){
    num[1] = d[1] = mu[1] = 1;
    for(int i=2; i<=n; ++i){
        if(!st[i]) p[ ++ idx] = i, num[i] = 2, d[i] = 2, mu[i] = -1;
        for(int j=1; p[j]<=n/i; ++j){
            st[i * p[j]] = true;
            num[i * p[j]] = i % p[j] ? 2 : num[i] + 1;
            d[i * p[j]] = i % p[j] ? d[i] * d[p[j]] : d[i] / num[i] * (num[i] + 1);
            mu[i * p[j]] = i % p[j] ? mu[i] * mu[p[j]] : 0;
            if(!(i % p[j])) break;
        }
    }
    for(int i=1; i<=n; ++i) d[i] = (d[i-1] + d[i]);
    for(int i=1; i<=n; ++i) mu[i] = (mu[i-1] + mu[i]);
}
int blk(int n, int m){
    int ans = 0;
    for(int lb = 1, ub; lb <= min(n, m); lb = ub + 1){
        ub = min(n / (n / lb), m / (m / lb));
        ans += (mu[ub] - mu[lb-1]) * d[n / lb] * d[m / lb];
    }
    return ans;
}
```

+ 莫比乌斯反演扩展

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-06-18-40-26-image.png)

###### 2，杜教筛

注意点：

1，杜教筛前必须用线性筛预处理

2，线性筛 和 $map$ 的记忆化

3，注意区分普通的分块：

$ans$ 初始化为 $\sum\limits_{i=1}^n \sum\limits_{d|i}f_d\times g_{\frac{i}{d}}$ ；$lb$ 的下限为 $2$ ；$ans ~-=~ ..$ 的形式

4，将 $i2,~i6,~s1(),~s2(),~s3()$ 预处理出来，求和函数 $s$  务必先对 $n$  取模（因为杜教筛面对的是大数据，非常容易溢出）

5，杜教筛的使用范围：一般可以筛 $\sum\limits_{i=1}^n i^k \times \phi_i$，$\sum\limits_{i=1}^n i^k \times \mu_i$，$\sum\limits_{i=1}^n i^k \times \phi_i \times g_{\frac{n}{i}}$；可以1秒内筛 $1e9$ 的数据

+ ”饭前甜点“

$\begin{cases} \epsilon~*~1=\epsilon \\ 1~*~1=d \\ id~*~1=\sigma \\ \mu~*~1=\epsilon \\ \phi~*~1=id \\ \phi~*~1~*~1=\sigma \\ id~*~\mu=\phi \end{cases}$

+ 杜教筛（复杂度$O(N^{\frac{2}{3}} \to N^{\frac{3}{4}})$）

（$一般线性筛筛至5e6能获取最大效率$）

杜教筛被用来处理数论函数的前缀和问题。对于求解一个前缀和，杜教筛可以在低于线性时间的复杂度内求解

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-06-20-31-26-image.png)

$\displaystyle\sum_{i=1}^{n}\sum_{d \mid i}g(d)f\left(\frac{i}{d}\right)=\sum_{i=1}^{n}g(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)\\ \iff \sum_{i=1}^{n}(f\ast g)(i)=\sum_{i=1}^{n}g(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)$

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-06-20-32-01-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-06-20-32-09-image.png)

###### 3，Powerful Number 筛

+ 涉及知识：线性筛，（杜教筛(可能用到)），枚举质数构造 $powerfulnumber$

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-06-23-16-35-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-06-23-16-41-image.png)

+ Powerful Number

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-06-23-17-12-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-06-23-17-17-image.png)

+ **PN 筛**

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-10-31-41-image.png)

具体步骤如下：

+ + 若函数给定 $f_{p^{j}}$ 的计算公式，并可以保证 $f_1 = 1$ ，$f_{a\times b} = f_a \times f_b~~[(a,~b) ~=~ 1]$，则可以考虑 $pn筛$

+ + 构造函数 $g$ 满足 $g_p = f_p$ （ $g$ 的前缀和 $gs$ 可以 杜教筛 或 $O(1)$ 求）

+ + 构造函数 $h$ 满足 $h ~=~ f/g $ （狄利克雷卷积除法），即 $f ~=~ g * h$，而 $h_1 = 1, f_p = g_1\times h_p ~+~ g_p\times h_1 = h_p ~+~ g_p \implies h_p=0，又 h是积性函数 \\ \implies h 仅在 pn 处可能非零 \\ （证：\displaystyle f_n ~~=~~ f_{\prod\limits_{i=1}^k p_i^{a_i}} ~= \prod_{i=1}^k f_{p_i^{a_i}}, 仅当 a_i \ge 2时 f_n\ne 0，得证）   $

+ + **重要公式1**： $\displaystyle f = h * g \implies fs_n ~~=~~ \sum\limits_{x=1,~~x~~is~PN}^n h_x\times gs_{\lfloor\frac{n}{x}\rfloor} $ 

+ + 杜教筛 或 直接计算 $gs$ 
  
  + 用 $dfs$ 构造 $pn$ （代码中$pn ~=~ x\times p_i^j = nx,~h_{pn} ~=~ h_{x\times p_i^j} ~=~ h_x\times h_{p_i^j} ~=~ h\times h_{p_i^j} $，即 $h_{p_i^j}需要公式推导（关于f_{p_i^j}的函数）或暴力求$）
  
  + **重要公式2**：$\displaystyle f ~=~ h * g \implies f_{p^j} ~=~ \sum_{k=0}^j h_{p^{j-k}}\times g_{p^{k}} \implies h_{p^j} ~=~ f_{p^j} - \sum_{k=1}^j h_{p^{j-k}}\times g_{p^k} $

复杂度分析：

① $1..n$ 内的素数有 $O(\frac{\sqrt{N}}{logN})$ 个，每个素数的指数c有 $O(logN)$ 个，计算 $h_{p^j}$ 需要循环 $O(logN)$ 次，该部分复杂度为 $O(\sqrt{N}\times logN)$

② 搜索 $gs$ 的部分：$1..n$ 内的 $pn$ 有 $O(\sqrt n)$ 个，若 $gs$ 能 $O(1)$ 求 $\implies O(\sqrt n)$ ；

$gs$ 用 杜教筛求 $\implies O(n^{\frac{2}{3}}) $

模板题：[Problem - F - Codeforces - Flipped Factorization](https://codeforces.com/gym/103306/problem/F)（$n=1e14$）

题意：$\displaystyle f_n ~=~ f_{\prod\limits_{i=1}^k p_i^{a_i}} ~\overset{①}=~ \prod_{i=1}^k f_{p_i^{a_i}} ~=~ \prod_{i=1}^k {a_i}^{p_i}，求\sum\limits_{i=1}^n f_i \\ \implies f_{{p_i}^j} ~=~    j^{p_i} \\ 1)~~ j=1时，f_{p_i} = 1，故 设 g = 1，则gs = id  \\ 2)~~ 推导h_{p^j}： f_{p^j} ~~=~~ \sum_{k=0}^j h_{p^{j-k}}\times g_{p^{k}} ~=~  \sum_{k=0}^j h_{p^{j-k}} \implies f_{p^j} - f_{p^{j-1}} ~=~ h_{p^j} \\ ①积性函数的有关性质   $

```cpp
int n, ans;
void dfs(int x, int h, int pos){
    // 累计贡献 
    ans = (ans + h * (n / x % P) % P) % P;
    for(int i=pos; i<=idx; ++i){
        // 剪枝 
        if(p[i] * p[i] > n / x) return ;
        int nx = x * p[i];
        for(int j=2; nx <= n / p[i]; ++j){
            nx *= p[i];
            // 计算 h(nx) = h(x * pi^j) = h(x) * h(pi^j)，可以直接推 h(pi^j)，也可以直接算 
            // tips: nx 就是一个 powerful number 
            int nh = h * (fp(j, p[i]) - fp(j - 1, p[i]) + P) % P;
            dfs(nx, nh, i + 1);
        }
    }
}
```

+ 例题：

+ + [P5325 【模板】Min_25筛 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5325)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-11-10-24-53-image.png)

（线性筛 + 杜教筛 + pn筛）（① 令 $g=id*\phi$，用杜教筛求 $gs$ ；② 可以推出： $h_{p^j ~=~ (p-1)\times(j-1)\times p^j}$ ，代码中 $p^j = nx / x$）

```cpp
#include<iostream>
#include<unordered_map>
using namespace std;

#define int long long
const int N = 5e6+3, P = 1e9+7;
int i2, i6;
int inv(int n){ return n == 1 ? 1 : (P - P / n) * inv(P % n) % P; }
int s1(int n){ n %= P; return n * (n + 1) % P * i2 % P; }
int s2(int n){ n %= P; return n * (n + 1) % P * i6 % P * (2 * n + 1) % P; }

int p[N], idx, st[N], g[N];
void init(int n){
    i2 = inv(2), i6 = inv(6);
    g[1] = 1;
    for(int i=2; i<=n; ++i){
        if(!st[i]) p[ ++ idx] = i, g[i] = i - 1;
        for(int j=1; p[j] <= n/i; ++j){
            st[i * p[j]] = true;
            g[i * p[j]] = i % p[j] ? g[i] * g[p[j]] : g[i] * p[j];
            if(!(i % p[j])) break;
        }
    }
    for(int i=1; i<=n; ++i) g[i] = (g[i-1] + g[i] * i % P) % P;
}

unordered_map<int, int> GS;
int gs(int n){
    if(n < N) return g[n];
    if(GS[n]) return GS[n];

    int ans = s2(n);
    for(int lb = 2, ub; lb <= n; lb = ub + 1){
        ub = n / (n / lb);
        ans -= (s1(ub) - s1(lb - 1)) * gs(n / lb) % P;
        ans = (ans % P + P) % P;
    }

    return GS[n] = ans;
}
// 公式推 h(p^j)
int n, ans;
void dfs(int x, int h, int pos){
    ans = (ans + h % P * gs(n / x) % P) % P;
    for(int i=pos; i<=idx; ++ i){
        if(x > n / p[i] / p[i]) return ;
        int nx = x * p[i];
        for(int j=2; p[i] * nx <= n; ++j){
            nx *= p[i];
            int nh = h % P * (j - 1) % P * (p[i] - 1) % 
            P * (nx / x) % P;
            dfs(nx, nh, i + 1);
        }
    }
}
// 暴力推 h(p^j)
int n, ans;
int hp[N][66];
void dfs(__int128 x, __int128 h, int pos){
    ans = (ans + h % P * gs(n / x) % P + P) % P;
    for(int i=pos; i<=idx; ++ i){
        if(x > n / p[i] / p[i]) return ;
        int nx = x * p[i];
        for(int j=2; p[i] * nx <= n; ++j){
            nx *= p[i];
            if(!hp[i][j]){
                int hh = (nx / x) * (nx / x - 1) % P;
                int g = p[i] * (p[i] - 1) % P, t = p[i] * p[i] % P;
                for(int k=1; k<=j; ++k){
                    hh = (hh - hp[i][j-k] * g % P) % P;
                    if(hh < 0) hh += P;
                    g = g * t % P;
                }
                hp[i][j] = hh;
            }

            dfs(nx, h * hp[i][j] % P, i + 1);
        }
    }
}

signed main(){
    init(N - 1);
    cin >> n;

    ans = 0;
    dfs(1, 1, 1);
    cout << ans << '\n';
}
```

+ + [#6053. 简单的函数 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/6053)

+ + [PE708 Twos are all you need](https://projecteuler.net/problem=708)

+ + - [PE639 Summing a multiplicative function](https://projecteuler.net/problem=639)

+ + - [PE484 Arithmetic Derivative](https://projecteuler.net/problem=484)

###### 4，min_25筛

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-11-12-08-41-image.png)
