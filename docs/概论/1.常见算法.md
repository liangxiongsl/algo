
###  ###

### 1.前缀和 ###

前缀和是一种预处理方式，可以应用于 {==多次 静态 快速查询 (O(1)) 区间和==}

!!! tip
	- 数组前缀变换后 {==不支持修改==}

!!! note
	c++标准库 `<numeric>` 是实现了前缀和 `std::partial_sum(bg, ed, <输出迭代器>)`

!!! 一维前缀和
> 给定一维数组 a[ ]，令 s[ ] 为前缀和
>
> $s_i = \sum\limits_{j=1}^{i} a_i$  &  $i=2..n$
> 
> 1.	预处理
> 		
> 		显然 $s_i = s_{i-1} + a_i$
> 		
> 		```
> 		// 1. 覆盖原有数组
> 		for i=1..n
> 			 a[i] += a[i-1];
> 		
> 		// 2. 独立存储 前缀和数组
> 		for i=1..n
> 			s[i] = s[i-1] + a[i];
> 		```
> 
> 2.	查询
> 
> 区间 [l, r] 以内的和 $\sum\limits_{i=l}^r s_i = s_r - s_{l-1}$

!!! 二维前缀和
> 给定二维数组 a[ ][ ]，令 s[ ][ ] 为前缀和  （$a_{0,*} = a_{*, 0} = 0$）
> 
> $s_{i, j} = \sum\limits_{k=1}^{i}\sum\limits_{l=1}^{j} a_{k, l}$   &   $i=1..n, j=1..m$
> 
> 1.	预处理
> 		
> 		根据容斥原理 $S_{i, j} = a_{i, j} + S_{i-1, j} + S_{i, j-1} - S_{i-1, j-1}$
> 
> 2.	查询
> 
> 		两点 $(x_0, y_0), (x_1, y_1)$ （$x_0\le x_1, y_0\le y_1$）之内的和
> 		
> 		$\sum\limits_{i=x_0}^{x_1}\sum\limits_{j=y_0}^{y_1} a_{i, j} = s_{x_1, y_1} - s_{x_0-1, y_1} - s_{x_1, y_0-1} + s_{x_0-1, y_0-1}$

!!! 例题
	- [bool矩阵中寻找最大的只含true的子矩阵](https://www.luogu.com.cn/problem/P1387)

!!! 高维前缀和
> 传统前缀和复杂度： $O(n^k \cdot 2^k)$
> 
> 枚举每一维，分别只对当前维求前缀，将得到 k 维的前缀和 ，时间复杂度优化至 $O(n^k \cdot k)$


### 2.差分 ###

差分 可以理解为 前缀和 的逆运算，可以应用于 {==多次 快速修改(加 / 减) (O(1)) 区间取值==}

!!! tip
	- 数组前缀变换后 {==不支持区间查询==}

!!! 一维差分
$b_i = a_{i} - a_{i-1}$


s