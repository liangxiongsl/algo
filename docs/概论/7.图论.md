
[概念](/理论/7.图论)

!!! note
	- 换根技巧：树上某个节点 x 构成的树的深度（即离 x 最远的结点与 x 之间的距离）为 $\max\{d1_x, d2_x\}$ （$d1,d2$ 分别为 x 到树的直径上的两个端点 p，q 的距离）

- 删边 -> 重儿子变化，树上前缀和变化
- 重儿子


###  ###

!!! note "树的存储"
	1. 只记录父节点：`parent[N]` 仅用于记录父节点，`parent[i]` 表示 i 的父节点
		- 应用：自底向上的递推
	2. 邻接表：`vector<T<node>>`：均可应用于自顶向下的遍历
		- `T = vector`：相较以下两者，遍历速度更快
		- `T = set`：支持**删点，删边**
		- `T = priority_queue`：支持删除优先级最高的儿子结点
		- 注1：支持以 无向图 或 有向图 的形式存储（前者需要两倍的空间）
		- 注2：对于有根树，区分结点的上下关系有多种，如：`parent[N]` 数组；遍历时开 `st[N]` 记录临结点是否已访问，未访问的就是子结点；遍历时判断邻结点是否为父节点，反之为儿子结点
	3. 左孩子右兄弟：`child[N]` 和 `sib[N]` 分别记录结点 i 的第一个子结点 和 下一个兄弟结点？？
		- 子结点遍历方式：`for(int i=child[x]; i!=EMPTY_NODE; i=sib[i])`
	4. 存储二叉树：`paretn[N]` 和 `child[N][2]`


!!! note "树的遍历"
	1. 无根树：
		```cpp
		// dfs(root, EMPTY_NODE)
		void dfs(int x, int fa){
			for(int y : e[x]){
				if(y == f) continue;
				dfs(y, x);
			}
		}
		```
	2. 有根树：

###  ###



