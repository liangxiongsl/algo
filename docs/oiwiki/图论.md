##### 1，图论概念（待补）

**图论 (Graph theory)** 是数学的一个分支，图是图论的主要研究对象。**图 (Graph)** 是由若干给定的顶点及连接两顶点的边所构成的图形，这种图形通常用来描述某些事物之间的某种特定关系。顶点用于代表事物，连接两顶点的边则用于表示两个事物间具有这种关系。

###### 1，图

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-01-15-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-01-46-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-01-57-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-02-04-image.png)

+ + 无向图、有向图、混合图；赋权图、正权图

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-03-02-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-06-15-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-07-18-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-07-48-image.png)

+ + 阶

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-09-37-image.png)

###### 2，相邻、邻域( $neighborhood$ )

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-15-43-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-16-15-image.png)

###### 3，度数

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-30-10-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-30-43-image.png)

+ + 握手定理/图论基本定理  及其 推论

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-30-55-image.png)

+ + 孤立点、叶节点/悬挂点、偶点、奇点、支配点

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-39-42-image.png)

+ + 最小度 $\delta_G$、最大度 $\Delta_G$

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-46-25-image.png)

+ + 出度 $d^+_v$ 、入度 $d^-_v$ 

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-47-43-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-47-52-image.png)

+ + k-正则图

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-55-41-image.png)

+ + 可图化、可简单图化

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-11-55-58-image.png)

###### 4，简单图、多重图

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-12-11-06-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-12-28-11-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-12-29-32-image.png)

###### 5，途径 $walk$、迹 $trail$、路径 $path$、回路 $circuit$、环/圈 $cycle/simple~circuits$

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-12-42-06-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-12-45-11-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-12-45-18-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-14-21-39-image.png)

###### 6，子图

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-14-30-23-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-14-30-32-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-15-12-59-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-15-13-17-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-15-13-23-image.png)

###### 7，

##### 2，存储

+ 1，直接存边

+ + 空间：$O(m)$

+ + 查询边：$O(m)$

+ + 遍历某点的出边：$O(m)$

+ + 遍历图：$O(n\times m)$

```cpp
#include<bits/stdc++.h>
using namespace std;

int n, m;
// 边属性 
struct edge{ int u, v, w; };
vector<edge> e;
// 点属性 
vector<bool> st;

bool find(int u, int v){
    for(int i=1; i<=m; ++i){
        if(e[i].u == u && e[i].v == v) return true;
    }
    return false;
}


void dfs(int u){
    if(st[u]) return ;
    st[u] = true;

    for(int i=1; i<=m; ++i){
        if(e[i].u != u) continue;
        dfs(e[i].v);
    }
}


signed main(){
    cin >> n >> m;

    e.resize(m + 1);
    st.resize(n + 1, false);

    for(int i=1; i<=m; ++i) cin >> e[i].u >> e[i].v;
    
}
```

分析：
1，直接存边的遍历效率低下，一般**不用于遍历图**

2，用于 Kruskal，对边按边权排序

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-14-45-57-image.png)

+ 2，邻接矩阵

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-14-48-55-image.png)

+ + 空间：$O(n^2)$

+ + 查询边：$O(1)$

+ + 遍历某点的出边：$O(n)$

+ + 遍历图：$O(n^2)$

```cpp
#include<bits/stdc++.h>
using namespace std;

int n, m;
vector<bool> st;
vector<vector<bool> > g;

bool find(int u, int v){ return g[u][v]; }

void dfs(int u){
    if(st[u]) return ;
    st[u] = true;

    for(int v=1; v<=n; ++v){
        if(!g[u][v]) continue;
        dfs(v);
    }
}

signed main(){
    cin >> n >> m;

    g.resize(n + 1, vector<bool>(n + 1, false));
    st.resize(n + 1, false);

    for(int i=1; i<=m; ++i){
        int u, v;
        cin >> u >> v;
        g[u][v] = true;
    }

}
```

分析：
1，邻接矩阵只适用于无重边（或可忽略重边）的情况

2，查询边高效

3，只适用于稠密图（非常少用）

+ 3，**邻接表**

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-15-04-00-image.png)

（利用2维的动态数组存边的信息）

+ + 空间：$O(m)$

+ + 查询边：$O(log(d^+_{u}))$ （可以事先对该点的出边排序， 然后再二分查询）

+ + 遍历出边：$O(d^+_{u})$

+ + 遍历图：$O(n+m)$

```cpp
#include<bits/stdc++.h>
using namespace std;

int n, m;
vector<bool> st;
vector<vector<int> > g;

bool find(int u, int v){
    for(int i=0; i<g[u].size(); ++i){
        if(g[u][i] == v) return true;
    }
    return false;
}

void dfs(int u){
    if(st[u]) return ;
    st[u] = true;

    for(int i=0; i<g[u].size(); ++i){
        dfs(g[u][i]);
    }
}

signed main(){
    cin >> n >> m;

    st.resize(n + 1, false);
    g.resize(n + 1);

    for(int i=1; i<=m; ++i){
        int u, v;
        cin >> u >> v;
        g[u].push_back(v);
    }
}
```

**加强版**：支持动态 **删边** 或 **删点** 的邻接表

1）删边（无向边或有向边）：如果空间不允许，则用 $set$ 牺牲一点时间来维护出边信息，否则用哈希

（如果边上只用存出点的信息，就不需要重载运算符 $<$ 了，否则（需要用到边权信息等）就需要重载）

2）删点：哈希即可

```cpp
const int N = 1e5+3;

int n, m;
int st[N];
struct edge{
    int v, w;
    bool operator<(const edge&t)const{ return v<t.v; }
};
vector<set<edge>> e;

void add(int u, int v, int w){
    e[u].insert({v, w});
}

void erase(int u, int v){
    e[u].erase({v, 0}), e[v].erase({u, 0});
//  哈希方法也可以 
//    st[u][v] = st[v][u] = false;
}
void erase(int u){
    st[u] = false;
}
```

分析：

1，存各种图都很适合，除非有特殊需求（如需要快速查询一条边是否存在，且点数较少，可以使用邻接矩阵）

2，尤其适用于需要**对一个点的所有出边进行排序**的场合

+ 4，**链式前向星**

本质上是用链表实现的邻接表

（链表存边的信息）

+ + 空间：$O(m)$

+ + 查询边：$O(d^+_u)$

+ + 遍历某点的出边：$O(d^+_u)$

+ + 遍历图：$O(n+m)$

```cpp
#include<bits/stdc++.h>
using namespace std;

// 这里的 n 的作用象征性的是告诉你有多少个点，很多操作都不需要用到 n
int n, m;
// 点属性 
vector<bool> st;
vector<int> h;
// 边属性 
struct edge{ int ne, v; };
vector<edge> e;

void add(int u, int v){
    e.push_back({h[u], v});
    h[u] = e.size() - 1;
}

bool find(int u, int v){
    for(int i=h[u]; i; i=e[i].ne){
        if(e[i].v == v) return true;
    }
    return false;
}

void dfs(int u){
    if(st[u]) return ;
    st[u] = true;

    for(int i=h[u]; i; i=e[i].ne){
        dfs(e[i].v);
    }
}

signed main(){
    cin >> n >> m;

    st.resize(n + 1, false);
    h.resize(n + 1, 0);

    for(int i=1; i<=m; ++i){
        int u, v;
        cin >> u >> v;
        add(u, v);
    }
}
```

分析：
1，存各种图都很适合，但不能快速查询一条边是否存在，也不能方便地对一个点的出边进行排序

2，优点是边是带编号的，有时会非常有用，而且如果 `cnt` 的初始值为奇数，存双向边时 `i ^ 1` 即是 `i` 的反边（常用于 [网络流](https://oi-wiki.org/graph/flow/)）

##### 3，DFS（图论）

该算法讲解时常常与 BFS 并列，但两者除了都能遍历图的连通块以外，用途完全不同，很少有能混用两种算法的情况

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-15-49-40-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-15-57-58-image.png)

+ $dfs$ 序列

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-16-13-53-image.png)

+ 括号序列

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-16-14-15-image.png)

+ 一般图上的 $dfs$

对于非连通图，只能访问到起点所在的连通分量。

对于连通图，DFS 序列通常不唯一。

（树的 DFS 序列也是不唯一的）

在 DFS 过程中，通过记录每个节点从哪个点访问而来，可以建立一个树结构，称为 DFS 树。DFS 树是原图的一个**生成树**

[DFS 树](https://oi-wiki.org/graph/scc/#dfs) 有很多性质，比如可以用来求 [强连通分量](https://oi-wiki.org/graph/scc/)

```cpp
void dfs(int u){
    if(st[u]) return ;
    st[u] = true;

//    打印 dfs序列 
//    cout << u << ' ';

//    打印括号序列 
//    cout << '(';
    for(int i=h[u]; i; i=e[i].ne){
        dfs(e[i].v);
    }
//    cout << ')';
}
```

##### 4，BFS（图论）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-16-17-26-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-16-19-05-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-16-19-17-image.png)

```cpp
int d[N], p[N];
queue<int> q;
void bfs(int u){
    while(!q.empty()) q.pop();

    q.push(u);
    st[u] = true, d[u] = 0, p[u] = -1;
    while(q.size()){
        u = q.front(), q.pop();
        for(int i=h[u]; i; i=e[i].ne){
            int v = e[i].v;
            if(st[v]) continue;
            q.push(v);
            st[v] = true, d[v] = d[u] + 1, p[v] = u;
        }
    }
}

void restore(int x){
    vector<int> res;
    for(int v=x; ~v; v=p[v]) res.push_back(v);
    reverse(res.begin(), res.end());
    for(int i=0; i<res.size(); ++i) cout << res[i];
    cout << '\n';
}
```

+ 1，$open-closed$ 表

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-16-36-33-image.png)

+ 2，在树/图上 BFS

+ + BFS 序列

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-16-38-25-image.png)

+ + 一般图上的 BFS

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-16-40-44-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-16-40-53-image.png)

+ 3，应用

+ 

+ 4，**双端队列 BFS**（$0-1~BFS$）

+ + 使用范围

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-21-25-55-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-21-26-09-image.png)

（这个例子不太好理解？）

+ + 伪代码

一般情况下，我们把**没有权值的边扩展到的点放到队首**，**有权值的边扩展到的点放到队尾**。这样即可保证像普通 BFS 一样整个队列**队首到队尾**权值**单调不下降**

```cpp
while (队列不为空) {
  int u = 队首;
  弹出队首;
  for (枚举 u 的邻居) {
    更新数据
    if (...)
      添加到队首;
    else
      添加到队尾;
  }
}
```

[Problem - 173B - Codeforces](https://codeforces.com/problemset/problem/173/B)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-12-21-30-48-image.png)

（这道题的正解不是 $0-1BFS$，但也可以做，是挺好的模板题！）

（basilisk）

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e3+3;
char g[N][N];
int n, m;

// 边化为点 
int f[N][N][4];
int dx[] = {0, 0, -1, 1}, dy[] = {1, -1, 0, 0};
deque<int> q;
// 入队函数化，提高可读性
void front(int x, int y, int dir, int d){
    if(x < 0 || x >= n || y < 0 || y >= m) return ;
    if(f[x][y][dir] <= d) return ;

    f[x][y][dir] = d;
    q.push_front(dir);
    q.push_front(y);
    q.push_front(x);
}
void back(int x, int y, int dir, int d){
    if(x < 0 || x >= n || y < 0 || y >= m) return ;
    if(f[x][y][dir] <= d) return ;

    f[x][y][dir] = d;
    q.push_back(x);
    q.push_back(y);
    q.push_back(dir);
}
int bfs(){
    memset(f, 0x3f, sizeof f);

    front(0, 0, 0, 0);
    while(q.size()){
        int x = q[0], y = q[1], dir = q[2];
        q.pop_front();
        q.pop_front();
        q.pop_front();

        int d = f[x][y][dir];
        for(int ndir=0; ndir<4; ++ndir){
            if(ndir == dir){
                int nx = x + dx[dir], ny = y + dy[dir];
                front(nx, ny, dir, d);
            }else if(g[x][y] == '#'){
                back(x, y, ndir, d+1);
            }
        }
    }

    return f[n-1][m-1][0]!=0x3f3f3f3f ? f[n-1][m-1][0] : -1;
}

signed main(){
    cin >> n >> m;
    for(int i=0; i<n; ++i) cin >> g[i];

    cout << bfs() << '\n';
}
```

+ 5，**优先队列BFS**

[【NOIP2017】奶酪 - 题目 - Universal Online Judge (uoj.ac)](https://uoj.ac/problem/332)

判断连通性的问题

（其他做法：并查集，最短路，多源$BFS$）

多源BFS：

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long
const int N = 1e3+3;
int n, h, r;
int x[N], y[N], z[N];

queue<int> q;
bool st[N], goal[N];
void push(int u){ q.push(u), st[u] = true; }


signed main(){
    int T;
    cin >> T;
    while(T--){
        while(q.size()) q.pop();
        memset(st, 0, sizeof st);
        memset(goal, 0, sizeof goal);

        cin >> n >> h >> r;

        bool ans = false;
        for(int i=1; i<=n; ++i){
            cin >> x[i] >> y[i] >> z[i];

            if(z[i] <= r) push(i);
            if(z[i] >= h-r) goal[i] = true;
        }

        while(q.size()){
            int u = q.front();
            q.pop();

            if(goal[u]) ans = true;

            for(int v=1; v<=n; ++v){
                if(st[v]) continue;
                // double 会爆精度...
                if(sqrt((long double)pow(x[u]-x[v], 2) + pow(y[u]-y[v], 2) + pow(z[u]-z[v], 2)) > (long double)2.0 * r) continue;
                push(v);
            }
        }
        puts(ans ? "Yes" : "No");
    }
}
```

##### 5，树上问题（待补）

##### 6，最短路

+ 相关概念

路径

最短路

有向图中的最短路、无向图中的最短路

单源最短路、每对结点之间的最短路

+ 性质

对于边权为正的图，任意两个结点之间的最短路，不会经过重复的结点。

对于边权为正的图，任意两个结点之间的最短路，不会经过重复的边。

对于边权为正的图，任意两个结点之间的最短路，任意一条的结点数不会超过 ，边数不会超过 。

+ 记号

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-09-42-50-image.png)

+ 1，$Floyd$ 算法

用来求**任意两个结点之间的最短路**

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-09-45-45-image.png)

（适用于任何图，不管有向无向，边权正负，但是最短路必须存在（不能有个负环））

+ + 实现

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-09-54-44-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-09-55-37-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-09-55-51-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-09-55-58-image.png)

朴素floyd：

```cpp
const int N = 1e2+3;
int g[N][N][N], n;

void floyd(){
    for(int k=1; k<=n; ++k){
        for(int x=1; x<=n; ++x){
            for(int y=1; y<=n; ++y){
                g[k][x][y] = min(g[k-1][x][y], g[k-1][x][k] + g[k-1][k][y]);
            }
        }
    }
}
```

滚动优化：

```cpp
const int N = 4e2+3;
int g[N][N], n;

void floyd(){
    for(int k=1; k<=n; ++k){
        for(int x=1; x<=n; ++x){
            for(int y=1; y<=n; ++y){
                g[x][y] = min(g[x][y], g[x][k] + g[k][y]);
            }
        }
    }
}
```

继续优化：矩阵乘法优化？

+ + **应用**

1，给一个正权无向图，找一个最小权值和的环

首先这一定是一个简单环，想一想这个环是怎么构成的

考虑环上编号最大的结点 u

`f[u-1][x][y]` 和 (u,x), (u,y）共同构成了环。

在 Floyd 的过程中枚举 u，计算这个和的最小值即可，复杂度：$O(n^3)$

2，已知一个有向图中任意两点之间是否有连边，要求判断任意两点是否连通

该问题即是求 **图的传递闭包**

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-10-47-41-image.png)

```cpp
// std::bitset<SIZE> f[SIZE];
for (k = 1; k <= n; k++)
  for (i = 1; i <= n; i++)
    if (f[i][k]) f[i] = f[i] | f[k];
```

+ 2，$Bellman-Ford$ 算法（及其优化：$SPFA$ ）

（以下简称 $BF$）

Bellman-Ford 算法是一种基于松弛（relax）操作的最短路算法，可以求出有**负权**的图的最短路，并可以**对最短路不存在的情况进行判断**

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-10-53-53-image.png)

+ + 流程

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-17-09-49-image.png)

```cpp
const int N = 1e5+3, inf = 0x3f3f3f3f;

int n, m, f[N];
struct edge{ int v, w; };
vector<edge> e[N];

bool bellmanford(int s){
    memset(f, 0x3f, sizeof f);

    bool ans;
    f[s] = 0;
    for(int i=1; i<=n; ++i){
        ans = false;
        // 用 f_u 更新 f_v （遍历边数组）
        for(int u=1; u<=n; ++u){
            if(f[u] == inf) continue;
            for(auto ed : e[u]){
                int v = ed.v, w = ed.w;
                if(f[v] > f[u] + w){
                    f[v] = f[u] + w;
                    ans = true;
                }
            }
        }
        // 无任何一个点的出点可以被松弛 
        if(!ans) break;
    }
    // 第 n 轮循环仍然可以松弛时说明 s 点可以抵达一个负环
    return ans;
}
```

判环的原理？：

若 $\prod\limits_{i\in circuit} w_i \ge 1$ ，

+ + 队列优化：$SFPA$
  
  `Shortest Path Faster Algorithm`

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-14-51-54-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-14-52-03-image.png)

$O(n\times m)$ 但是 $spfa$ 通常跑得飞快（允许出现负环）

```cpp
const int N = 1e5+3, inf = 0x3f3f3f3f;

int n, m, st[N], f[N], cnt[N];
struct edge{ int v, w; };
vector<edge> e[N];

queue<int> q;
bool push(int u, int v, int w){
    if(f[v] > f[u] + w){
        f[v] = f[u] + w;
        cnt[v] = cnt[u] + 1;
        // 最短路经过的边数 不大于 n-1，否则出现负环 
        if(cnt[v] >= n) return false;
        if(!st[v]) q.push(v), st[v] = true;
    }
    return true;
}

bool sqfa(int s){
    memset(f, 0x3f, sizeof f);
//    memset(cnt, 0, sizeof cnt);
//    memset(st, false, sizeof st);

    q.push(s), st[s] = true, f[s] = 0;
    while(q.size()){
        int u = q.front();
        q.pop(), st[u] = false;

        for(auto ed : e[u]){
            if(!push(u, ed.v, ed.w)) return false;
        }
    }
    return true;
}
```

+ + "BF" 的其他优化

除了队列优化（SPFA）之外，Bellman-Ford 还有其他形式的优化，这些优化在部分图上效果明显，但在某些特殊图上，最坏复杂度可能达到指数级

（队列，双端队列，堆，栈。。）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-15-22-53-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-15-23-10-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-15-24-09-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-15-25-59-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-15-26-30-image.png)

[(31 条消息) 如何看待 SPFA 算法已死这种说法？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/292283275/answer/484871888)

+ 3，$Dijkstra$ 算法

（**warning**：仅适用于**非负权**图；$DJ$ 是轻量级算法，除$DJ$ 以外的算法功能强悍，但效率略差）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-15-36-07-image.png)

+ + 流程

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-15-37-22-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-15-37-28-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-15-37-36-image.png)

朴素做法，复杂度：$O(n^2+m)=O(n^2)$

```cpp
const int N = 1e5+3, inf = 0x3f3f3f3f;

int n, m, st[N], f[N];
struct edge{ int v, w; };
vector<edge> e[N];

void dijkstra(int s){
    memset(f, 0x3f, sizeof f);

    f[s] = 0;
    for(int i=1; i<=n; ++i){
        int u = 0, mind = inf;
        for(int j=1; j<=n; ++j){
            if(st[j] || f[j] >= mind) continue;
            u = j;
            mind = f[j];
        }
        // 将 u 放入 集合 S 中 
        st[u] = true;

        // 松弛 u 的出点 
        for(auto ed : e[u]){
            int v = ed.v, w = ed.w;
            f[v] = min(f[v], f[u] + w);
        }
    }
}
```

单调队列优化（不带修改的堆），复杂度：$O(m\log{m})\le O(n^2\log{n^2})$

（点允许多次入堆；）

```cpp
const int N = 1e5+3, inf = 0x3f3f3f3f;

int n, m, st[N], f[N];
struct edge{ int v, w; };
vector<edge> e[N];

struct nd{
    int u, d;
    bool operator>(const nd&t)const{ return d > t.d; }
};
priority_queue<nd, vector<nd>, greater<nd>> q;

void dijkstra(int s){
    memset(f, 0x3f, sizeof f);

    f[s] = 0;
    q.push({s, 0});
    while(q.size()){
        int u = q.top().u;
        q.pop();
        if(st[u]) continue;

        st[u] = true;

        for(auto ed : e[u]){
            int v = ed.v, w = ed.w;
            if(f[v] > f[u] + w){
                f[v] = f[u] + w;
                q.push({f[v], v});
            }
        }
    }
}
```

+ 4，$Johnson$ 算法

和$floyd$ 一样，用于解决无负环图上的任意两点的最短路

（但是很可能没必要讨论，所以不介绍）

[最短路 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/graph/shortest-path/#johnson-%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95)

+ 5，各种算法的比较

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-16-28-45-image.png)

（表中的 Dijkstra 算法在计算复杂度时均用 `priority_queue` 实现）

+ 6，输出方案

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\图论\assets\2022-08-13-16-32-11-image.png)
