```cpp
int ans = 0;
t = 0;
for(int i=1; i<=n; ++i){
    if(!a[i]){
        t = 0;
        continue;
    }
    // 创造非严格升序 
    for(; t && st[t] > a[i]; -- t);
    // 保证 a_i 入栈后，保持严格升序 
    if((!t || t && st[t] < a[i])) ++ans, st[ ++ t] = a[i];
}
```



严格降序 $for(;~t~\&\&~f_{st[t]}\le w;~--t)$

非严格降序 $for(;~~t~~\&\&~~f_{st[t]} < w;~~--t)$

###### A，给定一个数列 $\{a_n\}$，求 $\displaystyle \sum_{i=1}^n(\min_{j>i,~a_j>a_i}\{j\}-i+1)$

（设 $a_{n+1}=inf$）

POJ - 3250

```cpp
#include<iostream>
using namespace std;

const int N = 4e6+3;

int a[N], n;

int st[N], t;

signed main(){
    cin >> n;
    for(int i=1; i<=n; ++i) scanf("%d", &a[i]);

    long long ans = 0;
    t = 0;
    for(int i=1; i<=n; ++i){
        for(; t && st[t] <= a[i]; -- t);
        ans += t;
        st[ ++ t] = a[i];
    }
    cout << ans << '\n';
}
```

```cpp
#include<iostream>
using namespace std;

const int N = 8e4+3;

int a[N], n;

int st[N], t;

signed main(){
    cin >> n;
    for(int i=1; i<=n; ++i) scanf("%d", &a[i]);

    long long ans = 0;
    t = 0;
    for(int i=1; i<=n; ++i){
        for(; t && a[st[t]] <= a[i]; -- t) ans += abs(st[t] - i) - 1, printf(" %d %d %d\n", st[t], i, abs(st[t] - i) - 1);
        st[ ++ t] = i;
    }
    for(; t; --t) ans += n - st[t];

    cout << ans << '\n';
}
```

###### B，给定 $\{a_n\},~\{b_n\}$，其中 $a_i$ 对两侧最近且 值大于 $a_i$ 的位置 $j$ 上的贡献是 $b_i$，求每个位置上所得贡献值的最大值

P1901

```cpp

```

###### C，滑动窗口最大值+最小值

[Sliding Window - POJ 2823 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/POJ-2823)

POJ2823

```cpp
#include<iostream>
using namespace std;

const int N = 1e6+3;

int a[N], n;

int st[N], s, t;

signed main(){
    int k;
    cin >> n >> k;
    for(int i=1; i<=n; ++i) scanf("%d", &a[i]);

    s = 1, t = 0;
    for(int i=1; i<k; ++i){
        for(; s<=t && a[st[t]] >= a[i]; --t);
        st[ ++ t] = i;
    }
    for(int i=k; i<=n; ++i){
        for(; s<=t && a[st[t]] >= a[i]; --t);
        st[ ++ t] = i;
        for(; st[s] <= i-k; ++s);
        printf("%d ", a[st[s]]);
    }
    puts("");

    s = 1, t = 0;
    for(int i=1; i<k; ++i){
        for(; s<=t && a[st[t]] <= a[i]; --t);
        st[ ++ t] = i;    
    }
    for(int i=k; i<=n; ++i){
        for(; s<=t && a[st[t]] <= a[i]; --t);
        st[ ++ t] = i;
        for(; st[s] <= i-k; ++s);
        printf("%d ", a[st[s]]);
    }
    puts("");
}
```

###### D，

[Flowerpot S - 洛谷 P2698 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/%E6%B4%9B%E8%B0%B7-P2698)

P2698

```cpp
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 1e5+3;

int n, d;
struct nd{
    int x, y;
    bool operator<(nd t){ return x<t.x; }
}a[N];

int st[N], s, t;
int st1[N], s1, t1;

signed main(){
    cin >> n >> d;
    for(int i=1; i<=n; ++i) scanf("%d%d", &a[i].x, &a[i].y);
    sort(a+1, a+n+1);

    int ans = 2e9, L = 1;
    s = 1, t = 0;
    s1 = 1, t1 = 0;
    for(int i=1; i<=n; ++i){
        for(; s<=t && a[st[t]].y < a[i].y; -- t);
        st[ ++ t] = i;
        for(; s1<=t1 && a[st1[t1]].y > a[i].y; -- t1);
        st1[ ++ t1] = i;

        while(L <= i && a[st[s]].y - a[st1[s1]].y >= d){
            ans = min(ans, a[i].x - a[L].x);
            ++ L;
            for(; s<=t && st[s] < L; ++s);
            for(; s1<=t1 && st1[s1] < L; ++s1);
        }
    }
    if(ans < 2e9) cout << ans << '\n';
    else puts("-1");
}
```
