###### 1，字符串简介

字符串，就是由字符连接而成的序列。

常见的字符串问题包括**字符串匹配**问题、**子串**相关问题、**前缀/后缀**相关问题、**回文串**相关问题、**子序列**相关问题等。

+ 字符集

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-08-30-26-image.png)

（**全序关系**：集合$A$ 上的 满足关系 $R$上 $<x,~y>$ ，$<y,~x>$ 必有其一 的**偏序关系**；

[知乎Gjjhgfrrgugv2020的回答](https://www.zhihu.com/question/36758436)）

+ 字符串

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-08-32-10-image.png)

+ 子串

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-08-33-38-image.png)

+ 子序列

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-08-33-57-image.png)

+ 后缀

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-08-36-18-image.png)

+ 前缀

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-08-37-07-image.png)

+ 字典序

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-08-38-06-image.png)

+ 回文串

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-08-38-24-image.png)

+ 字符串的存储

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-08-39-37-image.png)

###### 2，标准库

+ c标准库
  
  `char[]`/`const char*`

+ + 读写：scanf("%s", s)、printf("%s", s)、sscanf(const char *__source, const char *__format, ...)、sprintf(char *__stream, const char *__format, ...)

+ + 常规：
  
  + strlen(const char *str) 取长度
  
  + strcmp(const char *str1, const char *str2) 比较
  
  + strcpy(char *str, const char *src)、strncpy(char *str, const char *src, int cnt)    赋值
  
  + strcat(char *str1, const char *str2) 合并

+ + 查询：
  
  + strstr(char *str1, const char *str2) 若 `str2` 是 `str1` 的子串，则返回 `str2` 在 `str1` 的首次出现的地址；如果 `str2` 不是 `str1` 的子串，则返回 `NULL`
  
  + `strchr(const char *str, int c)`：找到在字符串 `str` 中第一次出现字符 `c` 的位置，并返回这个位置的地址。如果未找到该字符则返回 `NULL`
  
  + `strrchr(const char *str, char c)`：找到在字符串 `str` 中最后一次出现字符 `c` 的位置，并返回这个位置的地址。如果未找到该字符则返回 `NULL`。

ref：

[printf, fprintf, sprintf, snprintf, printf_s, fprintf_s, sprintf_s, snprintf_s - cppreference.com](https://zh.cppreference.com/w/c/io/fprintf)

[scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s - cppreference.com](https://zh.cppreference.com/w/c/io/fscanf)

[空终止字节字符串 - cppreference.com](https://zh.cppreference.com/w/c/string/byte)

+ c++标准库

`std::string`

- 重载了赋值运算符 `+`，当 `+` 两边是 `string/char/char[]/const char*` 类型时，可以将这两个变量连接，返回连接后的字符串（`string`）。
- 赋值运算符 `=` 右侧可以是 `const string/string/const char*/char*`。
- 访问运算符 `[cur]` 返回 `cur` 位置的引用。
- 访问函数 `data()/c_str()` 返回一个 `const char*` 指针，内容与该 `string` 相同。
- 容量函数 `size()` 返回字符串字符个数。
- `find(ch, start = 0)` 查找并返回从 `start` 开始的字符 `ch` 的位置；`rfind(ch)` 从末尾开始，查找并返回第一个找到的字符 `ch` 的位置（皆从 `0` 开始）（如果查找不到，返回 `-1`）。
- `substr(start, len)` 可以从字符串的 `start`（从 `0` 开始）截取一个长度为 `len` 的字符串（缺省 `len` 时代码截取到字符串末尾）。
- `append(s)` 将 `s` 添加到字符串末尾。
- `append(s, pos, n)` 将字符串 `s` 中，从 `pos` 开始的 `n` 个字符连接到当前字符串结尾。
- `replace(pos, n, s)` 删除从 `pos` 开始的 `n` 个字符，然后在 `pos` 处插入串 `s`。
- `erase(pos, n)` 删除从 `pos` 开始的 `n` 个字符。
- `insert(pos, s)` 在 `pos` 位置插入字符串 `s`。
- `std::string` 重载了比较逻辑运算符，复杂度是 $\Theta(N)$ 的。

ref：[std::basic_string - cppreference.com](https://zh.cppreference.com/w/cpp/string/basic_string)

###### 3，字符串匹配

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-10-17-55-image.png)

+ 分类
- + 单串匹配：给定一个模式串和一个待匹配串，找出前者在后者中的所有位置。

- + 多串匹配：给定多个模式串和一个待匹配串，找出这些模式串在后者中的所有位置。
    
    + 出现多个待匹配串时，将它们直接连起来便可作为一个待匹配串处理。
    
    + 可以直接当做单串匹配，但是效率不够高。

- + 其他类型：例如匹配一个串的任意后缀，匹配多个串的任意后缀……
+ 算法

+ + BF (Brute Force) 算法 $O(n)\to O(n\times m)$

```cpp
vector<int> ans;
void match(char *s, char *t){
    int n = strlen(s), m = strlen(t);
    for(int i=0, j; i<=n-m; ++i){
        for(j=0; j<m; ++j) if(s[i + j] != t[j]) break;
        if(j == m) ans.push_back(i);
    }
}
```

+ + 哈希 $hash$

+ + $kmp$

###### 4，字符串哈希（待补）

+ hash思想

Hash 的核心思想在于，将输入映射到一个值域较小、可以方便比较的范围。

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-10-33-33-image.png)

+ + Hash 函数：把字符串映射到整数的函数 $f：string \to int$ 

$f_s ~=~ \sum\limits_{i=1}^{|s|}s_i\times b^{|s|-i} \pmod{p}$ （多项式hash方法；常用）

其他定义：$f_s ~~=~~ \sum\limits_{i=1}^{|s|}s_i\times b^{i} \pmod{p}$  

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-10-35-07-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-10-35-15-image.png)

+ + 哈希碰撞：Hash 函数值一样时原字符串却不一样的现象

+ + 目标：时间复杂度和 Hash 的准确率（或 碰撞概率）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-10-46-07-image.png)

（上面的 $M$ 指的是 $p$）

+ 实现

$f_{s,~-1} = 0 \\ f_{s,~i} ~=~ b\times f_{s,~i-1} + s_i$ （不会推）

```cpp
const int B = 233, P = 1e9+7;
// 单次计算哈希值（复杂度高）
int h(string s){
    int ans = 0;
    for(int i=0; i<s.size(); ++i) ans = (1ll * ans * B + s[i]) % P;
    return ans;
}
```

```cpp
#define int long long
const int B = 233, P = 1e9+7;
int f[100003];
void init(string s){
    f[0] = s[0];
    for(int i=1; i<s.size(); ++i) f[i] = (f[i-1] * B + s[i]) % P;
}
int get(int lb, int ub){
    int ans = 1, a = B, n = ub - lb + 1;
    while(n){
        if(n & 1) ans = ans * a % P;
        a = a * a % P;
        n >>= 1;
    }
    return f[ub] - f[lb-1] * ans % P;
}
int h(string s){
    int ans = 0;
    for(int i=0; i<s.size(); ++i) ans = (1ll * ans * B + s[i]) % P;
    return ans;
}
```

+ + 错误率：若进行 $n$ 次比较，每次错误率 $\frac{1}{p}$，那么总错误率是$1-(1-\frac{1}{p})^n$，在随机数据下，若$p=1e9+7$ ，$n=1e6$，错误率约为$\frac{1}{1000}$ ，并不是能够完全忽略不计的。所以，进行字符串哈希时，经常会对两个大质数分别取模，这样的话哈希函数的值域就能扩大到两者之积，错误率就非常小了

[Problem - 5685 (hdu.edu.cn)](http://acm.hdu.edu.cn/showproblem.php?pid=5685)（哈希函数不同，也可以做类似的预处理）

+ 应用

+ + 字符串匹配

求出模式串的哈希值后，求出文本串每个长度为模式串长度的子串的哈希值，分别与模式串的哈希值比较即可。

+ + 允许 $k$ 次失配的字符串匹配

+ + 最长回文子串

+ + 最长公共子字符串

+ + 确定字符串中不同子字符串的数量

**相关文章：**

[[教程]滚动哈希和8个有趣的问题[编辑] - Codeforces](https://codeforces.com/blog/entry/60445)

[ACM字符串题目总结_weixin_30416497的博客-CSDN博客](https://blog.csdn.net/weixin_30416497/article/details/94963730)

###### 5，字典树trie

字典树，英文名 trie。顾名思义，就是一个像字典一样的树。

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-16-26-00-image.png)

（原图：[trie1.png (793×841) (oi-wiki.org)](https://oi-wiki.org/string/images/trie1.png)）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-16-26-31-image.png)

+ 1，检索字符串

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-16-26-40-image.png)

```cpp
const int N =5e5+3;
struct trie{
//  假设字符集为小写字母
    int idx, ne[N][26];
    int st[N];
    void ins(char *s, int l){
        int p = 0;
        for(int i=0; i<l; ++i){
            int e = s[i] - 'a';
            if(!ne[p][e]) ne[p][e] = ++ idx;
            p = ne[p][e];
        }
        st[p] = true;
    }
    int find(char *s, int l){
        int p = 0;
        for(int i=0; i<l; ++i){
            int e = s[i] - 'a';
            if(!ne[p][e]) return false;
            p = ne[p][e];
        }
        return !st[p] ? false : (st[p]==1 ? st[p] ++ : st[p]);
    }
};
```

+ 2，$ac$ 自动机：trie 是 [AC 自动机](https://oi-wiki.org/string/ac-automaton/) 的一部分。

+ 3，维护异或极值

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-16-36-09-image.png)

[P4551 最长异或路径 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4551)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-22-20-25-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-16-22-26-09-image.png)

问题可以转化为求任一两个结点的“异或深度”（从根到结点的异或和），朴素的复杂度为$O(\binom{n}{2})$，trie+贪心优化后为 $O(N\times log N)$

（好题）

```cpp
#include<iostream>
#include<cstring>
using namespace std;

const int N = 1e5+3, LEN = 32;
struct trie{
    int idx, ne[N * LEN][2];
    void ins(int n){
        int u = 0;
        for(int i=30; ~i; --i){
            int e = n >> i & 1;
            if(!ne[u][e]) ne[u][e] = ++ idx;
            u = ne[u][e];
        }
    }
    int ans;
    void find(int n){
        int ret = 0;
        int u = 0;
        for(int i=30; ~i; --i){
            int e = n >> i & 1;
            if(ne[u][e ^ 1]){
                // e ^ (e ^ 1) = 1
                ret |= 1 << i;
                u = ne[u][e ^ 1];
            }else u = ne[u][e];
        }
        ans = max(ans, ret);
    }
}tr;

struct edge{ int v, ne, w; }e[N<<1];
int idx, n, h[N];
void add(int u, int v, int w){
    e[ ++ idx] = {v, h[u], w}, h[u] = idx;
}

// 求 “边权异或前缀” （从根到每个结点的边权异或和） 
int d[N];
void dfs(int u, int p){
    tr.find(d[u]);
    tr.ins(d[u]);
    for(int i=h[u]; i; i=e[i].ne){
        int v = e[i].v, w = e[i].w;
        if(v == p) continue;    
        d[v] = d[u] ^ w;
        dfs(v, u);
    }
}

int main(){
    cin >> n;
    idx = 0, memset(h, 0, sizeof h);
    for(int i=1; i<n; ++i){
        int u, v, w;
        cin >> u >> v >> w;
        add(u, v, w);
        add(v, u, w);
    }
    dfs(1, 0);

    cout << tr.ans << '\n';
}
```

+ 4，维护异或和

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\字符串\assets\2022-07-17-15-19-15-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\字符串\assets\2022-07-17-15-19-32-image.png)

+ + 插入 & 删除

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\字符串\assets\2022-07-17-15-41-09-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\字符串\assets\2022-07-17-15-41-23-image.png)

+ + 全局加一

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\字符串\assets\2022-07-17-16-24-32-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\字符串\assets\2022-07-17-16-29-32-image.png)

```cpp
const int N = 1e5+3, H = 21;
struct trie{
    int idx, ne[N * (H + 1)][2], w[N * (H + 1)], xorv[N * (H + 1)];
    int mknode(){
        ne[ ++ idx][0] = ne[idx][1] = w[idx] = xorv[idx] = 0;
        return idx;
    }
    int up(int u){
        w[u] = xorv[u] = 0;
        int a = ne[u][0], b = ne[u][1];
        if(a){
            w[u] += w[a];
            xorv[u] ^= xorv[a] << 1;
        }
        if(b){
            w[u] += w[b];
            xorv[u] ^= (xorv[b] << 1) | (w[b] & 1);
        }
//        w[u] 仅保存奇偶性 
//        w[u] &= 1;
    }

// 增删
    void ins(int u, int n, int dp){
        if(!u) u = mknode();
        if(dp == H) return void(++ w[u]);
        ins(ne[u][n & 1], n >> 1, dp + 1);
        up(u);
    }
    int d;
    void del(int u, int n, int dp){
        if(dp == H) return void(-- w[u]);
        del(ne[u][n & 1], n >> 1, dp + 1);
        up(u);
    }
//  全局加一
    void addall(int u){
//      
        if(ne[u][1]) addall(ne[u][1]);
        swap(ne[u][0], ne[u][1]);
        up(u);
    }
}tr;
```

+ 5，01-trie合并

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\字符串\assets\2022-07-17-17-46-01-image.png)

```cpp
int merge(int a, int b){
    if(!a) return b;
    if(!b) return a;

    w[a] += w[b], xorv[a] ^= xorv[b];

    ne[a][0] = merge(ne[a][0], ne[b][0]);
    ne[a][1] = merge(ne[a][1], ne[b][1]);
    return a;
}
```

[P6018 [Ynoi2010] Fusion tree - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P6018)

[P6623 [省选联考 2020 A 卷] 树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P6623)

[Trie 树 基础练习 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/training/5061)

+ 6，可持久化trie树




###### 6，kmp

```cpp
vector<int> pi;
void kmp(string s){
    int n = s.size();
    pi.clear(), pi.resize(n);
    pi[0] = 0;
    for(int i=1; i<n; ++i){
        int j;
        for(j=pi[i-1]; j && s[j]!=s[i]; j=pi[j-1]);
        pi[i] = s[j]==s[i] ? j+1 : j;
    }
}
```

###### 7，z函数

朴素版

```cpp
vector<int> z;
void zf(string s){
    int n = s.size();
    z.clear(), z.resize(n);
    z[0] = 0;
    for(int i=1; i<n; ++i){
        for(; i+z[i]<n && s[z[i]]==s[i+z[i]]; ++ z[i]);
    }
}
```

线性版

```cpp
void ZF(string s){
    cin >> s;
    int n = s.size();
    z.clear(), z.resize(n);
    z[0] = 0;
    for(int i=1, lb=0, ub=0; i<n; ++i){
        if(i<=ub && z[i-lb]<ub-i+1) z[i] = z[i-lb];
        else{
            z[i] = max(0, ub-i+1);
            for(; i+z[i]<=n && s[z[i]]==s[i+z[i]]; ++ z[i]);
        }
        if(ub < i+z[i]-1) lb = i, ub = i+z[i]-1;
    }
}
```

###### 8，AC自动机

用于解决 **多模式匹配**

$ac$ 自动机 $=$  $kmp+trie$

![AC_automation_gif_c.gif](http://oi-wiki.com/string/images/ac-automaton3.gif)

[P3796 【模板】AC 自动机（加强版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3796)

```cpp
const int N = 153*73, M = 153;

string S[M];
int n, tr[N][26], idx, st[N], q[N], s, t, f[N];
void add(string s, int id){
    int u = 0;
    for(int i=0, e; e=s[i]-'a', i<s.size(); ++i, u=tr[u][e]){
        if(!tr[u][e]) tr[u][e] = ++ idx;
    }
    st[u] = id;
}
void ac(){
    s = 1, t = 0;
    for(int i=0; i<26; ++i) if(tr[0][i]) q[ ++ t] = tr[0][i];
    while(s <= t){
        int u = q[s ++ ];
        for(int i=0; i<26; ++i){
            if(tr[u][i]){
                q[ ++ t] = tr[u][i];
                f[tr[u][i]] = tr[f[u]][i];
            }else tr[u][i] = tr[f[u]][i];
        }
    }
}
int tr_ans[N], li_ans[M];
void get(string t){
    for(int i=0, u=0; u=tr[u][t[i]-'a'], i<t.size(); ++i){
        for(int j=u; j; j=f[j]){
            ++ tr_ans[j];
        }
    }
    int ans = 0;
    for(int i=1; i<=idx; ++i){
        if(st[i]){
            ans = max(ans, tr_ans[i]);
            li_ans[st[i]] = tr_ans[i];
        }
    }
    cout << ans << '\n';
    for(int i=1; i<=n; ++i){
        if(li_ans[i] == ans){
            cout << S[i] << '\n';
        }
    }
}
void init(){
    idx = 0, memset(tr, 0, sizeof tr), memset(st, 0, sizeof st);
    memset(f, 0, sizeof f);
    memset(tr_ans, 0, sizeof tr_ans);
    memset(li_ans, 0, sizeof li_ans);
}
```

###### 9，后缀数组sa

（字符串大小比较：

先将两字符串向左对齐，然后对较小的字符串的后几位$(\ge 0)$ 以$ASCII$码 $-\infin$ 填补

1，从左到右找到第一个两字符不同的位置，此处$ASCII$小的一方 数值“更小”

2，找不到不相同的位置，则表明两字符串相等）

+ 约定

字符串下标从 $1$ 开始

涉及两个数组：编号数 $sa[~]$ ，排名数 $rk[~]$

![](D:\Document%20And%20Settings2\lx\Desktop\oiwiki\字符串\assets\2022-09-26-22-12-32-image.png)

（$sa_i$ 表示 谁第 $i$ 小， $rk_i$ 表示 $\mathop{suf}_i$ 第几小；两者均是双射函数）

1）倍增

复杂度：$O(n\log^2{n})$

```cpp

const int N = 1e6+3;

char s[N];
int n;
int sa[N], rk[N<<1], prk[N<<1];

void init(){
	n = strlen(s + 1);
	for(int i=1; i<=n; ++i) sa[i] = i, rk[i] = s[i];
	
	for(int w=1; w<n; w<<=1){
		sort(sa+1, sa+n+1, [w](int a, int b){
			return rk[a] != rk[b] ? rk[a] < rk[b] : rk[a+w] < rk[b+w];
		});
		memcpy(prk, rk, sizeof rk);
		
		for(int i=1, p=0; i<=n; ++i){
			if(prk[sa[i]] == prk[sa[i-1]] && prk[sa[i] + w] == prk[sa[i-1] + w]) rk[sa[i]] = p;
			else rk[sa[i]] = ++ p;
		}
	}
	for(int i=1; i<=n; ++i) cout << sa[i] << ' ';
	cout << '\n';
}


```

2）倍增+基数排序：

复杂度：$O(n\times \log n)$

```cpp

const int N = 1e6+3;

int n;
char s[N];
int sa[N], rk[N<<1], prk[N<<1];
int w[N], sa1[N];
void init(){
	n = strlen(s + 1);
//	for(int i=1; i<=n; ++i) sa[i] = i, rk[i] = s[i];
	
	int m = 127;
	for(int i=1; i<=n; ++i) ++ w[ rk[i]=s[i] ];
	for(int i=1; i<=m; ++i) w[i] += w[i-1];
	for(int i=n; i>=1; --i) sa[w[ rk[i] ]--] = i;
	memcpy(prk+1, rk+1, n * sizeof(int));
	for(int k=0, i=1; i<=n; ++i){
		if(prk[sa[i]] == prk[sa[i-1]]) rk[sa[i]] = k;
		else rk[sa[i]] = ++ k;
	}
	
	m = n;
	for(int p=1; p<n; p<<=1){
		memset(w, 0, sizeof w);
		memcpy(sa1+1, sa+1, n * sizeof(int));
		for(int i=1; i<=n; ++i) ++ w[ rk[sa1[i]+p] ];
		for(int i=1; i<=m; ++i) w[i] += w[i-1];
		for(int i=n; i>=1; --i) sa[w[ rk[sa1[i]+p] ]--] = sa1[i];
		
		memset(w, 0, sizeof w);
		memcpy(sa1+1, sa+1, n * sizeof(int));
		for(int i=1; i<=n; ++i) ++ w[ rk[sa1[i]] ];
		for(int i=1; i<=m; ++i) w[i] += w[i-1];
		for(int i=n; i>=1; --i) sa[w[ rk[sa1[i]] ]--] = sa1[i];
		
		memcpy(prk+1, rk+1, n * sizeof(int));
		for(int k=0, i=1; i<=n; ++i){
			if(prk[sa[i]] == prk[sa[i-1]] && prk[sa[i]+p] == prk[sa[i-1]+p]) rk[sa[i]] = k;
			else rk[sa[i]] = ++ k;
		}
	}
	
	for(int i=1; i<=n; ++i) cout << sa[i] << ' ';
	cout << '\n';
}



```

3）其他线性算法：[诱导排序与 SA-IS 算法](https://riteme.site/blog/2016-6-19/sais.html)；[dc3](https://wenku.baidu.com/view/5b886b1ea76e58fafab00374.html "[2009] 后缀数组——处理字符串的有力工具 by. 罗穗骞")
