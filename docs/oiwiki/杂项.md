###### 1、双指针

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-25-10-20-20-image.png)

+ 维护区间信息
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-25-15-51-44-image.png)
  
  + 1，[713. 乘积小于 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-product-less-than-k/)
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-25-15-52-08-image.png)
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-25-16-12-02-image.png)
  
  ```cpp
  const int N = 1e5+3;
  int n, k;
  int a[N];
  
  int f(){
      long long prod = 1ll, ans = 0;
      // ub 先移动，再更新 ； lb 先更新，再移动 
      for(int lb = 1, ub = 1; ub <= n; ++ ub){
          prod *= a[ub];
  ```
  
          // 寻找 满足题意 与 不满足题意 的中介点 lb_end
          while(lb <= ub && prod >= k) prod /= a[lb ++];
          ans += ub - lb + 1;
      }
      return ans;
  
  }

```
类似题目：区间和不小于k的区间个数（实际上，也可以用容斥，即每次大循环，$ans ~+=~ ub - (ub-lb+1)=lb-1$；当然，画图也是可以的）

```cpp

int f(){
    long long sum = 0, ans = 0;
    for(int lb = 1, ub = 1; ub <= n; ++ ub){
        sum += a[ub];

        while(lb <= ub && sum >= k) sum -= a[lb ++ ];
        ans += lb - 1;
    }
    return ans;
}
```

+ 2，[P3066 [USACO12DEC]Running Away From the Barn G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3066)（双指针+树上差分）
  
  前言：![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-25-16-20-06-image.png)
  
  （天啊 ，不会！！）
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-25-18-17-38-image.png)
  
  神仙的题解：![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-25-18-17-56-image.png)

+ 子序列匹配
  
  + [524. 通过删除字母匹配到字典里最长单词 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting/)
    
    ```cpp
    const int N = 1e3+3;
    int n;
    string s, dict[N];
    
    // priority：长度 higner，字典序 higher
    void solve(){
        string ans_str;
        int ans_len = 0;
    
        sort(dict + 1, dict + n + 1);
    
        for(int i=n; i>=1; -- i){
            int lb = 0;
            for(int ub = 0; ub < s.length(); ++ ub){
                if(s[ub] == dict[i][lb]) ++ lb;
            }
            if(lb == dict[i].length()){
                if(ans_len <= lb){
                    ans_len = lb;
                    ans_str = dict[i];
                }
            }
        }
    //    cout << ans_len << '\n';
        cout << ans_str << '\n';
    }
    ```

+ 利用序列有序性
  
  + [167. 两数之和 II - 输入有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

```cpp
const int N = 1e5+3;
int n, k;
int a[N];

void f(){
    int lb = 1, ub = n;
    while(lb < ub){
        if(a[lb] + a[ub] > k) -- ub;
        else if(a[lb] + a[ub] < k) ++ lb;
        else{
            printf("%d %d\n", lb, ub);
            break;
        }
    }
}
```

+ 单向链表中找环

###### 2，离散化

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\杂项\assets\2022-07-21-19-27-35-image.png)

+ 整数离散

方法1：（支持浮点数，字符串离散）

```cpp
map<int, int > mp;
// idx尽量初始化为0
int idx;
// 动态编号
int get(int x){ return mp[x] ? mp[x] : mp[x] = ++idx; }
```

方法2：

```cpp
const int N = 1e5+3;
int n, num[N];
// 重新编号
void dis(){ sort(num, num + n), n = unique(num, num + n) - num; }
// 查询新编号
int get(int x){ return lower_bound(num, num+n, x) - num; }
```

方法3：

```cpp
vector<int> num;
void dis(){
    sort(num.begin(), num.end());
    num.erase(unique(num.begin(), num.end()), num.end());
}
int get(int x){ 
    return lower_bound(num.begin(), nmu.end(), x) - lower_bound(); 
}
```

（也可以将需要离散化的数据存在数组里，加快查询 $O(\log{n})\to O(1)$）

+ 例题：[P1955 [NOI2015] 程序自动分析 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1955)

（考察并查集 + 离散化）

离散化部分代码：

```cpp
struct Q{
    // 要对 u, v 进行离散，所以先把输入数据存起来离线处理
    int u, v, f;
    // 题目的特殊处理（不是离散化的重点）
    bool operator<(const Q&t){ return f>t.f; }
}q[N];
int n;

int idx, A[N<<1];
void init(){
    idx = 0;
    // 输入需要离散的数据 
    for(int i=0; i<n; ++i) A[ ++ idx] = q[i].u, A[ ++ idx] = q[i].v;
    // 离散化 
    sort(A + 1, A + idx + 1), idx = unique(A + 1, A + idx + 1) - A;
    // 输出离散化的数据 
    for(int i=0; i<n; ++i){
        q[i].u = lower_bound(A + 1, A + idx + 1, q[i].u) - A;
        q[i].v = lower_bound(A + 1, A + idx + 1, q[i].v) - A;
    }
}
```
