###### 1，NTT

```cpp
#include<iostream>
#include<algorithm>
using namespace std;


#define int long long
const int P = (479<<21) + 1;
const int N = (1e6+3)*4;
int fp(int a, int n){
    int ans = 1;
    while(n){
        if(n & 1) ans = ans * a % P;
        a = a * a % P;
        n >>= 1;
    }
    return ans;
}

int rev[N];
void ntt(int y[], int len, int op){
    for(int i=0; i<len; ++i){
        rev[i] = rev[i>>1]>>1 | (i & 1) * (len >> 1);
        if(i < rev[i]) swap(y[i], y[rev[i]]);
    }
    for(int n=2; n<=len; n<<=1){
        int gn = fp(3, (P - 1) / n);
        if(op == -1) gn = fp(gn, P-2);

        for(int j=0; j<len; j+=n){
            int g = 1;
            for(int k=j; k<j+n/2; ++k){
                int u = y[k], v = y[k + n/2] * g % P;
                y[k] = (u + v) % P;
                y[k + n/2] = (u - v + P) % P;
                g = g * gn % P;
            }
        }
    }
    if(~op) return ;
//    reverse(y + 1, y + len);
    int il = fp(len, P-2);
    for(int i=0; i<len; ++i) y[i] = y[i] * il % P;
}

int n, m;
int a[N], b[N];

signed main(){
    cin >> n >> m;
    for(int i=0; i<=n; ++i) cin >> a[i];
    for(int i=0; i<=m; ++i) cin >> b[i];

    int l = 1;
    while(l <= n+m) l <<= 1;

    ntt(a, l, 1);
    ntt(b, l, 1);
    for(int i=0; i<l; ++i) a[i] = a[i] * b[i] % P;
    ntt(a, l, -1);

    for(int i=0; i<=n+m; ++i) cout << a[i] << ' ';
}
```

###### 2，Burnside & pólya

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-03-21-05-05-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-03-22-35-26-image.png)

###### 3，筛法

约数个数

```cpp
const int N = 5e6+3;
bool np[N];
int p[N], idx;
int num[N], d[N];
void pre(int n){
    num[1] = d[1] = 1;
    for(int i = 2; i <= n; ++ i){
        if(!np[i]) p[++ idx] = i, num[i] = 1, d[i] = 2;
        for(int j = 1; p[j] <= n/i; ++ j){
            np[i * p[j]] = true;

            int n = i * p[j];
            num[n] = i % p[j] ? num[i] * num[p[j]] : num[i] + 1; 
            // num[n] = i % p[j] ? 1 : num[i] + 1;
            d[n] = i % p[j] ? d[i] * d[p[j]] : d[i] / num[n] * (num[n] + 1);
            // d[n] = i % p[j] ? d[i] * 2 : d[i] / num[n] * (num[n] + 1); 
            if(!(i % p[j])) break;
        }
    }
    for(int i=1; i<=10; i++) cout << num[i] << ' ' << d[i] << '\n';

}
```

约数和

```cpp
const int N = 5e6+3;
bool np[N];
int p[N], idx;
int g[N], f[N];
void pre(int n){

    g[1] = f[1] = 1;
    for(int i = 2; i <= n; ++ i){
        if(!np[i]) p[++ idx] = i, g[i] = i + 1, f[i] = i + 1;
        for(int j = 1; p[j] <= n/i; ++ j){
            np[i * p[j]] = true; 
            int n = i * p[j];
            g[n] = i % p[j] ? g[i] * g[p[j]] : g[i] * p[j] + 1;
            // g[n] = i % p[j] ? 1 + p[j] : g[i] * p[j] + 1;
            f[n] = i % p[j] ? f[i] * f[p[j]] : f[i] / g[i] * g[n]; 
            if(!(i % p[j])) break;
        }
    }

}
```

###### 4，欧拉

![](D:\Document%20And%20Settings2\lx\Desktop\assets\2022-09-10-23-16-06-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\assets\2022-09-10-23-25-18-image.png)

朴素版 & 优化版

```cpp
int f(int n){
    int ans = n;
    for(int i=2; i<=n/i; ++i){
        if(n % i) continue;
        for(; !(n % i); n /= i);
        ans = ans / i * (i - 1);
    }
    if(n > 1) ans = ans / n * (n - 1);
    return ans;
}
// 线性筛优化
int f(int n){
    int ans = n;
    for(int i=1; i<=idx && p[i]<=n/p[i]; ++i){
        if(n % p[i]) continue;
        for(; !(n % p[i]); n/=p[i]);
        ans = ans / p[i] * (p[i] - 1);
    }
    if(n > 1) ans = ans / n * (n - 1);
    return ans;
}
```

###### 5，类欧几里得

![](D:\Document%20And%20Settings2\lx\Desktop\assets\2022-09-10-23-27-09-image.png)

<img src="file:///D:/Document%20And%20Settings2/lx/Desktop/assets/2022-09-10-23-26-24-image.png" title="" alt="" data-align="inline">

```cpp
#include<iostream>
using namespace std;

#define int long long
const int p = 998244353;
int i2, i6;
inline int inv(int n){ return n==1 ? 1 : (p - p / n) * inv(p % n) % p; }
inline int s0(int n){ return n + 1; }
inline int s1(int n){ return n * (n + 1) % p * i2 % p; }
inline int s2(int n){ return n * (n + 1) % p * (2 * n + 1) % p * i6 % p; }

struct func{
    int f, g, h;
};

func calc(int a, int b, int c, int n){
    int ac = a / c, bc = b / c, D = (a * n + b) / c;

    if(!a) return {bc * s0(n) % p, bc * s1(n) % p, bc * bc % p * s0(n) % p};

    if(a >= c || b >= c){
        func x1 = calc(a % c, b % c, c, n);
        return {
            (ac * s1(n) % p + bc * s0(n) % p + x1.f) % p,
            (ac * s2(n) % p + bc * s1(n) % p + x1.g) % p,
            (ac * ac % p * s2(n) % p + 2 * ac * bc % p * s1(n) % p + bc * bc % p * s0(n) % p + 
            x1.h + 2 * ac * x1.g % p + 2 * bc * x1.f % p) % p
        };
    }
    func x2 = calc(c, c - b - 1, a, D - 1);
    func x = {
        ((D * n - x2.f) % p + p) % p,
        ((D * s1(n) % p - i2 * x2.h % p - i2 * x2.f % p) % p + p) % p,
        ((D * (D + 1) % p * n % p - 2 * x2.g % p - 2 * x2.f % p) % p + p) % p
    };
    x.h = ((x.h - x.f) % p + p) % p;
    return x;
}

signed main(){
    i2 = inv(2), i6 = inv(6);
//    cout << i2 << ' ' << i6 << '\n';

    int T;
    cin >> T;
    while(T--){
        int n, a, b, c;
        cin >> n >> a >> b >> c;
        func x = calc(a, b, c, n);
        cout << x.f << ' ' << x.h << ' ' << x.g << '\n';
    }
    return 0;
}
```

###### 6，欧几里得 & 线性同余

```cpp
int exgcd(int a, int b, int &x, int &y){
    if(!b) return x = 1, y = 0, a;
    int d = exgcd(b, a % b, x, y), x1 = x;
    return x = y, y = x1 - a / b * y, d;
}

int liEu(int a, int b, int n){
    int x, y, d = exgcd(a, b, x, y);
    if(n % d) return -1;
    int nd = n / d, bd = b / d;
    x *= nd;
    return (x % bd + bd) % bd;
}
```

$x_1\le x\le x_2,~y_1\le y\le y_2$，求解的数量

```cpp
int x1, x2, y1, y2;
int liEu(int a, int b, int n){
    if(n < 0) a *= -1, b *= -1, n *= -1;
    if(a < 0) a *= -1, swap(x1, x2), x1 *= -1, x2 *= -1;
    if(b < 0) b *= -1, swap(y1, y2), y1 *= -1, y2 *= -1;

    int l = x2-x1+1, l1 = y2-y1+1;
    if(!a && !b) return !n ? l * l1 : 0;
    if(!a) return !(n % b) && n/b>=y1 && n/b<=y2 ? l : 0;
    if(!b) return !(n % a) && n/a>=x1 && n/a<=x2 ? l1 : 0; 


    int x, y, d = exgcd(a, b, x, y);
    if(n % d) return 0;
    int nd = n / d, bd = b / d, ad = a / d;
    x *= nd, y *= nd;

    int s1 = ceil(1.0*(x1-x)/bd), s2 = floor(1.0*(x2-x)/bd);
    int t1 = ceil(1.0*(y2-y)/-ad), t2 = floor(1.0*(y1-y)/-ad);
    return max(0ll, min(s2, t2) - max(s1, t1) + 1);
}
```

###### 7，中国剩余

```cpp
int excrt(int n, int *a, int *b){
    int A1 = a[1], B1 = b[1];
    for(int i=2; i<=n; ++i){
        int A2 = a[i], B2 = b[i];

        // liEu(a, b, c, x, y)
        int x, y;
        int d = exgcd(B1, B2, x, y), c = A2 - A1, cd = c / d, bd = B2 / d;
        if(c % d) return -1;
        x *= cd, y *= cd;
        // 求解最小正整数解
        x = (x % bd + bd) % bd;

        A1 += B1 * x, B1 *= bd;
    }
    // 不知道要不要模 B1 ？
    return A1;
}
```

###### 8，卢卡斯

```cpp
#define int long long
const int N = 2e5+3;
int P;

int fac[N], ifac[N];
void init(int n){
    fac[0] = ifac[0] = ifac[1] = 1;
    for(int i=1; i<=n; ++i) fac[i] = fac[i-1] * i % P;
    for(int i=2; i<=n; ++i) ifac[i] = (P - P / i) * ifac[P % i] % P;
    for(int i=1; i<=n; ++i) ifac[i] = ifac[i-1] * ifac[i] % P;
}
int c(int a, int b){
    if(a < P) return fac[a] * ifac[a-b] % P *ifac[b] % P;
    return c(a / P, b / P) * c(a % P, b % P) % P;
}
```

```cpp
#define int long long
const int N = 4e4+3, p = 999911659, pb = p - 1;
int k, a[4 + 1], b[4 + 1];
void breakdown(int n){
    // 构造 b[] 
    for(int i=2; i<=n; ++i){
        if(n % i) continue;
        while(!(n % i)) n /= i;
        b[++ k] = i;
    }
    if(n > 1) b[++ k] = n;
}

int fac[N];
void init(int p){ fac[0] = 1; for(int i=1; i<=p; ++i) fac[i] = fac[i-1] * i % p; }
int fp(int a, int n, int p){ int ans = 1;while(n){    if(n & 1) ans = ans * a % p;a = a * a % p;    n >>= 1; } return ans; }
int inv(int n, int p){  return fp(n, p-2, p); }
int c(int a, int b, int p){ return a < b ? 0 : fac[a] * inv(fac[a - b], p) % p * inv(fac[b], p) % p; }
int lucas(int a, int b, int p){ return !b ? 1 : lucas(a / p, b / p, p) * c(a % p, b % p, p) % p; }

int crt(int k, int *a, int *b, int n){
    // 构造 a[]， 即 x 模 各种 bi 意义下的值 
    for(int i=1; i<=k; ++i){
        init(b[i]);

        int ans = 0;
        for(int j=1; j * j <= n; ++j){
            if(n % j) continue;
            ans = (ans + lucas(n, j, b[i])) % b[i];
            if(j * j != n) ans = (ans + lucas(n, n / j, b[i])) % b[i];
        }
        a[i] = ans;
    }
    // 合并 
    int ans = 0;
    for(int i=1; i<=k; ++i){
        int b1 = pb / b[i], ib1 = inv(b1, b[i]);
        ans = (ans + a[i] * b1 % pb * ib1 % pb) % pb;
    }

    return ans;
}
```

###### 9，离散根

```cpp
int log(int a, int b){
    if(b==1) return 0;
    int sq = sqrt(P) + 1;

    map<int, int> T;
    int pr = 1;
    for(int t=0; t<sq; ++t){
        T[b * pr % P] = t;
        pr = pr * a % P;
    }
    int pr1 = 1;
    for(int s=1; s<=sq; ++s){
        pr1 = pr1 * pr % P;
        if(T.count(pr1)) return sq * s - T[pr1];
    }
    return -1;
}

//
```

```cpp
int gcd(int a, int b){ return !b ? a : gcd(b, a % b); }
int fp(int a, int n, int p){ int ans = 1; while(n){ if(n & 1) ans = 1ll * ans * a % p; a = 1ll * a * a % p; n >>= 1; } return ans; }

int exbsgs(int a, int b, int p){
    if(b == 1) return 0;

    // 区别 1 
    long long cnt = 0, k = 1, d;
    while((d = gcd(a, p)) > 1){
        if(b % d) return -1;
        b /= d, p /= d;
        ++ cnt, k = a / d * k % p;
        if(k == b) return cnt;
    }

    int sq = sqrt(p) + 1;
    unordered_map<int, int> dec;

    d = b;
    for(int i=0; i<sq; ++i){
        dec[d] = i;
        d = d * a % p;
    }

    int asq = fp(a, sq, p);
    // 区别2，d初始化为 k，而不是 1
    d = k;
    for(int i=1; i<=sq; ++i){
        d = d * asq % p;
        // 区别3，结果加上 cnt 
        if(dec.count(d)) return cnt + i * sq - dec[d];
    }
    return -1;
}
```

###### 10，莫比乌斯

![](D:\Document%20And%20Settings2\lx\Desktop\assets\2022-09-10-23-51-41-image.png)



###### 1，并查集

+ 启发式合并（优先级高者作为祖先）
+ 判环

```cpp
const int N = 5e4+3, P = 3;
int fa[N], w[N];
void init(int n){ for(int i=0; i<=n; ++i) fa[i] = i, w[i] = 0; }
int find(int u){
    int f = fa[u];
    if(f == u) return u;
    int f1 = find(f);
    w[u] = (w[u] + w[f]) % P;
    return fa[u] = f1;
}
bool add(int u, int v, int rel){
    int x = find(u), y = find(v);
    if(x == y) return (w[u] - w[v] + P) % P == rel % P;
    fa[x] = y;
    w[x] = (w[v] + rel - w[u] + P) % P;
    return true;
}
```

###### 2，树状数组

+ 注意离散化；下标从1开始；权值数组存1以上的值

+ 可结合map

```cpp
#define lb(u) (u & -u)
int f[N], g[N];
void add(int tr[], int u, int w){
    for(int i=u; i<N; i+=lb(i)) tr[i] += w;
}
int gsum(int tr[], int u){
    int ans = 0;
    for(int i=u; i>0; i-=lb(i)) ans += tr[i];
    return ans;
}
int gsum(int tr[], int lb, int ub){ return gsum(tr, ub) - gsum(tr, lb-1); }
```

###### 3，矩阵

+ 求递推函数的两个问题：边界值，递推式

+ 列向量的 $k$ 次转移

+ 求幂时，$n\ge 1$ 或 $n\ge 0$ （根据实现的细节而不同）

```cpp
#define int long long
struct mat{
    int r, c;
    vector<vector<int>> m;
    vector<int>& operator[](int i){ return m[i]; }
    mat(int r, int c):r(r),c(c) { m.resize(r, vector<int>(c)); }
};
int P = 10;
mat operator*(mat a, mat b){
    mat ans(a.r, b.c);
    for(int i=0; i<a.r; ++i) for(int k=0; k<a.c; ++k) if(a[i][k]) for(int j=0; j<b.c; ++j)
        ans[i][j] = (ans[i][j] + a[i][k] * b[k][j] % P + P) % P;
    return ans;
}
mat operator+(mat a, mat b){
    mat ans(a.r, a.c);
    for(int i=0; i<a.r; ++i) for(int j=0; j<a.c; ++j)
        ans[i][j] = (a[i][j] + b[i][j]) % P;
    return ans;
}
mat operator^(mat a, int n){
    mat ans = a;
    for(--n; n; n>>=1, a=a*a) if(n & 1) ans = ans * a;
    return ans;
}
mat dfs(mat a, int k){
    if(k == 1) return a;
    mat ans = dfs(a, k/2);
    ans = ans * (a ^ (k/2)) + ans;
    if(k & 1) ans = ans + (a ^ k);
    return ans;
};
```

###### 4，单调栈、单调队列

+ 单调栈：最近的更大值（更小值）

+ 单调栈会比较细节

+ 单调栈又可以看作特殊的单调队列

```cpp
int st[N], t;

t = 0;
for(int i=1; i<=n; ++i){
    for(; t && a[st[t]] >= a[i]; --t);
    ans[i] = t ? st[t]+1 : 1;
    st[ ++ t] = i;
}
```

+ 单调队列：满足某条件的区间的最大值（最小值）

如：求定长 $k$ 区间的最小值

```cpp
int st[N], s, t;

s = 1, t = 0;
for(int i=1; i<k; ++i){
    for(; s<=t && a[st[t]] > a[i]; -- t);
    st[ ++ t] = i;
    for(; s<=t && i-st[s] >= k; ++ s);
}
for(int i=k; i<=n; ++i){
    for(; s<=t && a[st[t]] > a[i]; -- t);
    st[ ++ t] = i;
    for(; s<=t && i-st[s] >= k; ++ s);
    // 输出原数组最优下标 st[s] 
}
```

###### 5，ST表

+ $O(n\times log_n)~\to O(1)$ 求可重复贡献的“区间和”

+ 可结合二分（区间长度 具有单调性的情况）

```cpp
const int N = 1e5+3;
int f[N][23], n, lg[N];

void init(){
    lg[1] = 0;
    for(int i=2; i<N; ++i) lg[i] = lg[i/2] + 1;

    for(int j=1; j<23; ++j){
        for(int i=1; i+(1<<j)-1<=n; ++i){
            f[i][j] = max(f[i][j-1], f[i+(1<<j-1)][j-1]);
        }
    }
}
int get(int lb, int ub){
    int s = lg[ub-lb+1];
//    printf(" %d %d\n", lb+(1<<s), ub-(1<<s)+1+(1<<s));
    return max(f[lb][s], f[ub-(1<<s)+1][s]);
}
```


###### 1，kmp

```cpp
vector<int> pi;
void kmp(string s){
    int n = s.size();
    pi.clear(), pi.resize(n);
    pi[0] = 0;
    for(int i=1; i<n; ++i){
        int j;
        for(j=pi[i-1]; j && s[j]!=s[i]; j=pi[j-1]);
        pi[i] = s[j]==s[i] ? j+1 : j;
    }
}
```

###### 2，z函数

```cpp
void ZF(string s){
    cin >> s;
    int n = s.size();
    z.clear(), z.resize(n);
    z[0] = 0;
    for(int i=1, lb=0, ub=0; i<n; ++i){
        if(i<=ub && z[i-lb]<ub-i+1) z[i] = z[i-lb];
        else{
            z[i] = max(0, ub-i+1);
            for(; i+z[i]<=n && s[z[i]]==s[i+z[i]]; ++ z[i]);
        }
        if(ub < i+z[i]-1) lb = i, ub = i+z[i]-1;
    }
}
```

###### 3，ac自动机

```cpp
const int N = 153*73, M = 153;

string S[M];
int n, tr[N][26], idx, st[N], q[N], s, t, f[N];
void add(string s, int id){
    int u = 0;
    for(int i=0, e; e=s[i]-'a', i<s.size(); ++i, u=tr[u][e]){
        if(!tr[u][e]) tr[u][e] = ++ idx;
    }
    st[u] = id;
}
void ac(){
    s = 1, t = 0;
    for(int i=0; i<26; ++i) if(tr[0][i]) q[ ++ t] = tr[0][i];
    while(s <= t){
        int u = q[s ++ ];
        for(int i=0; i<26; ++i){
            if(tr[u][i]){
                q[ ++ t] = tr[u][i];
                f[tr[u][i]] = tr[f[u]][i];
            }else tr[u][i] = tr[f[u]][i];
        }
    }
}
int tr_ans[N], li_ans[M];
void get(string t){
    for(int i=0, u=0; u=tr[u][t[i]-'a'], i<t.size(); ++i){
        for(int j=u; j; j=f[j]){
            ++ tr_ans[j];
        }
    }
    int ans = 0;
    for(int i=1; i<=idx; ++i){
        if(st[i]){
            ans = max(ans, tr_ans[i]);
            li_ans[st[i]] = tr_ans[i];
        }
    }
    cout << ans << '\n';
    for(int i=1; i<=n; ++i){
        if(li_ans[i] == ans){
            cout << S[i] << '\n';
        }
    }
}
void init(){
    idx = 0, memset(tr, 0, sizeof tr), memset(st, 0, sizeof st);
    memset(f, 0, sizeof f);
    memset(tr_ans, 0, sizeof tr_ans);
    memset(li_ans, 0, sizeof li_ans);
}
```
