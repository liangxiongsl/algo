###### 1，并查集 union-find structure

[并查集应用 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/topic/dsu-app/)

并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的 **合并** 及 **查询** 问题。 它支持两种操作：

- 查找（Find）：确定某个元素处于哪个子集；
- 合并（Union）：将两个子集合并成一个集合。

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-21-18-10-05-image.png)

+ 初始化

$warning$：有时候为了使题目更繁杂一点，结点的标号可能为负 或者 需要离散化

```cpp
void init(int n){ for(int i=0; i<n; ++i) fa[i] = i; }
```

+ 查找（+记忆化）

![loading-ag-1146](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-21-18-25-25-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-21-18-25-52-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-21-18-25-32-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-21-18-26-04-image.png)

```cpp
// 非递归，无记忆化
int find(int u){
    while(u != fa[u]) u = fa[u];
    return u;
}
// 递归，记忆化
int find(int u){
    if(u == fa[u]) return u;
    return fa[u] = find(fa[u]);
}
```

+ 记忆化合并（适合有向关系）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-21-18-27-30-image.png)

```cpp
// 合并 u 与 v 所在的家族
void mer(int u, int v){
    u = find(u), v = find(v);
    fa[u] = v;
}
```

+ 启发式合并（适合存储无向关系；保护树结构）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-21-18-30-34-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-21-18-33-48-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-21-18-34-35-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-21-18-33-28-image.png)

（使用启发式合并是明智的）

时空复杂度：$O(m\times\alpha(m,~n))\approx O(m\times \log{n})$，$O(n)$

```cpp
const int N = 1e5+3;
struct US{
    int n, fa[N], sz[N];
    US(int x){ n = x; for(int i=0; i<n; ++i) fa[i] = i; fill(sz, sz+n, 1); }

    int find(int u){
        if(u == fa[u]) return u;
        return find(fa[u]);
    }
    void mer(int u, int v){
        int x = find(u), y = find(v);
        if(x == y) return ;
        if(sz[x] > sz[y]) swap(x, y);
        fa[x] = y;
//      sz[y] = max(sz[x] + 1, sz[y]);    // 如果sz表示高度时
        sz[y] += sz[x];
    }
}tr(N);
```

+ 带权并查集

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-21-19-03-47-image.png)

+ 例题

+ + 1，[【NOI2015】程序自动分析 - 题目 - Universal Online Judge (uoj.ac)](https://uoj.ac/problem/127)

离散化 + 常规并查集

+ + 2，[P1197 [JSOI2008] 星球大战 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1197)

每次进行**删点**操作，并且求**连通块个数**，并查集不适合删点，考虑从末状态推至初始状态

先计算末状态的连通块数，并且每次进行加点操作（同时连接相关的边，故**需要先存无向图**）

两个重点

1，计算末状态的连通块数：假设连通块数为点的个数；于是每次加上当前状态**存在的**边（边的信息来自于无向图）就会使连通块数 $-1$

2，加点操作对连通块数的影响：连通块数先 $+1$ ，遍历并加上该点的**存在的**相关边，每次成功加边都需要使 连通块数 $-1$

+ + 3，[P2024 [NOI2001] 食物链 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2024)

带权并查集（通过更新结点与父亲的权值，可以快速推导任意两点的关系）

这里使用**记忆化搜索**（这题启发式合并似乎不好用）

以下讨论权值 $W$ 的更新

1，查询：对于记忆化搜索，只有三种情况，可以发现权值仅在第三种情况下需要更新

$W_u' ~=~ (W_u + W_f)\%3$

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-22-14-53-02-image.png)

2，合并：由于记忆化搜索的影响，u 和 v的关系只有四种

考虑最一般的第四种情况 $W_x + W_u ~=~ W_v + rel \implies W_x ~=~ (W_v + rel - W_u)\% 3 $

（$W_u 或 W_v = 0$ 可以对应于前三种情况）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\并查集\assets\2022-07-22-15-12-12-image.png)

```cpp
#include<iostream>
using namespace std;

const int N = 5e4+3;
// fa, w 两者均是向上相关值 
int fa[N], w[N];
void init(int n){ for(int i=0; i<=n; ++i) fa[i] = i, w[i] = 0; }
int find(int u){
    int f = fa[u];
    if(f == u) return u;
    int f1 = find(f);
    if(f1 == f) return f;
    // 更新 u 的向上相关值 
    return w[u] = (w[u] + w[f]) % 3, fa[u] = f1;
}
bool add(int u, int v, int rel){
    int x = find(u), y = find(v);
    if(x == y) return false;
    // x欲合并到y上，更新 x的向上 和 y的向下 的相关值（但是这题 y的相关值不用变） 
    w[x] = (w[v] + rel - w[u] + 3) % 3, fa[x] = y;
    return true;
}

int n, m;

int main(){
    int ans = 0;

    cin >> n >> m;
    init(n);
    for(int i=0; i<m; ++i){
        int op, u, v;
        cin >> op >> u >> v;
//      输入异常（唯有输入正确，add()函数才能正确判断）
        if(u > n || v > n){
            ++ ans;
            continue;
        }
        if(op == 1){
            if(!add(u, v, 0) && (w[u] - w[v] + 3) % 3 != 0) ++ ans;
        }else{
            if(!add(u, v, 1) && (w[u] - w[v] + 3) % 3 != 1) ++ ans;
        }
    }
    cout << ans << '\n';
}
```

+ + 4，[P1196 [NOI2002] 银河英雄传说 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1196)

$(u,~v)$ 的合并操作被指定为 将 $u$ 所在的集合（或 $u$ 的祖先 $x$）合并到 $v$ 的后面

（这意味着合并操作**有序**，即 $add(u,~v)\ne add(v,~u)$）

每次需要查询 $u,~v$ 之间的结点个数，用 $w[~]$ （向上相关值）维护即可，而合并时更新 $w$ 又需要知道 $v$ 所在集合的大小，则再维护集合的结点数 $num[~]$ （全局相关值）

```cpp
int fa[N], w[N], num[N];
void init(int n){ for(int i=0; i<=n; ++i) fa[i] = i, w[i] = 0, num[i] = 1; }
int find(int u){
    int f = fa[u];
    if(f == u) return u;
    int f1 = find(f);
    if(f1 == f) return f;
    return w[u] = w[u] + w[f], num[u] = num[f1], fa[u] = f1;
}
bool add(int u, int v){
    int x = find(u), y = find(v);
    if(x == y) return false;
    w[x] = 1 + (num[y] - 1), num[x] = num[x] + num[y], fa[x] = y;
    num[y] = num[x];
    return true;
}
```

+ + 5，[UVA11987 Almost Union-Find - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/UVA11987)

难点：删点

```cpp
const int N = 2e5+3;
// num, sum 均是全局相关值 
int fa[N], num[N], sum[N];
// 1..n 内存的是实际的元素的指针， n+1 .. n+n 存的是虚点（包含各种相关值） 
void init(int n){
    for(int i=0; i<=n; ++i)
        fa[i] = fa[i + n] = i + n, num[i + n] = 1, sum[i + n] = i; 
}
int find(int u){
    int f = fa[u];
    if(f == u) return u;
    int f1 = find(f);
    if(f1 == f) return f;
    return fa[u] = f1;
}
bool add(int u, int v){
    int x = find(u), y = find(v);
    if(x == y) return false;
    num[x] += num[y], sum[x] += sum[y], fa[x] = y;
    num[y] = num[x], sum[y] = sum[x];
    return true;
}
bool move(int u, int v){
    int x = find(u), y = find(v);
    if(x == y) return false;
    // 移动 u 到 v 的根 y 上 
    fa[u] = y;
    // 改变 u 对相关量的贡献 
    -- num[x], sum[x] -= u;
    ++ num[y], sum[y] += u;
    return true;
}
```

[P3144 [USACO16OPEN]Closing the Farm S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3144)
