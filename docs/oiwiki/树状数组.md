###### 1，简介

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\树状数组\assets\2022-07-30-18-02-15-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\树状数组\assets\2022-07-30-20-44-35-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\树状数组\assets\2022-07-30-20-44-27-image.png)

（$a_u$ 受一些 $c_v,~u\le v\le n$ 支配  ）

（性质：$c$的**偶数**结点 $c_{2u-1}$ 可以直接求出其支配的区间和，$c$的**奇数**结点 $c_{2u}$（图中没画出，否则上图就不像一颗树了）则要对其支配的多棵树求和）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\树状数组\assets\2022-07-30-20-45-59-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\树状数组\assets\2022-07-30-20-46-30-image.png)

###### 2，核心操作 $lowbit$

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\树状数组\assets\2022-07-30-20-49-14-image.png)

$lowbit_u$ 表示 $u$ 的二进制表示中，最低位的 1 的位置对应的数（该数仅该位置为 0）

（我觉得大概也未必一定要用$lowbit$ 可能也有适合的函数）

$e.g.~~lowbit_{76}=lowbit_{1001100_2} = 100_2 = 4$

```cpp
#define lb(u) u & -u
```

性质：$lowbit_u \le u$ （$u+lowbit_u \le 2\times u$）

###### 3，朴素模板，trics，第k小值

（$n$ 的上界不影响效率下应该尽可能大）

```cpp
const int N = 1e5+3;
int a[N], n;
int lb(int u){ return -u & u; }

void add(int u, int w){
//  if(u <= 0) return void(puts("yele"));
    // 更新 a_u 及 c_u 支配的结点 
    while(u <= n){
        a[u] += w;
        u += lb(u);
    }
}

int gsum(int u){
//  if(u <= 0) return puts("yele");
    int ans = 0;
    // 累加 a_u 及其 c_u 支配的其他结点 
    while(u >= 1){
        ans += a[u];
        u -= lb(u);
    }
    return ans;
}
```

（温馨小提示：$u=0$ 时，$lowbit_u = lowbit_0= 0 \le n$， 必然死循环）、

+ 区间加 & 区间和查询

（主要讨论区间和查询）

要求 $\sum\limits_{i=1}^u a_i$ ，此时引入查分数组 $b$ ，$a_u = \sum\limits_{i=1}^u b_i$

$\displaystyle \operatorname{GSUM}_u = \sum_{i=1}^u a_i = \sum_{i=1}^u\sum_{j=1}^i b_j = \sum_{j=1}^u\sum_{i=1}^u b_j[j\le i] = \sum_{j=1}^u\sum_{i=j}^u b_j =  \sum_{j=1}^u (u-j+1)\times b_j \\ = (u+1)\times\sum_{j=1}^u b_j - \sum_{j=1}^u j\times b_j$ 

于是，我们就可以维护两个数组 $\{b_j\},~\{j\times b_j\}$

$\operatorname{GSUM}_u = (u+1)\times gsum_{u} -gsum1_{u}$

$\operatorname{GSUM}_{ub}-\operatorname{GSUM}_{lb-1} = ((ub+1)\times gsum_{ub}- gsum1_{ub}) - (lb\times gsum_{lb-1}- gsum1_{lb-1})$

板子：

```cpp
#define int long long
#define lb(u) u&-u
const int N = 1e6+3;
int a[N], a1[N], n;

// 单点改 
void add(int u, int w){
    int w1 = u * w;
    while(u <= n){
        a[u] += w, a1[u] += w1;
        u += lb(u);
    }
}
// 区间改 
void add(int lb, int ub, int w){
    add(lb, w), add(ub + 1, -w);
}

// 前缀查
int gsum(int *a, int u){
    int ans = 0;
    while(u){
        ans += a[u];
        u -= lb(u);
    }
    return ans;
}
// 区间查
int gsum(int lb, int ub){
    return (ub + 1) * gsum(a, ub) - gsum(a1, ub)
        - (lb * gsum(a, lb-1) - gsum(a1, lb-1));
}
```

+ Tricks

每一个节点的值是由所有与自己直接相连的儿子的值求和得到的。因此可以倒着考虑贡献，即每次确定完儿子的值后，用自己的值更新自己的直接父亲。

复杂度：$O(n)$

```cpp
void init() {
    for (int i = 1; i <= n; ++i) {
        t[i] += a[i];
        int j = i + lowbit(i);
        if (j <= n) t[j] += t[i];
    }
}
```

+ 查询第 $k$ 小的值

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\树状数组\assets\2022-07-30-23-47-17-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\树状数组\assets\2022-07-30-23-47-28-image.png)

$\displaystyle t=\sum_{i=x+1}^{x+2^{depth}}a_i$

1. 求出 $depth=\left \lfloor \log_2n \right \rfloor$
2. 计算 $\displaystyle t=\sum_{i=x+1}^{x+2^{depth}}a_i$
3. 如果 $sum+t \le k$，则此时扩展成功，将 $2^{depth}$ 累加到 $x$ 上；否则扩展失败，对 $x$ 不进行操作
4. 将 $depth$ 减 1，回到步骤 2，直至 $depth$ 为 0

```cpp
#define lb(u) (u&-u)
const int N = 3.2e4+3;
// 权值树状数组
int n, tr[N];

void add(int u, int cnt = 1){
    for(int i=u; i<N; i+=lb(i)) tr[i] += cnt;
}

int gsum(int u){
    int ans = 0;
    for(int i=u; i>0; i-=lb(i)) ans += tr[i];
    return ans;
}

int kth(int k){
    int w = 0, sum = 0;
    for(int i=log2(n); ~i; --i){
        w += 1 << i, sum += tr[w];
        if(w >= n || sum >= k)
            w -= 1 << i, sum -= tr[w];
    }
    return w + 1;
}
```

（**warning：** $N$ 是 $a_i$ 的值域中的最大值；$a_i$ 最小值应大于0（否则 $++ a_i$））

+ 时间戳优化

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\树状数组\assets\2022-07-31-00-03-43-image.png)

```cpp
#define lb(u) u&-u
const int N = 1e5+3;
int a[N], n;
int tag[N], Tag;
void reset(){ ++ Tag; }

void add(int u, int w){
    while(u <= n){
        if(tag[u] != Tag) a[u] = 0;
        a[u] += w, tag[u] = Tag;
        u += lb(u);
    }
}

int gsum(int u){
    int ans = 0;
    while(u){
        if(tag[u] == Tag) ans += a[u];
        u -= lb(u);
    }
    return ans;
}
```

###### 4，二维树状数组

（**warning：** 对于 $a_i$ 值域小于 $1e3$ 的可以考虑二维树状数组，否则如果 $n\le 1e3$ 可以离散化处理）

1，单改多查

```cpp
#define int long long
#define lb(u) (u&-u)
const int N = 4.1e3+3;
int a[N][N], n, m;

void add(int u, int v, int w){
    for(int i=u; i<=n; i+=lb(i)){
        for(int j=v; j<=m; j+=lb(j)){
            a[i][j] += w;
        }
    }
}

int gsum(int u, int v){
    int ans = 0;
    for(int i=u; i; i-=lb(i)){
        for(int j=v; j; j-=lb(j)){
            ans += a[i][j];
        }
    }
    return ans;
}
```

2，多改多查

（这是仅针对区间加的优化，题目不需要 区间加 则尽量不用此优化；另外，树状数组天生支持区间查询）

同样是树状数组维护差分数组

$\displaystyle \sum_{i=1}^u\sum_{j=1}^v a_{i,~j} = \sum_{i=1}^u\sum_{j=1}^v\sum_{k=1}^i\sum_{l=1}^j b_{k,~l} = \sum_{k=1}^u\sum_{l=1}^v\sum_{i=1}^u\sum_{j=1}^v b_{k,~l}[k\le i,~l\le j]\\ = \sum_{k=1}^u\sum_{l=1}^v b_{k,~l}\times(u-k+1)\times(v-l+1) = \\ (u+1)\times(v+1)\times\sum_{k=1}^u\sum_{l=1}^v b_{k,~l} - (u+1)\sum_{k=1}^u\sum_{l=1}^v b_{k,~l}\times l \\ - (v+1)\times\sum_{k=1}^u\sum_{l=1}^v b_{k,~l}\times k + \sum_{k=1}^u\sum_{l=1}^v b_{k,~l}\times k\times l$

四个树状数组维护四个数列 $\{b_{i,~j}\}，\{i\times b_{i,~j}\}，\{j\times b_{i,~j}\}，\{i\times j\times b_{i,~j}\}$即可

```cpp
#define int long long
#define lb(u) (u&-u)
const int N = 2.1e3+3;
int a[N][N], a1[N][N], a2[N][N], a3[N][N];
int n, m;

void add(int u, int v, int w){
    int w1 = u * w, w2 = v * w, w3 = u * v * w;
    for(int i=u; i<=n; i+=lb(i))
        for(int j=v; j<=m; j+=lb(j))
            a[i][j] += w, a1[i][j] += w1, a2[i][j] += w2, a3[i][j] += w3;
}
void add(int lb, int lb1, int ub, int ub1, int w){
    add(lb, lb1, w), add(ub+1, ub1+1, w), 
    add(lb, ub1+1, -w), add(ub+1, lb1, -w);
}

int gsum(int a[][N], int u, int v){
    int ans = 0;
    for(int i=u; i; i-=lb(i))
        for(int j=v; j; j-=lb(j))
            ans += a[i][j];
    return ans;
}
int gsum(int lb, int lb1, int ub, int ub1){
// 注意define后面还有很长一段
#define GS(u, v) ((u+1)*(v+1)*gsum(a, u, v) - (v+1)*gsum(a1, u, v) - (u+1)*gsum(a2, u, v) + gsum(a3, u, v))
    return GS(ub, ub1) + GS(lb-1, lb1-1) - GS(ub, lb1-1) - GS(lb-1, ub1);
}
```

###### 5，三维树状数组

1，区间加+单点查

```cpp
#define lb(u) (u&-u)
const int N = 1e2+3;
int tr[N][N][N], n;

void add(int x, int y, int z, int w){
    for(int i=x; i<=n; i+=lb(i))
        for(int j=y; j<=n; j+=lb(j))
            for(int k=z; k<=n; k+=lb(k))
                tr[i][j][k] += w;
}
void add(int lb, int lb1, int lb2, int ub, int ub1, int ub2, int w){
    add(lb, lb1, lb2, w);
    add(lb, lb1, ub2+1, -w);
    add(lb, ub1+1, lb2, -w);
    add(lb, ub1+1, ub2+1, w);
    add(ub+1, lb1, lb2, -w);
    add(ub+1, lb1, ub2+1, w);
    add(ub+1, ub1+1, lb2, w);
    add(ub+1, ub1+1, ub2+1, -w);
}

int gsum(int x, int y, int z){
    int ans = 0;
    for(int i=x; i; i-=lb(i))
        for(int j=y; j; j-=lb(j))
            for(int k=z; k; k-=lb(k))
                ans += tr[i][j][k];
    return ans;
}
```

2，区间加 + 区间查

```cpp
#define lb(u) (u&-u)
const int N = 103;
int a[8][N][N][N], n;

void add(int x, int y, int z, int w){
    int W[8] = {w, w * x, w * y, w * z, 
    w * x * y, w * x * z, w * y * z, w * x * y * z};
    for(int i=x; i<=n; i+=lb(x))
        for(int j=y; j<=n; j+=lb(y))
            for(int k=z; k<=n; k+=lb(z))
                for(int l=0; l<8; ++l)
                    a[l][i][j][k] += W[l];
}

void add(int lb, int lb1, int lb2, int ub, int ub1, int ub2, int w){
    add(lb, lb1, lb2, w);
    add(lb, lb1, ub2+1, -w);
    add(lb, ub1+1, lb2, -w);
    add(lb, ub1+1, ub2+1, w);

    add(ub+1, lb1, lb2, -w);
    add(ub+1, lb1, ub2+1, w);
    add(ub+1, ub1+1, lb2, w);
    add(ub+1, ub1+1, ub2+1, -w);
}
int gsum(int x, int y, int z){
    int ans[8] = {};
    int st[8] = {-(x+1)*(y+1)*(z+1), (y+1)*(z+1), (x+1)*(z+1), (x+1)*(y+1), 
                -(z+1), -(y+1), -(x+1), 1};
    for(int i=x; i; i-=lb(i))
        for(int j=y; j; j-=lb(j))
            for(int k=z; k; k-=lb(k))
                for(int l=0; l<8; ++l)
                    ans[l] += a[l][i][j][k];
    int ret = 0;
    for(int i=0; i<8; ++i) ret += st[i] * ans[i];
    return ret;
}
int gsum(int lb, int lb1, int lb2, int ub, int ub1, int ub2){
    return 0
    +gsum(ub, ub1, ub2)
    -gsum(ub, ub1, lb2-1)
    -gsum(ub, lb1-1, ub2)
    +gsum(ub, lb1-1, lb2-1)
    -gsum(lb-1, ub1, ub2)
    +gsum(lb-1, ub1, lb2-1)
    +gsum(lb-1, lb1-1, ub2)
    -gsum(lb-1, lb1-1, lb2-1)
    ;
}
```

6，例题

[CWXU-暑期集训-树状数组 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/contest/507481#problem/A)

[树状数组 专题题单 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/article/2815)
