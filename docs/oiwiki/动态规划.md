###### 1、动态规划基础

+ 原理
  
  ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-23-27-35-image.png)

+ + 最优子结构
    
    ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-23-34-37-image.png)
    
    ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-23-34-45-image.png)

+ + 无后效性
    
    ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-23-35-08-image.png)

+ + 子问题重叠
    
    ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-23-35-44-image.png)

+ + 动规的基本思路
    
    ![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-06-21-23-36-21-image.png)

+ 常见问题

+ + 最长公共子序列 $lcs$ 

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-06-23-29-49-image.png)

```cpp
// 朴素算法
int n, m;
char a[N], b[N];
int f[N][N];
int dp(){
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++)
            if(a[i] == b[j]) f[i][j] = f[i-1][j-1] + 1;
            else f[i][j] = max(f[i-1][j], f[i][j-1]);
    return f[n][m];
}
```

更优算法：[位运算求最长公共子序列 - -Wallace- - 博客园 (cnblogs.com)](https://www.cnblogs.com/-Wallace-/p/bit-lcs.html)

+ + 最长不下降子序列 $lis$

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-06-23-33-04-image.png)

```cpp
// 朴素算法
int n;
int a[N], f[N];
int dp(){
    int ans = 1;
    f[1] = 1;
    for(int i=2; i<=n; ++i){
        for(int j=1; j<i; ++j){
            if(a[i] >= a[j]){
                f[i] = max(f[i], f[j] + 1);
                ans = max(ans, f[i]);
            }
        }
    }
    return ans;
}
```

[Super Jumping! Jumping! Jumping! - HDU 1087 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/HDU-1087)

[FatMouse's Speed - HDU 1160 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/HDU-1160)

[最少拦截系统 - HDU 1257 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/HDU-1257)

[Bridging signals - HDU 1950 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/HDU-1950)

###### 2，记忆化搜索

###### 3，背包dp

核心：限制 和 贡献

+ 1，01背包

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-15-39-33-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-15-39-44-image.png)

```cpp
int n;
int A, a[N], B, b[N], f[N];
int _(){
    for(int i=1; i<=n; ++i){
        for(int j=A; j>=a[i]; --j){
//          当前的选择只受上一个物品影响，故可滚动数组
//            f[i][j] = max(f[i-1][j], f[i-1][j-a[i]]+b[i]);
            f[j] = max(f[j], f[j-a[i]] + b[i]);
        }
    }
    cout << f[A] << '\n';
}
```

+ 2，完全背包

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-16-00-21-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-16-01-20-image.png)

朴素状态转移方程：$f_{i,j}=\max_{k=0}^{+\infty}(f_{i-1,j-k\times w_i}+v_i\times k)$

优化的状态转移方程：$f_{i,j}=\max(f_{i-1,j},f_{i,j-w_i}+v_i)$

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-16-05-56-image.png)

[P1616 疯狂的采药 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1616)

```cpp
int n;
int A, a[N/1000], B, b[N/1000], f[N];
int _(){
    for(int i=1; i<=n; ++i){
        for(int j=a[i]; j<=A; ++j){
//            f[i][j] = max(f[i-1][j], f[i][j-a[i]]+b[i]);
            f[j] = max(f[j], f[j-a[i]] + b[i]);
        }
    }
    cout << f[A] << '\n';
}
```

+ 3，多重背包

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-16-15-24-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-16-18-05-image.png)

$f_{i,j}=\max_{k=0}^{k_i}(f_{i-1,j-k\times w_i}+v_i\times k) \qquad O(W\sum_{i=1}^nk_i)$

+ + 二进制分组优化

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-16-19-30-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-16-19-37-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-16-21-44-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-16-21-54-image.png)

$O(W\sum_{i=1}^n\log_2k_i)$

[P1776 宝物筛选 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1776)

```cpp
int idx;
int A, a[N], B, b[N];
int f[N];
int _(int n, int A, int *a, int *b){
    for(int i=1; i<=n; ++i){
        for(int j=A; j>=a[i]; --j){
            f[j] = max(f[j], f[j-a[i]]+b[i]);
        }
    }
    return f[A];
}
void solve(){
    int n;
    cin >> n >> A;
    for(int i=1; i<=n; ++i){
        int aa, bb, kk;
        cin >> bb >> aa >> kk;
        for(int k=1; k<=kk; k<<=1){
            ++ idx, a[idx] = k * aa, b[idx] = k * bb;
            kk -= k;
        }
        if(kk) ++ idx, a[idx] = kk * aa, b[idx] = kk * bb;
    }
    cout << _(idx, A, a, b);
}
```

+ 4，混合背包

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-16-48-59-image.png)

+ + 做法1：

```cpp
for (循环物品种类) {
  if (是 0 - 1 背包)
    套用 0 - 1 背包代码;
  else if (是完全背包)
    套用完全背包代码;
  else if (是多重背包)
    套用多重背包代码;
}
```

+ + 做法2：完全背包、多重背包 $\implies $ 01背包 + 二进制优化

（值得注意的细节：（完全背包的情况中，）物品的限制 $aa可能=0$ ，该物品的“可容纳上界” 应合理设置；$aa$非0时，物品数量设为 $A/aa$（物品数量的上界））

```cpp
int n, A, a[N], B, b[N];
int f[N];
int _(int n, int A, int *a, int *b){
    for(int i=1; i<=n; ++i){
        for(int j=A; j>=a[i]; --j){
            f[j] = max(f[j], f[j-a[i]]+b[i]);
        }
    }
    return f[A];
}
void solve(){
    int idx;

    int t[4], m;
    scanf("%d:%d %d:%d %d", t, t+1, t+2, t+3, &m);
    A = (t[2] - t[0]) * 60 + (t[3] - t[1]);
    for(int i=1; i<=m; ++i){
        int aa, bb, kk;
        cin >> aa >> bb >> kk;
//      完全 -> 多重  
        kk = !kk ? (!aa ? A/aa : A / aa) : kk;
//         多重 -> 01
        for(int k=1; k<=kk; k<<=1){
            ++ idx, a[idx] = k * aa, b[idx] = k * bb;
            kk -= k;
        }
        if(kk) ++ idx, a[idx] = kk * aa, b[idx] = kk * bb;;
    }
    cout << _(idx, A, a, b) << '\n';
}
```

+ + 做法三：完全背包$\implies$多重背包， 而 01背包 $\iff$ 多重背包 ，使用单调队列优化

+ 5，二维费用背包（水题）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-18-13-45-image.png)

[P1855 榨取kkksc03 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1855)

```cpp
int n;
int A, a[N], B, b[N];
int f[N][N];
int _(){
    for(int i=1; i<=n; ++i)
        for(int j=A; j>=a[i]; --j)
            for(int k=B; k>=b[i]; --k)
                f[j][k] = max(f[j][k], f[j - a[i]][k - b[i]] + 1);
    return f[A][B];
}
```

+ 6，分组背包（[]()）

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-19-28-21-image.png)[P1757 通天之分组背包 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1757)

是个好题，“离散读取数据”，即 $id$ 并非按顺序给出；注意循环顺序！！

```cpp
#include<iostream>
using namespace std;

#include<map>
#include<vector>
const int N = 1e3+3;
struct nd{ int a, b; };
map<int, vector<nd>> bag;
int A;

int f[N];
int _(){
    for(auto  i: bag)               // 循环每一组
        for(int j=A; j>=0; --j)     // 循环背包容量
            for(auto k : i.second)  // 循环该组的每一个物品
                if(k.a <= j){
                    f[j] = max(f[j], f[j - k.a] + k.b);
                }
    return f[A];
}

int main(){
    int n;
    cin >> A >> n;
    for(int i=1; i<=n; ++i){
        int aa, bb, id;
        cin >> aa >> bb >> id;
        bag[id].push_back({aa, bb});
    }
    cout << _() << '\n';
}
```

+ 7，依赖背包

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-23-15-13-image.png)

将多个“主件”看成多棵树，枚举每一棵树，然后枚举结点之间的选择情况，

相对于一棵树而言，记树根为 $0$，孩子为 $1$ 和 $2$，可选择的所有方案为：

$\empty,~\{0\},~~\{0,~1\},~\{0,~2\},~\{0,~1,~2\}$

**（补充：initializer_list\<T\> 和 lambda 的函数式编程很适用于状态计算！！）**

[P1064 [NOIP2006 提高组] 金明的预算方案 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1064)

```cpp
#include<iostream>
using namespace std;

const int N = 4e4+3;
// 编号是离散的，即 有的位置没有物品！！，其属性均为 0 
int n, A, a[N][3], b[N][3], f[N];    // （由于树的深度是2，所以直接用二维数组） 

int main(){
    cin >> A >> n;
    for(int i=1; i<=n; ++i){
        int aa, bb, t;
        cin >> aa >> bb >> t;
        if(!t) a[i][0] = aa, b[i][0] = bb;
        // 编号为 t 的物品有第一个空位 
        else if(!a[t][1]) a[t][1] = aa, b[t][1] = bb;
        // 编号为 t 的物品有第二个空位 
        else if(!a[t][2]) a[t][2] = aa, b[t][2] = bb;
    }

    // 枚举根结点，然后状态机 
    for(int i=1; i<=n; ++i){
        for(int j=A; j>=0; --j){
            auto up = [&f, i, j, a, b](initializer_list<int> l){
                int lmt = 0, val = 0;    // 限制 和 贡献
                for(auto t : l) lmt += a[i][t], val += a[i][t] * b[i][t];
                if(j - lmt >= 0) f[j] = max(f[j], f[j - lmt] + val);
            };
            up({0});
            up({0, 1});
            up({0, 2});
            up({0, 1, 2});
        }
    }
    cout << f[A] << '\n';
}
```

（该题与$01$背包的本质区别是：$01$ 背包有2种决策，而该题中有5种决策）

+ 8，泛化的背包

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-23-27-51-image.png)

[CWXU-暑假集训-背包DP - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/contest/502767)

+ 9，杂项

+ + 小优化

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-23-30-06-image.png)

+ + 背包的变种

+ + + 1，输出方案

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-07-23-47-30-image.png)

```cpp
// 因为最后一件物品存储的是最终状态，所以从最后一件物品进行循环
for (从最后一件循环至第一件) {
    if (g[i][v]) {
        选了第 i 项物品;
        v -= 第 i 项物品的重量;
    } else {
        未选第 i 项物品;
    }
}
```

+ + + 2，求方案数

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-08-00-03-23-image.png)

```cpp
// 01 + 滚动
int n, A, a[N], f[N];
int _(){
    f[0] = 1;
    for(int i=1; i<=n; ++i)
        for(int j=A; j>=a[i]; --j)
            f[j] += f[j - a[i]];
    return f[A];
}
```

拓展：[1742 -- Coins (poj.org)](http://poj.org/problem?id=1742)（多重背包，用二进制优化会tle）

+ + + 3，最优方案总数

```cpp
int n, A, a[N], b[N], f[N], g[N];
int _(){
    memset(f, -0x3f, sizeof f);
    f[0] = 0;
    g[0] = 1;
    for(int i=1; i<=n; ++i){
        for(int j=A; j>=a[i]; --j){
            int tmp = max(f[j], f[j - a[i]] + b[i]);
            int val = 0;
            if(tmp == f[j]) val += g[j];
            if(tmp == f[j - a[i]] + b[i]) val += g[j - a[i]];
            f[j] = tmp;
            g[j] = val;
        }
    }

    int mx = 0;
    for(int i=0; i<=A; ++i) mx = max(mx, f[i]);
    int ans = 0;
    for(int i=0; i<=A; ++i) if(f[i] == mx) ans += g[i];
    return ans;
```

+ + + 4，背包的第k优解

```cpp
#include<iostream>
#include<cstring>
using namespace std;

const int N = 1e3+3;
int n, A, a[N], b[N], K, f[N][N];
int G, g[N], H, h[N];
int _(){
    memset(f, 0, sizeof f);
    for(int i=1; i<=n; ++i){
        for(int j=A; j>=a[i]; --j){
            for(int k=1; k<=K; ++k)
g[k] = f[j][k], h[k] = f[j - a[i]][k] + b[i];

            g[K + 1] = h[K + 1] = -1;
            int kk = 1, gg = 1, hh = 1;
            while(kk <= K && (~g[gg] || ~h[hh])){
                f[j][kk] = g[gg] > h[hh] ? g[gg ++ ] : h[hh ++ ];
                if(f[j][kk] != f[j][kk - 1]) ++ kk;
            }
        }
    }
    return f[A][K];
}

int main(){
    int T;
    cin >> T;
    while(T--){
        cin >> n >> A >> K;
        for(int i=1; i<=n; ++i) cin >> b[i];
        for(int i=1; i<=n; ++i) cin >> a[i];
        cout << _() << '\n';
    }
}
```

###### 4，区间dp

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-08-21-18-08-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-08-21-18-00-image.png)

[#10147. 「一本通 5.1 例 1」石子合并 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/10147)

```cpp
for(int d = 1; d < n; ++d){
    for(int lb = 1, ub; (ub = lb + d) < 2 * n; ++lb){
        f[lb][ub] = inf;
        f1[lb][ub] = -inf;
        for(int mid = lb; mid < ub; ++ mid){
            f[lb][ub] = min(f[lb][ub], 
                        f[lb][mid] + f[mid + 1][ub] + a[ub] - a[lb - 1]);
            f1[lb][ub] = max(f1[lb][ub], 
                        f1[lb][mid] + f1[mid + 1][ub] + a[ub] - a[lb - 1]);
        }
    }
}
```

+ 习题：

+ + [能量项链 - Vijos](https://vijos.org/p/1312)
  
  + [矩阵取数游戏 - Vijos](https://vijos.org/p/1378)
  
  + [P4767 [IOI2000]邮局 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4767)

###### 5，树形dp

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-12-21-49-48-image.png)

+ 1，基础

+ + [P1352 没有上司的舞会 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1352)

我们设 $f_{u,~1/0}$ 代表以 $u$ 为根的子树的最优解（第二维的值为 0 代表  不参加舞会的情况，1 代表 $u$ 参加舞会的情况）。

状态转移：$f_{u,~0} ~=~ \sum\limits_{(u,~v)\in E}max\{f_{v,~0},~f_{v,~1}\}  \\ f_{u,~1} ~=~ \sum\limits_{(u,~v)\in E}f_{v,~0} ~+~ w_{(u,~v)} $

```cpp
#include<iostream>
#include<cstring>
using namespace std;

const int N = 6e3+3;
struct edge{ int v, ne; }e[N];
int idx, n, h[N];
void addedge(int u, int v){
    e[++ idx] = {v, h[u]}, h[u] = idx;
}

int d[N], st[N], f[N][2];

void calc(int u){
    st[u] = true;
    for(int i=h[u], v; v=e[i].v, ~i; i=e[i].ne){
        if(st[v]) continue;
        calc(v);
        f[u][0] += max(f[v][0], f[v][1]);
        f[u][1] += f[v][0];
    }
}

int main(){
    cin >> n;
    for(int i=1; i<=n; ++i) cin >> f[i][1];

    idx = 0; 
    memset(h, -1, sizeof h);
    for(int i=1; i<n; ++i){
        int u, v;
        cin >> v >> u;
        d[v] = true;
        addedge(u, v);
    }
    for(int i=1; i<=n; ++i){
        if(d[i]) continue;
        calc(i);
        cout << max(f[i][0], f[i][1]) << '\n';
    }
}
```

+ + [Computer - HDU 2196 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/HDU-2196)

题意：给定一棵带权树（n个点，n-1条边），求每个结点到叶子的最长距离

状态转移：$f_u ~=~ max\{f'_{(u,~v)}\} \\ f'_{(u,~v)} ~=~ f_v ~+~ w_{(u,~v)} \quad v\ne u.father $

（ $f'_{u,~v)}$ 需要记忆化）

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

const int N = 2e4+3;
struct edge{ int v, ne, w; }e[N];
int idx, n, h[N];
void add(int u, int v, int w){
    e[ ++ idx] = {v, h[u], w}, h[u] = idx;
}

int f[N];
int dfs(int u, int p){
    int ans = 0;
    for(int i=h[u]; i; i=e[i].ne){
        int v = e[i].v, w = e[i].w;
        if(v == p) continue;
        if(!f[i]) f[i] = dfs(v, u) + w;
        ans = max(ans, f[i]);
    }
    return ans;
}

int main(){
    while(cin >> n){
        idx = 0;
        memset(h, 0, sizeof h);
        for(int i=2; i<=n; ++i){
            int v, w;
            cin >> v >> w;
            add(i, v, w);
            add(v, i, w);
        }

        memset(f, 0, sizeof f);
        for(int i=1; i<=n; ++i){
            cout << dfs(i, 0) << ' ' << cc << '\n';
        }
    }
}
```

+ + [Strategic Game - HDU 1054 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/HDU-1054)

题意：给定一棵无权树，选出 x 个点使这些点的邻边覆盖树的边集 $E(G)$

状态转移：$f_{u,~0} ~=~ \sum\limits_{(u,~v)\in E}f_{v,~1} \\ f_{u,~1} ~=~ \sum\limits_{(u,~v)\in E}min\{f_{v,~0},~f_{v,~1}\} ~+~ 1 $

```cpp
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

const int N = 3e3+3;
struct edge{ int v, ne; }e[N];
int idx, n, h[N];
void add(int u, int v){
    e[ ++ idx] = {v, h[u]}, h[u] = idx;
}

int f[N][2];
void dfs(int u, int p){
    f[u][0] = 0;
    f[u][1] = 1;
    for(int i=h[u]; ~i; i=e[i].ne){
        int v = e[i].v;
        if(v == p) continue;
        dfs(v, u);
        f[u][0] += f[v][1];
        f[u][1] += min(f[v][0], f[v][1]);
    }
}


int main(){
    while(~scanf("%d", &n)){
        memset(h, -1, sizeof h);
        idx = 0;
        for(int i=1; i<=n; ++i){
            int u, v, cnt;
            scanf("%d:(%d)", &u, &cnt);
            while(cnt--) scanf("%d", &v), add(u, v), add(v, u);
        }

        memset(f, 0, sizeof f);
        dfs(0, -1);
        cout << min(f[0][0], f[0][1]) << '\n';
    }
}
```

+ + [P3574 [POI2014] FAR-FarmCraft - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3574)

+ 2，书上背包

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-13-10-41-03-image.png)

[P2014 [CTSC1997] 选课 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2014)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-13-10-42-05-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-13-10-41-31-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-13-10-42-29-image.png)

（第二维可以滚动    ）

```cpp
#include<iostream>
#include<cstring>
using namespace std;

const int N = 3e2+3;
struct edge{ int v, ne; }e[N];
int idx, n, h[N], A, b[N];
void add(int u, int v){
    e[ ++ idx] = {v, h[u]}, h[u] = idx;
}

int f[N][N];
void dfs(int u){
    f[u][1] = b[u];
    for(int _=h[u]; ~_; _=e[_].ne){
        int v = e[_].v;
        dfs(v);
        for(int i=A; i>=1; --i){
            for(int j=0; j<i; ++j){
                f[u][i] = max(f[u][i], f[u][i - j] + f[v][j]);
            }
        }
    }
}

int main(){
    cin >> n >> A;
    memset(h, -1, sizeof h);
    idx = 0;
    for(int i=1; i<=n; ++i){
        int u;
        cin >> u >> b[i];
        add(u, i);
    }
    ++ A;

    dfs(0);
    cout << f[0][A] << '\n';
}
```

+ + [P4516 [JSOI2018] 潜入行动 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4516)

+ + [P3780 [SDOI2017]苹果树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3780)

+ 3，换根dp

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-13-16-25-45-image.png)

+ + [P3478 [POI2008] STA-Station - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3478)

```cpp

```

+ + [Accumulation Degree - POJ 3585 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/POJ-3585)

+ + [P2986 [USACO10MAR] Great Cow Gathering G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2986)

+ + [Problem - 708C - Codeforces](https://codeforces.com/problemset/problem/708/C)

###### 6，DAG上的dp

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-14-17-07-35-image.png)

[The Tower of Babylon - UVA 437 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/UVA-437)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-15-09-03-17-image.png)

每种砖头按摆放状态可以分为3种，开一个数组来存；考虑深搜的思想，可以构建一个有 $3\times n$ 棵树的森林，每次递归都从 $3\times n$ 种砖头里选长宽合适的砖头作为子结点。（可以记忆化）

```cpp
#include<iostream>
#include<cstring>
using namespace std;

#define int long long
const int N = 33;
struct { int a, b, x; }vt[N * 3];
int n, f[N * 3];

int dfs(int u){
    if(~f[u]) return f[u];
    f[u] = 0;
    for(int v=1; v<=n; ++v){
        if(vt[u].a > vt[v].a && vt[u].b > vt[v].b || 
            vt[u].a > vt[v].b && vt[u].b > vt[v].a){
            f[u] = max(f[u], dfs(v) + vt[v].x);
        }
    }
    return f[u];
}

signed main(){
    int m, test = 0;
    while(cin >> m, m){
        n = 0;
        for(int i=1; i<=m; ++i){
            int a, b, c;
            cin >> a >> b >> c;
            vt[ ++ n] = {a, b, c};
            vt[ ++ n] = {b, c, a};
            vt[ ++ n] = {c, a, b};
        }

        memset(f, -1, sizeof f);
        int ans = 0;
        for(int i=1; i<=n; ++i){
            ans = max(ans, dfs(i) + vt[i].x);
        }

        printf("Case %lld: maximum height = %lld\n", ++ test, ans);
    }
}
```


###### 7，状压dp

[#2153. 「SCOI2005」互不侵犯 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/2153)

![](D:\Document%20And%20Settings2\lx\Desktop\project-梁雄\img\2022-07-15-09-20-11-image.png)

```cpp
#include<iostream>
using namespace std;

#define int long long
const int N = 15;
int n, k, f[N][1<<N][N * N];

int idx, st[1<<N], d[1<<N];
// 构造行内合法的状态 
void dfs(int s, int num, int cur){
    if(cur >= n) return void(( st[++ idx] = s, d[idx] = num ));
    dfs(s, num, cur + 1);
    dfs(s | 1 << cur, num + 1, cur + 2);
}
// 过滤相邻两行不合法的状态 
bool fail(int u, int v){
    return st[u] & st[v] || st[u] << 1 & st[v] || st[u] & st[v] << 1;
}


signed main(){
    cin >> n >> k;
    dfs(0, 0, 0);

    for(int i=1; i<=n; ++i){
        for(int u=1; u<=idx; ++u){
            if(i==1){ f[i][u][d[u]] = 1; continue; }
            for(int l=d[u]; l<=k; ++l){
                for(int v=1; v<=idx; ++v){
                    if(fail(u, v)) continue;
                    f[i][u][l] += f[i-1][v][l - d[u]];
                }
            }
        }
    }
    int ans = 0;
    for(int u=1; u<=idx; ++u) ans += f[n][u][k];
    cout << ans << '\n';
}
```

+ [#10173. 「一本通 5.4 练习 2」炮兵阵地 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/10173)

```cpp
#include<iostream>
using namespace std;

// m=10时，满足第一个行状态条件的有60个，所以不需要开1<<10=1024大的数组
int idx, st[60], num[60], a[103];

int n, m, f[103][60][60];


int main(){
    cin >> n >> m;
    int mm = 1 << m;
//  过滤第一种非法的行状态，并使用lowbit计算行状态的1的个数
    for(int i=0; i<mm; ++i){
        if(i<<1&i || i>>1&i) continue;
        if(i<<2&i || i>>2&i) continue;
        st[idx] = i, num[idx] = 0;
        for(int j=i; j; j-=j&-j) ++ num[idx];
        ++ idx;
    }
//    cout << idx << '\n';

//    读入每行的 “可放置状态”a[i]，仅当 st & ~a[i] != 0 时，st 不是 a[i]的子集 
    for(int i=1; i<=n; ++i){
        a[i] = 0;
        for(int j=0; j<m; ++j){
            char c;
            cin >> c;
            a[i] = 2 * a[i] | (c == 'P');
        }
    }

    int ans = 0;
//  不懂的地方：为什么不需要初始化？
    for(int i=1; i<=n; ++i){
        for(int j=0; j<idx; ++j){
            for(int k=0; k<idx; ++k){
                for(int l=0; l<idx; ++l){
                    // 过滤第二种非法的行状态 
                    if(st[j] & ~a[i]) continue;
                    if(st[k] & ~a[i-1]) continue;
                    if(st[l] & ~a[i-2]) continue;

                    // 过滤非法的行间状态 
                    if(st[j] & st[k]) continue;
                    if(st[j] & st[l]) continue;
                    if(st[l] & st[k]) continue;

                    f[i][j][k] = max(f[i][j][k], f[i-1][k][l] + num[j]);
                    ans = max(ans, f[i][j][k]);
                }
            }
        }
    }
    cout << ans << '\n';
}
```

如果问题求的是方案数，那么核心代码为

```cpp
cin >> n >> m;
mm = 1 << m;
for(int i=0; i<mm; ++i){
    // 列内合法条件1 
    if(i<<1&i || i>>1&i) continue;
    if(i<<2&i || i>>2&i) continue;
    st[idx] = i, num[idx] = 0;
    for(int j=i; j; j-=j&-j) ++ num[idx];
    ++ idx;
}

for(int i=1; i<=n; ++i){
    for(int j=0; j<m; ++j){
        char c;
        cin >> c;
        a[i] = 2 * a[i] + (c == 'P');
    }
}

// 初始化
for(int j=0; j<idx; ++j)
    for(int k=0; k<idx; ++k){
        if(st[j] & ~a[2]) continue;
        if(st[k] & ~a[1]) continue;

        if(st[j] & st[k]) continue;
        f[2][j][k] = 1;
    }
for(int i=3; i<=n; ++i){
    for(int j=0; j<idx; ++j){
        // st[j] 交 a[i]的补集 非空 
        for(int k=0; k<idx; ++k){
            for(int l=0; l<idx; ++l){
                if(st[j] & ~a[i]) continue;
                if(st[k] & ~a[i-1]) continue;
                if(st[l] & ~a[i-2]) continue;

                if(st[j] & st[k]) continue;
                if(st[j] & st[l]) continue;
                if(st[k] & st[l]) continue;
                f[i][j][k] = (f[i][j][k] + f[i-1][k][l]);
            }
        }
    }
}
int ans = 0;
for(int j=0; j<idx; ++j) for(int k=0; k<idx; ++k) ans += f[n][j][k];
cout << ans << '\n';
```

+ [P1879 [USACO06NOV]Corn Fields G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1879)

+ [P2051 [AHOI2009] 中国象棋 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2051)（好题）

题意：$n\times m$ 矩阵放置互不攻击的炮的方案数

（错误的状态划分： $f_{i,~~j,~~k}$  表示 $i\times m$ 的矩阵中 $第j列$ 的炮数为 $k$ 的方案（因为 $f_{i,~~j_1,~~k}$ 和 $f_{i,~~j_2,~k},j_1\ne j_2$ 会有交集））

状态定义：$f_{i,~j,~k}$ 表示 $i\times m$ 的矩阵中 有 $j(\in 0..m)$ 列的炮的总数为2，有 $k(\in 0..m-j)$ 列的炮的总数为1，则 有 $l ~:=~ m-j-k$ 列的炮的总数为0

设元组$(x_2,~x_1,~x_0)$ （$\sum\limits_{t=0}^2 x_t\le 2$）表示对于某个 $i-1\times m$ 矩阵，取出 $x_t(t=0..2)$ 个炮数为 $i$ 的列，第 $i$ 行的这些列放置恰好 $x_t$ 个炮，此时炮数为 $t$ 的列数 $-1$，炮数为 $ t+1$ 的列数 $+1$ 

那么，$f_{i,~~j,~~k}$ 可以分为6类：$(0,~0,~0)、(0,~~1,~~0)、(0,~~0,~~1)、(0,~~1,~~1)、(0,~~2,~~0)、(0,~~0,~~2)$

分别对应 $f_{i-1,~j,~k}、f_{i-1,~~j-1,~~k+1}、f_{i-1,~~j,~~k-1}、f_{i-1,~~j-1,~~k}、f_{i-1,~~j-2,~~k+2}、f_{i-1,~~j,~~k-2}$

```cpp
#include<iostream>
using namespace std;

#define int long long
const int p = 9999973;
int n, m;
int f[2][103][103];

int c(int n){
    return n * (n - 1) / 2 % p;
}
signed main(){
    cin >> n >> m;

    f[0][0][0] = 1;
    for(int i=1; i<=n; ++i){
        for(int j=0; j<=m; ++j){
            for(int k=0; j+k<=m; ++k){
                int l = m - j - k;
                #define f0 f[i & 1][j][k]
                #define f1 f[i-1 & 1]
                f0 = f1[j][k];
                if(j-1 >= 0 && k+1<=m)
                    f0 = (f0 + f1[j-1][k+1] * (k + 1) % p) % p;
                if(k-1 >= 0 && l+1<=m)
                    f0 = (f0 + f1[j][k-1] * (l + 1) % p) % p;
                if(j-1 >= 0 && l+1<=m)
                    f0 = (f0 + f1[j-1][k] * k * (l + 1) % p) % p;
                if(j-2 >= 0 && k+2<=m)
                    f0 = (f0 + f1[j-2][k+2] * c(k + 2) % p) % p;
                if(k-2 >= 0 && l+2<=m)
                    f0 = (f0 + f1[j][k-2] * c(l + 2) % p) % p;
            }
        }
    }
    int ans = 0;
    for(int j=0; j<=m; ++j){
        for(int k=0; j+k<=m; ++k){
            ans = (ans + f[n & 1][j][k]) % p;
        }
    }
    cout << ans << '\n';
}
```

+ [#2471. 「九省联考 2018」一双木棋 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/2471)

###### 8，数位dp（待补）

+ 1）[Luogu P2602 数字计数](https://www.luogu.com.cn/problem/P2602)

（属性计数）

求$[lb,~ub]$ 中各位数字出现的次数

记 $f_i$ 为前 $i$ 位的所有十进制数中，各位数$(0~..~9)$出现的次数，

易得 $f_i~=~10^{i-1} + f_{i-1}\times 10$

（记 $a_i(\le 9)$ 为第 $i(i\ge 1)$ 位的数字；确定 $a_i$ 为任意数时，第 $i$ 位贡献为$10^{i-1}$；$a_i=0..9$ 时，前$i-1$ 位 的贡献为 $10\times f_{i-1}$）

```cpp
#define int long long
const int N = 15;
int f[N], mi[N];
void init(){
    mi[0] = 1;
    for(int i=1; i<N; ++i){
        f[i] = 10 * f[i-1] + mi[i-1];
        mi[i] = mi[i-1] * 10;
    }
}

int len, a[N], ans[N], ans1[N];
void get(int n, int ans[]){
    int s = n;
    for(len = 0; n; n /= 10) a[ ++ len] = n % 10;
    for(int i=len; i>=1; --i){
        for(int j=0; j<10; ++j) ans[j] += a[i] * f[i-1];
        for(int j=0; j<a[i]; ++j) ans[j] += mi[i-1];
        s -= a[i] * mi[i-1], ans[a[i]] += s + 1;
        ans[0] -= mi[i-1];
    }
}
```

+ 2）[hdu 2089 不要62](https://vjudge.net/problem/HDU-2089)

（限制计数）

统计 $[lb,~ub]$ 内不能有 “子串” “62”或 “4”的数的个数

该题涉及到相邻位，用如下方法可以“暴力”解决（但是常数为 $100$）

```cpp
#define int long long
const int N = 15;

int f[N][10], g[N], mi[N];
void init(){
    f[0][0] = 1; 
    for(int i=1; i<N; ++i){
        int s = 0;
        for(int j=0; j<10; ++j){
            if(j==4) continue;
            for(int k=0; k<10; ++k){
                if(k==4) continue;
                if(j==6&&k==2) continue;
                f[i][j] += f[i-1][k];
            }
            s += f[i][j];
        }
        g[i] = s;
    }
}
int get(int n){
//    if(n==-1) return 0;
    int ans = 0;
    int len, a[N] = {};
    for(len = 0; n; n/=10) a[ ++ len] = n % 10;
    for(int i=len; i>=1; --i){
        for(int j=0; j<a[i]; ++j){
            if(j==4 || a[i+1]==6 && j==2) continue;
            ans += f[i][j];
        }
        if(a[i]==4 || a[i+1]==6&&a[i]==2) break;
    }
    return ans;
}
```

更优算法：[数位 DP - OI Wiki (oi-wiki.org)](https://oi-wiki.org/dp/number/#%E4%BE%8B%E9%A2%98%E4%BA%8C)

+ 3）[SCOI2009 windy 数](https://loj.ac/problem/10165)
