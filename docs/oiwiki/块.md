###### 1，分块思想

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-25-15-52-57-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-25-15-52-52-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-25-15-53-16-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-25-15-53-40-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-25-15-53-59-image.png)

+ 区间和

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-25-20-46-35-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-25-20-46-47-image.png)

[#6280. 数列分块入门 4 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/6280)

区间改值：$O(\sqrt{n})$，区间查询：$O(\sqrt{n})$

```cpp
int n, a[N];
// id表示块号； add、s 分别为 某个分块 的加法懒标记、实际的和
int id[N], len, add[N], s[N];
void init(){
    len = sqrt(n);
    for(int i=1; i<=n; ++i) id[i] = (i - 1) / len + 1, s[id[i]] += a[i];
}
void madd(int lb, int ub, int w){
    if(id[lb] == id[ub]){
        for(int i=lb; i<=ub; ++i) a[i] += w, s[id[i]] += w;
        return ;
    }
    for(int i=lb; id[i]==id[lb]; ++i) a[i] += w, s[id[i]] += w;
    for(int i=ub; id[i]==id[ub]; --i) a[i] += w, s[id[i]] += w;
    for(int i=id[lb]+1; i<id[ub]; ++i) add[i] += w, s[i] += w * len;
}

// 带取模的查询
int get(int lb, int ub, int P){
    int ans = 0;
    if(id[lb] == id[ub]){
        for(int i=lb; i<=ub; ++i) ans = (ans + a[i] + add[id[i]]) % P;
        return ans;
    }
    for(int i=lb; id[i]==id[lb]; ++i) ans = (ans + a[i] + add[id[i]]) % P;
    for(int i=ub; id[i]==id[ub]; --i) ans = (ans + a[i] + add[id[i]]) % P;
    for(int i=id[lb]+1; i<id[ub]; ++i) ans = (ans + s[i]) % P;
    return ans;
}
```

+ 区间和2（待补）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-25-20-57-30-image.png)

+ 对查询分块

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-25-20-59-20-image.png)

+ 其他问题

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-25-21-36-27-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-25-21-36-31-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-25-21-36-37-image.png)

[UVA12003 Array Transformer - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/UVA12003)

[``Dynamic'' Inversion - UVA 11990 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/UVA-11990)

###### 2，分块数组

初始化（最简单的结构）

```cpp

int id[N], len;
void init(){
	len = sqrt(n);
	for(int i=1; i<=n; ++i) id[i] = (i-1)/len+1
}


```

分块数组有很高的扩展性！！

可解决问题（目前总结到的）：

1，区间加法：$add[~]$ 懒标记，则点值可以表示为 $a_i+add_{id[i]]}$

2，区间和查询：每个块添加字段 $s[~]$；$a_i$ 或 $add_{id[i]}$更新（即点值更新）时 $s_i$ 也需要更新

3，区间大于k的数目查询：添加分块副本 $vetor<int>r[~]$，块内排序，查询时累计贡献；点值更新时需要对块内重新排序

4，区间乘法：$mul[~]$ 懒标记

+ 例题1：[P2801 教主的魔法 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2801)

题意：区间加法 + 区间大于k的数目查询

（需要开$O2$ 优化，原因不明）

```cpp

#include<bits/stdc++.h>
#define sort(u) sort(begin(u), end(u))
#define lb(u, w) lower_bound(begin(u), end(u), w)
using namespace std;

const int N = 1e6+3, M = 1e3+3;
int n, a[N];
int id[N], len;
// 针对查询的分块副本，块内排序（每个块在原数据更新后需重新排序）
vector<int> r[M];
// 区间加法懒标记
int add[M];
void init(){
	len = sqrt(n);
	for(int i=1; i<=n; ++i) id[i] = (i-1)/len+1, r[id[i]].push_back(a[i]);
	for(int i=1; i<=id[n]; ++i) sort(r[i]);
}
// 更新分块副本
void so(int k){
	r[k].clear();
	int lb = (k-1)*len+1, ub = min(k*len, n);
	for(int i=lb; i<=ub; ++i) r[k].push_back(a[i]);
	sort(r[k]);
}
void madd(int lb, int ub, int w){
	int x = id[lb], y = id[ub];
	if(x == y){
		for(int i=lb; i<=ub; ++i) a[i] += w;
		so(x);
		return ;
	}
	for(int i=lb; id[i]==x; ++i) a[i] += w; so(x);
	for(int i=ub; id[i]==y; --i) a[i] += w; so(y);
	for(int i=id[lb]+1; i<id[ub]; ++i) add[i] += w;
}
int get(int lb, int ub, int w){
	int x = id[lb], y = id[ub];
	int ans = 0;
	if(x == y){
		for(int i=lb; i<=ub; ++i) ans += (a[i]+add[id[i]] < w);
		return ans;
	}
	for(int i=lb; id[i]==x; ++i) ans += (a[i]+add[id[i]] < w);
	for(int i=ub; id[i]==y; --i) ans += (a[i]+add[id[i]] < w);
	for(int i=x+1; i<y; ++i) ans += lb(r[i], w-add[i]) - r[i].begin();
	return ans;
}

int main(){
	int m;
	cin >> n >> m;
	for(int i=1; i<=n; ++i) cin >> a[i];
	init();
	
	for(int i=0; i<m; ++i){
		char op;
		int lb, ub, w;
		cin >> op >> lb >> ub >> w;
		if(op == 'A'){
			cout << ub-lb+1-get(lb, ub, w) << '\n';
		}else{
			madd(lb, ub, w);
		}
	}
}


```

+ 例题2（待补）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-26-16-48-32-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\块状数据结构\assets\2022-07-26-16-48-36-image.png)

[#130. 树状数组 1 ：单点修改，区间查询 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/130)

[#132. 树状数组 3 ：区间修改，区间查询 - 题目 - LibreOJ (loj.ac)](https://loj.ac/p/132)

[P3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3373)

（区间加，区间乘，区间和查询；另外，此题需要**疯狂**吸氧）

```cpp

const int N = 1e5+3, M = 1e3+3;
int n;
long long a[N];
long long P;
int len, id[N];
long long add[M], mul[M], s[M];
void init(){
	len = sqrt(n);
	for(int i=1; i<=n; ++i){
		id[i] = (i-1)/len+1;
		s[id[i]] = (s[id[i]] + a[i]) % P;
		mul[id[i]] = 1;
	}
}
void reset(int k) {
	for(int i=(k-1)*len+1; i<=min(k*len, n); i++)
		a[i] = (a[i] * mul[k] + add[k]) % P;
	mul[k] = 1, add[k] = 0;
}

void madd(int lb, int ub, int w){
	int x = id[lb], y = id[ub];
	if(x == y){
	reset(x);
		for(int i=lb; i<=ub; ++i) a[i] = (a[i] + w) % P, s[id[i]] = (s[id[i]] + w) % P;
		return ;
	}
	reset(x);
	s[id[lb]] = (s[id[lb]] + w * (len * id[lb] - lb + 1)) % P;
	for(int i=lb; id[i]==x; ++i) a[i] = (a[i] + w) % P;
	reset(y);
	s[id[ub]] = (s[id[ub]] + w * (ub - (len * (id[ub] - 1) + 1) + 1)) % P;
	for(int i=ub; id[i]==y; --i) a[i] = (a[i] + w) % P;
	for(int i=x+1; i<y; ++i) add[i] = (add[i] + w) % P, s[i] = (s[i] + w * len ) % P;
}
void mmul(int lb, int ub, int w){
	int x = id[lb], y = id[ub];
	if(x == y){
	reset(x);
		for(int i=lb; i<=ub; ++i) s[id[i]] = (s[id[i]] + a[i] * (w-1) % P) % P, a[i] = (a[i] * w) % P;
		return ;
	}
	reset(x);
	for(int i=lb; id[i]==x; ++i) s[id[i]] = (s[id[i]] + a[i] * (w-1)) % P, a[i] = (a[i] * w) % P;
	reset(y);
	for(int i=ub; id[i]==y; --i) s[id[i]] = (s[id[i]] + a[i] * (w-1)) % P, a[i] = (a[i] * w) % P;
	for(int i=x+1; i<y; ++i) add[i] = add[i] * w % P, mul[i] = mul[i] * w % P, s[i] = s[i] * w % P;
}
long long get(int lb, int ub){
	int x = id[lb], y = id[ub];
	long long ans = 0;
	if(x == y){
		for(int i=lb; i<=ub; ++i) ans = (ans + a[i] * mul[id[i]] + add[id[i]]) % P;
		return ans;
	}
	for(int i=lb; id[i]==x; ++i) ans = (ans + a[i] * mul[id[i]] + add[id[i]]) % P;
	for(int i=ub; id[i]==y; --i) ans = (ans + a[i] * mul[id[i]] + add[id[i]]) % P;
	for(int i=x+1; i<y; ++i) ans = (ans + s[i]) % P;
	return ans;
}



```

[P5048 [Ynoi2019 模拟赛] Yuno loves sqrt technology III - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5048)

[P4168 [Violet]蒲公英 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4168)

[P4135 作诗 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4135)
