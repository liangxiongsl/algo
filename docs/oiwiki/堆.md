###### 1，堆简介

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-11-46-33-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-11-46-41-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-11-46-59-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-11-47-08-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-11-47-20-image.png)

+ 分类

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-11-47-34-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-11-47-42-image.png)

###### 2，二叉堆

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-17-32-03-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-17-32-12-image.png)

+ 插入

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-17-32-43-image.png)

+ 删除

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-17-33-03-image.png)

```cpp
int n, h[N];

void up(int u){
    while(u > 1){
        if(h[u / 2] >= h[u]) break;
        swap(h[u], h[u / 2]);
        u /= 2;
    }
}
void down(int u){
    while(2 * u <= n){
        int v = 2 * u;
        if(v + 1 <= n && h[v] < h[v + 1]) ++ v;
        if(h[u] >= h[v]) break;
        swap(h[u], h[v]);
        u = v;
    }
}
```

+ 建堆

```cpp
void init(int n){
//    O(N*logN), decreasekey
//    for(int i=1; i<=n; ++i) up(i);
//  O(N)
    for(int i=n; i>=1; --i) down(i);
}
```

+ 对顶堆（直接用 $priority\_queue$ ）

大根堆存较小值，小根堆存较大值

两个堆的大致关系（最右边为堆顶）：

$$
大根堆：x_1\le x_2\le..\le x_k \\ 小根堆： x_n\ge x_{n-1}\ge..\ge x_{k+1}
$$

+ + 定义

```cpp
priority_queue<int, vector<int>, less<int> > a;
priority_queue<int, vector<int>, greater<int> > b;
#define mov(a, b) b.push(a.top()), a.pop()
```

+ + 插入

```cpp
if(a.empty() || n <= a.top()) a.push(n);
else b.push(n);
```

+ 维护

```cpp
if(a.size() > k) mov(a, b);
else if(a.size() < k) mov(b, a);
```

[SP16254 RMID2 - Running Median Again - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/SP16254)

[SP15376 RMID - Running Median - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/SP15376)

[P1801 黑匣子 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1801)

###### 3，配对堆

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-21-54-22-image.png)

简单定义：

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-23-06-00-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-23-06-33-image.png)

通常我们使用左儿子右兄弟表示法储存一个配对堆

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-23-06-23-image.png)

+ 存储

就是普通的带权多叉树的表示方式

+ 查询最小值 $O(1)$

返回堆首

+ 合并，插入 $O(1)$

直接把根节点权值较大的那个配对堆设成另一个的儿子

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-23-23-09-28-image.png)

+ 删除最小值 $O(\log{n})$

把儿子们 **从左往右** 两两配成一对，用 `merge` 操作把被配成同一对的两个儿子合并到一起，再将新产生的堆 **从右往左** 暴力合并在一起

```cpp
struct nd{
    // 结点权 
    int x;
    // 左孩子 右兄弟 
    nd *ch, *br;
};

nd* add(nd *u, nd *v){
    if(u == nullptr) return v;
    if(v == nullptr) return u;
    if(u->x > v->x) swap(u, v);
//    将 v 合并到 u
//     v承接u的兄弟 
    v->br = u->ch;
//    v作为 u的儿子 
    u->ch = v;
    return u;
}

nd* mer(nd *u){
    if(u == nullptr || u->br == nullptr) return u;
//    暂存最左边的两个兄弟，然后拆散 
    nd *v = u->br, *w = v->br;
    u->br = v->br = nullptr;
    return add(add(u, v), mer(w));
}
nd *del(nd *u){ return mer(u->ch); }
```

+ 减小 一个元素的值 $O(n)$ （待补）

（较为繁杂）

###### 4，左偏堆（待补）

+ dist

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-24-07-35-58-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-24-07-36-07-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-24-07-36-21-image.png)

+ 定义

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-24-07-37-13-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\堆\assets\2022-07-24-07-37-18-image.png)

+ 合并

[P3377 【模板】左偏树（可并堆） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3377)

[P1456 Monkey King - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1456)

[P2713 罗马游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2713)

[P1552 [APIO2012] 派遣 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1552)

[P3261 [JLOI2015]城池攻占 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3261)

[P3273 [SCOI2011]棘手的操作 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3273)

[P4331 [BalticOI 2004]Sequence 数字序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4331)
