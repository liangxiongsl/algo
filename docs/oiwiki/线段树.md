###### 1，简介

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-01-11-14-28-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-01-14-29-13-image.png)

（幺群）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-01-14-59-42-image.png)

###### 2，朴素线段树（区间加/赋值/乘/min/max/xor + 区间查）

如数组 $a=\{10,11,12,13,14\}$ 对应的线段树：

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-01-21-55-21-image.png)

+ 1，建树

```cpp
// 减短长串的函数头声明；注意默认参数
#define head int lb = 1, int ub = n, int u = 1
// m, lc, rc 能确定左右儿子的 区间 和 结点编号
#define def int m = lb + ub >> 1, lc = u<<1, rc = lc+1
const int N = 4e5+3;    // 取四倍大小
int a[N], n;

long long sum[N], add[N];
void init(head){
    def;
    if(lb == ub) return void(sum[u] = a[lb]);
    init(lb, m, lc), init(m+1, ub, rc);
    sum[u] = sum[lc] + sum[rc];
}
```

递归步骤：

1，$lb == ub$ ：出口，对区间和 $sum$ 赋值

2，$down()$：无

3，分治 $(lb,~mid,~lc),~(mid+1, ub,~rc)$

4，$up()$：儿子更新父亲的权值（刚好与出口"对立"）

+ + 线段树的大小

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-01-22-21-29-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-01-22-21-37-image.png)

（总结：取 $4\times n$ 的大小能绝对避免 $segment~fault$ ）

+ 2，区间操作，区间查询

步骤：

1，$l\le lb~~\&\&~~r\ge ub$：出口，更新 结点$u$ 的权值 或 懒标记（对更新操作而言），或返回权值（对查询操作而言）

（常见的权值：$sum_u$ ；常见的懒标记：$$）

2，$down()$：更新两个儿子的懒标记（下方懒标记）

3，分治：若 $l\le mid$，则分治 $(lb,~mid,~lc)$；若 $r > mid$，则 $~(mid+1,~ub,~rc)$

4，$up()$：从两个儿子更新父亲的权值（仅 更新 或 初始化时 需要）

+ + 区间加法

```cpp
void madd(int l, int r, int w, head){
    def;
    if(l <= lb && r >= ub) return void((sum[u] += len * w, add[u] += w));

    if(add[u]){
        sum[lc] += llen * add[u], add[lc] += add[u];
        sum[rc] += rlen * add[u], add[rc] += add[u];
        add[u] = 0;
    }

    if(l <= m) madd(l, r, w, lb, m, lc);
    if(r > m) madd(l, r, w, m+1, ub, rc);
    sum[u] = sum[lc] + sum[rc];
}

long long gsum(int l, int r, head){
    def;
    long long ans = 0;
    if(l <= lb && r >= ub) return sum[u];

    if(add[u]){
        sum[lc] += llen * add[u], add[lc] += add[u];
        sum[rc] += rlen * add[u], add[rc] += add[u];
        add[u] = 0;
    }

    if(l <= m) ans += gsum(l, r, lb, m, lc);
    if(r > m) ans += gsum(l, r, m+1, ub, rc);
    return ans;
}
```

+ + 区间赋值

```cpp
int sum[N], as[N];
void mas(int l, int r, int w, head){
    def;
    if(l <= lb && r >= ub) return void((sum[u] = (ub - lb + 1) * w, as[u] = w));

    if(as[u]){
        sum[lc] = (mid - lb + 1) * as[u], as[lc] = as[u];
        sum[rc] = (ub - mid) * as[u], as[rc] = as[u];
        as[u] = 0;
    }

    if(l <= mid) mas(l, r, w, lb, mid, lc);
    if(r > mid) mas(l, r, w, mid+1, ub, rc);
    sum[u] = sum[lc] + sum[rc];
}
long long gsum(int l, int r, head){
    def;
    if(l <= lb && r >= ub) return sum[u];

    if(as[u]){
        sum[lc] = (mid - lb + 1) * as[u], as[lc] = as[u];
        sum[rc] = (ub - mid) * as[u], as[rc] = as[u];
        as[u] = 0;
    }
    long long ans = 0;
    if(l <= mid) ans += gsum(l, r, lb, mid, lc);
    if(r > mid) ans += gsum(l, r, mid+1, ub, rc);
    return ans;
}
```

+ + 区间加法 + 区间乘法

```cpp
#define head int lb = 1, int ub = n, int u = 1
#define def int mid = lb+ub>>1, lc = u<<1, rc = lc + 1
const int N = 4e5+3;
int a[N], n, P = 1e9+7;

long long sum[N], add[N], mul[N];
void init(head){
    def;
    // 注意 mul_u 的初始化 
    mul[u] = 1;
    if(lb == ub) return void(sum[u] = a[lb]);
    init(lb, mid, lc), init(mid+1, ub, rc);
    sum[u] = sum[lc] + sum[rc];
}
void down(head){
    def;
    if(mul[u] != 1){
        sum[lc] = sum[lc] * mul[u] % P, add[lc] = add[lc] * mul[u] % P, 
            mul[lc] = mul[lc] * mul[u] % P;
        sum[rc] = sum[rc] * mul[u] % P, add[rc] = add[rc] * mul[u] % P, 
            mul[rc] = mul[rc] * mul[u] % P;
        mul[u] = 1;
    }
    if(add[u]){
        sum[lc] = (sum[lc] + (mid - lb + 1) * add[u]) % P, 
            add[lc] = (add[lc] + add[u]) % P;
        sum[rc] = (sum[rc] + (ub - mid) * add[u]) % P, 
            add[rc] = (add[rc] + add[u]) % P;
        add[u] = 0;
    }
}
void madd(int l, int r, int w, head){
    def;
    if(l <= lb && r >= ub) return void((
sum[u] = (sum[u] + (ub - lb + 1) * w) % P, add[u] = (add[u] + w) % P)
    );
    down(lb, ub, u);
    if(l <= mid) madd(l, r, w, lb, mid, lc);
    if(r > mid) madd(l, r, w, mid+1, ub, rc);
    sum[u] = (sum[lc] + sum[rc]) % P;
}
void mmul(int l, int r, int w, head){
    def;
    if(l <= lb && r >= ub) return void((
sum[u] = sum[u] * w % P, add[u] = add[u] * w % P, mul[u] = mul[u] * w % P
));
    down(lb, ub, u);
    if(l <= mid) mmul(l, r, w, lb, mid, lc);
    if(r > mid) mmul(l, r, w, mid+1, ub, rc);
    sum[u] = (sum[lc] + sum[rc]) % P;
}
long long gsum(int l, int r, head){
    def;
    if(l <= lb && r >= ub) return sum[u];
    down(lb, ub, u);
    long long ans = 0;
    if(l <= mid) ans = (ans + gsum(l, r, lb, mid, lc)) % P;
    if(r > mid) ans = (ans + gsum(l, r, mid+1, ub, rc)) % P;
    return ans;
}
```

+ 一些小优化

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-01-22-32-03-image.png)

+ [P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3372)

+ [P3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3373)

+ [线段树的区间修改 - HihoCoder 1078 - Virtual Judge (csgrandeur.cn)](https://vjudge.csgrandeur.cn/problem/HihoCoder-1078)

+ [Glad You Came - HDU 6356 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/HDU-6356)

+ [P6242 【模板】线段树 3 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P6242)

###### 3，猫树（待补）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-02-16-45-43-image.png)


### 无修改区间，树上询问 ###


[一种高效处理无修改区间或树上询问的数据结构（附代码） - 博客 - immortalCO的博客 (uoj.ac)](https://immortalco.blog.uoj.ac/blog/2102)

###### 1，前言

+ 问题描述

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-02-17-08-32-image.png)

+ 问题举例

+ + 1，可减信息（区间和、区间异或和）：

> 直接用前缀和实现，$O(n)+O(1)+O(n)$

+ + 2，可重复贡献信息（区间最值）

> 如果序列很长，使用线段树即可，复杂度 $O(n)+O(logn)+O(n)$

> 如果询问很多，但序列不是特别长，可以用倍增的 RMQ，复杂度 $O(n\log n)+O(1)+O(n\log n)$

> 如果序列很长，询问也很多，可以对序列线性建立笛卡尔树转为 LCA 问题，然后转为正负 1 RMQ，每 $\log n$ 分一段打表预处理，复杂度 $O(n)+O(1)+O(n)$

（WTF？）

+ + 3，仅满足支持结合律和快速合并，如最大子段和、区间的串哈希值

> 一般使用线段树实现，复杂度 $O(n)+O(\log n)+O(n)$

+ + 4，而**猫树**可以做到 $ O(n\log n)+O(1)+O(n\log n)$ 的复杂度

+ 应用

+ + 1，最大区间字段和

+ + 2，$NAND$ （与非运算）

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-02-17-35-07-image.png)

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-02-17-35-26-image.png)

+ + 3，区间

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-02-17-37-52-image.png)

+ + 4，BZOJ4540

![](D:\Document%20And%20Settings2\lx\Desktop\oi-wiki\数据结构\线段树\assets\2022-08-02-17-39-55-image.png)


