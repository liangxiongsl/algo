避雷（bug）方案：

1，初始化（注意集合标识的离散化）

2，并查集维护**有向环**，判断**环的存在性**

3，并查集维护图的所有连通分量数量

4，并查集维护某一连通分量内的**优先级最高**的点（即祖先）

（并查集多用于逻辑关系的判断；带权并查集关注的不是元素的属性，而是元素之间的**关系**；并查集是 **狭义上的无向图**）

（男题：$F$）

###### A，动态合并+查询

###### B，维护并查集大小

###### C，查询并查集森林的数目

###### D，带权并查集维护区间和（判环问题）

（$w_u$ 可以看作是 $u$ 到 祖宗 $f$ 的向量）

**左闭右开** 或 **左开右闭** 区间可以满足 “**可加性**”，例如$[1,~4)+[4,~7)=[1,~7)$

以下代码可满足之前所构建的所有关系的情况下，关系 $w_{u\to v}$ 是否正确，另外如果 $u,~v$ 之间是独立的，那么利用 $w_{u\to v}$ 构建 $u,~v$ 之间的关系

```cpp
bool add(int u, int v, int rel){
    int x = find(u), y = find(v);
    if(x == y) return rel == w[u] - w[v];
    fa[x] = y;
    w[x] = rel + w[v] - w[u];
    return true;
}
```

###### E，“种类”并查集，可以用带权并查集解决（”模P意义下的加法群“）

```cpp
int find(int u){
    int f = fa[u];
    if(f == u) return u;
    int f1 = find(f);
    w[u] = (w[u] + w[f]) % P;
    return fa[u] = f1;
}
bool add(int u, int v, int rel){
    int x = find(u), y = find(v);
//  此处必须模P，而其他地方在不溢出的情况下可以不模P
    if(x == y) return rel % P == (w[u] - w[v] + P) % P;
    w[x] = (rel + w[v] - w[u] + P) % P;
    fa[x] = y;
    return true;
}
```

###### F，“种类”并查集 + 计数背包dp（+  方案）

有两类人，好人和坏人，分别有 $a$，$b$ 个

给出 $m$ 条信息描述： $u$ 说 $v$ 是好人或坏人（好人说话不会说谎，而坏人必然会说谎

这些描述其实可以反映 $u$ 和 $v$ 的关系，即 $u$ 和 $v$ 的性质的关系（此题是模2加法群，只有**相同** 或 **相异** 关系；但这些描述不会反映 $u$ 或 $v$ 是好人还是坏人）

思路：通过描述构建完并查集森林后，我们知道每个并查集又分为 $P=2$ 个子集，每个子集为 “好人集合” 或 “坏人集合”，用人数标识，得到二维数组 $num[cnt][P]$（$cnt$ 为并查集数量，$P=2$），要判断 $a=\sum\limits_{i=1}^{cnt}num_{i,~op}$ 是否唯一，可以考虑用 "计数类"的背包dp（我称之为 “1 2背包”）

声明：

```cpp
int idx, mp[N], num[N][2];
// g[] 记录 f[][] 的 "路径"，值域记录 f的第二维，相当于降一个维度
int f[N][N], g[N];
```

1）dp之间进行 **离散化** + 构造 $num$ 数组：

（**离散化是转化为dp问题的接口！！**）

```cpp
idx = 0, memset(mp, 0, sizeof mp);
memset(num, 0, sizeof num);
for(int i=1; i<=n; ++i){
    int f = find(i);
    if(!mp[f]) mp[f] = ++ idx;
    ++ num[mp[f]][w[i]];
}
```

2）”1 2计数dp“

```cpp
memset(f, 0, sizeof f);
memset(g, 0, sizeof g);
f[0][0] = 1;
for(int i=1; i<=idx; ++i){
    for(int j=0; j<=a; ++j){
        if(j >= num[i][0]) f[i][j] = f[i-1][j-num[i][0]];
        if(j >= num[i][1]) f[i][j] += f[i-1][j-num[i][1]];
    }
}
```

3）回溯 唯一方案

```cpp
// 方案不唯一，则退出
if(f[idx][a] != 1){
    puts("no");
    continue;
}
int j = a;
for(int i=idx; i>=1; --i){
    if(f[i-1][j-num[i][0]] == 1) j -= num[i][0], g[i] = 0;
    else j -= num[i][1], g[i] = 1;
}
for(int i=1; i<=n; ++i){
    int f = find(i);
    if(w[i] == g[mp[f]]) printf("%d\n", i);
}
```

###### G，贪心 + 并查集优化标记数组

给定 $n$ 个商品，具有 价值 $v$ 和 过期时间 $t$（以天为单位），一天只能卖一个商品，求最大化收益

贪心策略（不会证。。）：对价值降序，每次选择不大于 $t_i$ 的最接近 $t_i$ 的一天卖掉物品 $i$，可实现最大利润

并查集优化标记数组：因为 $0$ 是不合法的天数，所有查询到 天数$t_i$ 和 $0$ 是同一个并查集时，意味着 物品$i$ 不可卖了，否则查询到的天数 $f$，物品将在 第 $f$ 天卖出

其他优化：单调队列

###### H，"权值区间"并查集 + 离散化

注：模2的加法群的 加法运算 相当于 异或运算

###### I，权值并查集（维护两种权值 x 和 y坐标的位移）

注意：此权值是 一种向量，而非 x或y 的真实坐标，换句话说，权值并查集维护的是某些点的属性之间的关系

```cpp
int fa[N], wx[N], wy[N];
void init(int n){
    for(int i=0; i<=n; ++i){
        fa[i] = i;
        wx[i] = wy[i] = 0;
    }
}
int find(int u){
    int f = fa[u];
    if(f == u) return u;
    int f1 = find(f);
    wx[u] += wx[f];
    wy[u] += wy[f];
    return fa[u] = f1;
}
bool add(int u, int v, int relx, int rely){
    int x = find(u), y = find(v);
    if(x == y) return relx == wx[u] - wx[v] && rely == wy[u] - wy[v];
    fa[x] = y;
    wx[x] = relx + wx[v] - wx[u];
    wy[x] = rely + wy[v] - wy[u];
    return true;
}
// 获取 u, v 两点的哈密顿路径
int get(int u, int v){
    int x = find(u), y = find(v);
//    cout << x << ' ' << y << '\n';
//  u, v 之间可以确定哈密顿路径的必要条件：u 与 v 不独立
    if(x == y) return abs(wx[u] - wx[v]) + abs(wy[u] - wy[v]);
    return -1;
}
```

###### J，常规带权并查集

###### K，带权并查集 + 枚举

题意：一群人进行游戏，这群人分为4类人：1个$judge$ 和 其他3类人，

其中 $judge$ 和 属性会改变，而其他三类人的属性不会改变，换句话说，三类人互相之间的胜负关系不会改变，而 $judge$ 和三类人的胜负关系可能不唯一

给定 $m$ 场比赛的描述，试判断 $judge$ 是谁，若存在且唯一，输出至少需要多少场比赛能够判断

分析：分为三种情况

1）没有 $judge$ 

2）有2个以上的 $judge$

3）仅有一个 $judge$

做法：依次枚举$judge$ 的$id$，若与此人不相关的比赛的能使 $add()$ 返回 $true$，表明该人可以是 $judge$，累加 $judge$ 的个数 $cnt$

若 $judge$唯一，则比赛的轮数为假设其他人为裁判时（实际上不是）使得关系的体系不融洽的最大比赛场次（不会证！！！艸）

（poj会把 **RE** 当成 **WA**，实在是diao）

###### L，动态删边 + 查询连通点内优先级最高的点（离线并查集）

并查集不适合删边，却适合此类查询

”引理“：set实现的**邻接表**可以方便地 删边（本题小重点） 或 删点

删边操作：首先用邻接表建 **初始图**，然后逐步删边，得到 **末状态图** （邻接表）；使用末状态的邻接表建立 末状态的并查集；离线存储询问；然后反向遍历 所有询问，于是**删边操作就等价于加边操作了**

（**注意**：上述的所述的边是**无向边**！！；**引入邻接表的目的是方便并查集的建图**）

查询操作：要使某个点查询后返回最优的点，就需要合理处理合并操作，使用"启发式合并"，如果 $u$ 的根 $x$ 的优先级比 $v$ 的根 $y$ 的优先级大，则交换 $x$ 和 $y$，使得将 $x$ 合并到优先级更高的 $y$ 当中

###### M / N，判断给定边构成的图是否为一颗树

有两种情况：

1）图为空，则该图为树

2）该图只有一个连通分量，而且该图不存在边数 $\ge 2$ 的环（即包括自环） 

并查集的 $add()$ 返回 $false$ 意味着 $u,~v$ 之间存在边数 $\ge 2$ 的环

```cpp
bool add(int u, int v){
    int x = find(u), y = find(v);
    if(x == y) return false;
    fa[x] = y;
    return true;
}
```
